{"text": "<fim_prefix>        }\n        if (possibleToDeadLetter != null && possibleSendToDeadLetterTopicMessages != null) {\n            possibleSendToDeadLetterTopicMessages.put(batchMessage, possibleToDeadLetter);\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"[{}] [{}] enqueued messages in batch. queue size - {}, available queue size - {}\", subscription,\n                    consumerName, incomingMessages.size(), incomingMessages.remainingCapacity());\n        }\n        if (skippedMessages > 0) {\n            increaseAvailablePermits(cnx, skippedMessages);\n        }\n    }\n    /**\n     * Record the event that one message has been processed by the application.\n     *\n     * Periodically, it sends a Flow command to notify the broker that it can push more messages\n     */\n    protected synchronized void messageProcessed(Message<?> msg) {\n        ClientCnx currentCnx = cnx();\n        ClientCnx msgCnx = ((MessageImpl<?>) msg).getCnx();\n        lastDequeuedMessage = msg.getMessageId();\n        if (msgCnx != currentCnx) {\n            // The processed message did belong to the old queue that was cleared after reconnection.\n            return;\n        }\n        increaseAvailablePermits(currentCnx);\n        stats.updateNumMsgsReceived(msg);\n        if (conf.getAckTimeoutMillis() != 0) {\n            // reset timer for messages that are received by the client\n            MessageIdImpl id = (MessageIdImpl) msg.getMessageId();\n            if (id instanceof BatchMessageIdImpl) {\n                id = new MessageIdImpl(id.getLedgerId(), id.getEntryId(), getPartitionIndex());\n            }\n            if (partitionIndex != -1) {\n                // we should no longer track this message, TopicsConsumer will take care from now onwards\n                unAckedMessageTracker.remove(id);\n            } else {\n                unAckedMessageTracker.add(id);\n            }\n        }\n    }\n    protected void trackMessage(Message<?> msg) {\n        if (msg != null) {\n            MessageId messageId = msg.getMessageId();\n            if (conf.getAckTimeoutMillis() > 0 && messageId instanceof MessageIdImpl) {\n                MessageIdImpl id = (MessageIdImpl)messageId;\n                if (id instanceof BatchMessageIdImpl) {\n                    // do not add each item in batch message into tracker\n                    id = new MessageIdImpl(id.getLedgerId(), id.getEntryId(), getPartitionIndex());\n                }\n                unAckedMessageTracker.add(id);\n            }\n        }\n    }\n    void increaseAvailablePermits(ClientCnx currentCnx) {\n        increaseAvailablePermits(currentCnx, 1);\n    }\n    private void increaseAvailablePermits(ClientCnx currentCnx, int delta) {\n        int available = AVAILABLE_PERMITS_UPDATER.addAndGet(this, delta);\n        while (available >= receiverQueueRefillThreshold && !paused) {\n            if (AVAILABLE_PERMITS_UPDATER.compareAndSet(this, available, 0)) {\n                sendFlowPermitsToBroker(currentCnx, available);\n                break;\n            } else {\n                available = AVAILABLE_PERMITS_UPDATER.get(this);\n            }\n        }\n    }\n    @Override\n    public void pause() {\n        paused = true;\n    }\n    @Override\n    public void resume() {\n        if (paused) {\n            paused = false;\n            increaseAvailablePermits(cnx(), 0);\n        }\n    }\n    private ByteBuf decryptPayloadIfNeeded(MessageIdData messageId, MessageMetadata msgMetadata, ByteBuf payload,\n            ClientCnx currentCnx) {\n        if (msgMetadata.getEncryptionKeysCount() == 0) {\n            return payload.retain();\n        }\n        // If KeyReader is not configured throw exception based on config param\n        if (conf.getCryptoKeyReader() == null) {\n            switch (conf.getCryptoFailureAction()) {\n                case CONSUME:\n                    log.warn(\"[{}][{}][{}] CryptoKeyReader interface is not implemented. Consuming encrypted message.\",\n                            topic, subscription, consumerName);\n                    return payload.retain();\n                case DISCARD:\n                    log.warn(\n                            \"[{}][{}][{}] Skipping decryption since CryptoKeyReader interface is not implemented and config is set to discard\",\n                            topic, subscription, consumerName);\n                    discardMessage(messageId, currentCnx, ValidationError.DecryptionError);\n                    return null;\n                case FAIL:\n                    MessageId m = new MessageIdImpl(messageId.getLedgerId(), messageId.getEntryId(), partitionIndex);\n                    log.error(\n                            \"[{}][{}][{}][{}] Message delivery failed since CryptoKeyReader interface is not implemented to consume encrypted message\",\n                             topic, subscription, consumerName, m);\n                    unAckedMessageTracker.add(m);\n                    return null;\n            }\n        }\n        ByteBuf decryptedData = this.msgCrypto.decrypt(msgMetadata, payload, conf.getCryptoKeyReader());\n        if (decryptedData != null) {\n            return decryptedData;\n        }\n        switch (conf.getCryptoFailureAction()) {\n            case CONSUME:\n                // Note, batch message will fail to consume even if config is set to consume\n                log.warn(\"[{}][{}][{}][{}] Decryption failed. Consuming encrypted message since config is set to consume.\",\n                        topic, subscription, consumerName, messageId);\n                return payload.retain();\n            case DISCARD:\n                log.warn(\"[{}][{}][{}][{}] Discarding message since decryption failed and config is set to discard\", topic,\n                        subscription, consumerName, messageId);\n                discardMessage(messageId, currentCnx, ValidationError.DecryptionError);\n                return null;\n            case FAIL:\n                MessageId m = new MessageIdImpl(messageId.getLedgerId(), messageId.getEntryId(), partitionIndex);\n                log.error(\n                        \"[{}][{}][{}][{}] Message delivery failed since unable to decrypt incoming message\",\n                         topic, subscription, consumerName, m);\n                unAckedMessageTracker.add(m);\n                return null;\n        }\n        return null;\n    }\n    private ByteBuf uncompressPayloadIfNeeded(MessageIdData messageId, MessageMetadata msgMetadata, ByteBuf payload,\n            ClientCnx currentCnx) {\n        CompressionType compressionType = msgMetadata.getCompression();\n        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);\n        int uncompressedSize = msgMetadata.getUncompressedSize();\n        int payloadSize = payload.readableBytes();\n        if (payloadSize > PulsarDecoder.MaxMessageSize) {\n            // payload size is itself corrupted since it cannot be bigger than the MaxMessageSize\n            log.error(\"[{}][{}] Got corrupted payload message size {} at {}\", topic, subscription, payloadSize,\n                    messageId);\n            discardCorruptedMessage(messageId, currentCnx, ValidationError.UncompressedSizeCorruption);\n            return null;\n        }\n        try {\n            ByteBuf uncompressedPayload = codec.decode(payload, uncompressedSize);\n            return uncompressedPayload;\n        } catch (IOException e) {\n            log.error(\"[{}][{}] Failed to decompress message with {} at {}: {}\", topic, subscription, compressionType,\n                    messageId, e.getMessage(), e);\n            discardCorruptedMessage(messageId, currentCnx, ValidationError.DecompressionError);\n            return null;\n        }\n    }\n    private boolean verifyChecksum(ByteBuf headersAndPayload, MessageIdData messageId) {\n        if (hasChecksum(headersAndPayload)) {\n            int checksum = readChecksum(headersAndPayload);\n            int computedChecksum = computeChecksum(headersAndPayload);\n            if (checksum != computedChecksum) {\n                log.error(\n                        \"[{}][{}] Checksum mismatch for message at {}:{}. Received checksum: 0x{}, Computed checksum: 0x{}\",\n                        topic, subscription, messageId.getLedgerId(), messageId.getEntryId(),\n                        Long.toHexString(checksum), Integer.toHexString(computedChecksum));\n                return false;\n            }\n        }\n        return true;\n    }\n    private void discardCorruptedMessage(MessageIdData messageId, ClientCnx currentCnx,\n            ValidationError validationError) {\n        log.error(\"[{}][{}] Discarding corrupted message at {}:{}\", topic, subscription, messageId.getLedgerId(),\n                messageId.getEntryId());\n        discardMessage(messageId, currentCnx, validationError);\n    }\n    private void discardMessage(MessageIdData messageId, ClientCnx currentCnx, ValidationError validationError) {\n        ByteBuf cmd = Commands.newAck(consumerId, messageId.getLedgerId(), messageId.getEntryId(), AckType.Individual,\n                                      validationError, Collections.emptyMap());\n        currentCnx.ctx().writeAndFlush(cmd, currentCnx.ctx().voidPromise());\n        increaseAvailablePermits(currentCnx);\n        stats.incrementNumReceiveFailed();\n    }\n    @Override\n    String getHandlerName() {\n        return subscription;\n    }\n    @Override\n    public boolean isConnected() {\n        return getClientCnx() != null && (getState() == State.Ready);\n    }\n<fim_suffix>    int getPartitionIndex() {\n        return partitionIndex;\n    }<fim_middle>// function below has no smell\n"}