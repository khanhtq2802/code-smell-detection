{"text": "<fim_prefix>            proxyUrl = PlatformMiscUtils.getInstance().getEnvironmentVariable(EnvironmentVariables.HTTP_PROXY_URL);\n            logIfDefined(EnvironmentVariables.HTTP_PROXY_URL, proxyUrl);\n            if (StringUtil.isNullOrEmpty(proxyUrl)) {\n                proxyUrl = PlatformMiscUtils.getInstance().getEnvironmentVariable(\n                    EnvironmentVariables.HTTP_PROXY_URL_ALTERNATE);\n                logIfDefined(EnvironmentVariables.HTTP_PROXY_URL_ALTERNATE, proxyUrl);\n            }\n        }\n        if (StringUtil.isNullOrEmpty(proxyUrl)) {\n            log.debug(\"    proxy is not defined in environment variables\"); //$NON-NLS-1$\n            return null;\n        }\n        /*\n         * Check against the NO_PROXY environment variable. (lynx also\n         * documented \"no_proxy\" as lower case here, so we need to check both\n         * the variable and its alternate.)\n         */\n        nonProxyHosts = PlatformMiscUtils.getInstance().getEnvironmentVariable(EnvironmentVariables.NO_PROXY_HOSTS);\n        logIfDefined(EnvironmentVariables.NO_PROXY_HOSTS, nonProxyHosts);\n        if (StringUtil.isNullOrEmpty(nonProxyHosts)) {\n            nonProxyHosts =\n                PlatformMiscUtils.getInstance().getEnvironmentVariable(EnvironmentVariables.NO_PROXY_HOSTS_ALTERNATE);\n            logIfDefined(EnvironmentVariables.NO_PROXY_HOSTS_ALTERNATE, nonProxyHosts);\n        }\n        if (hostExcludedFromProxyEnvironment(connectionInstanceData.getServerURI(), nonProxyHosts)) {\n            log.debug(\"    proxy is defined, but excluded in environment variables\"); //$NON-NLS-1$\n            return null;\n        }\n        URI proxyURI;\n        try {\n            proxyURI = new URI(proxyUrl);\n        } catch (final URISyntaxException e) {\n            final String messageFormat = Messages.getString(\"CLCHttpClientFactory.IllegalProxyURLFormat\"); //$NON-NLS-1$\n            final String message = MessageFormat.format(messageFormat, proxyUrl);\n            log.warn(message, e);\n            throw new IllegalConfigurationException(message, e);\n        }\n        if (proxyURI.getHost() == null) {\n            final String messageFormat = Messages.getString(\"CLCHttpClientFactory.IllegalProxyURLFormat\"); //$NON-NLS-1$\n            final String message = MessageFormat.format(messageFormat, proxyUrl);\n            log.warn(message);\n            throw new IllegalConfigurationException(message);\n        }\n        String username = null, password = null;\n        if (proxyURI.getRawUserInfo() != null) {\n            final String[] userInfo = proxyURI.getRawUserInfo().split(\":\", 2); //$NON-NLS-1$\n            try {\n                username = URLDecoder.decode(userInfo[0], \"UTF-8\"); //$NON-NLS-1$\n                password = URLDecoder.decode(userInfo[1], \"UTF-8\"); //$NON-NLS-1$\n            } catch (final Exception e) {\n                log.warn(\"Could not decode user info as UTF-8\", e); //$NON-NLS-1$\n            }\n        } else {\n            /*\n             * If the proxy credentials were NOT specified in the URI itself,\n             * look up the credentials\n             */\n            final CachedCredentials proxyCredentials = credentialsManager.getCredentials(proxyURI);\n            username = proxyCredentials != null ? proxyCredentials.getUsername() : null;\n            password = proxyCredentials != null ? proxyCredentials.getPassword() : null;\n        }\n        return new CLCHTTPProxyConfiguration(proxyURI.getHost(), proxyURI.getPort(), username, password);\n    }\n    private void logIfDefined(final String name, final String value) {\n        if (!StringUtil.isNullOrEmpty(value)) {\n            log.debug(\"    \" + name + \"=\" + value); //$NON-NLS-1$ //$NON-NLS-2$\n        }\n    }\n    /**\n     * Determines whether the given host should be proxied or not, based on the\n     * pipe-separated list of wildcards to not proxy (generally taken from the\n     * <code>http.nonProxyHosts</code> system property.)\n     *\n     * @param host\n     *        the host to query (not <code>null</code>)\n     * @param nonProxyHosts\n     *        the pipe-separated list of hosts (or wildcards) that should not be\n     *        proxied, or <code>null</code> if all hosts are proxied\n     * @return <code>true</code> if the host should be proxied,\n     *         <code>false</code> otherwise\n     */\n    static boolean hostExcludedFromProxyProperties(final URI serverURI, final String nonProxyHosts) {\n        if (serverURI == null || serverURI.getHost() == null || nonProxyHosts == null) {\n            return false;\n        }\n        for (final String nonProxyHost : nonProxyHosts.split(\"\\\\|\")) //$NON-NLS-1$\n        {\n            /*\n             * Note: for wildcards, the java specification says that the host\n             * \"may start OR end with a *\" (emphasis: mine).\n             */\n            if (nonProxyHost.startsWith(\"*\") //$NON-NLS-1$\n                && LocaleInvariantStringHelpers.caseInsensitiveEndsWith(\n                    serverURI.getHost(),\n                    nonProxyHost.substring(1))) {\n                return true;\n            } else if (nonProxyHost.endsWith(\"*\") //$NON-NLS-1$\n                && LocaleInvariantStringHelpers.caseInsensitiveStartsWith(\n                    serverURI.getHost(),\n                    nonProxyHost.substring(0, nonProxyHost.length() - 1))) {\n                return true;\n            } else if (CollatorFactory.getCaseInsensitiveCollator().equals(serverURI.getHost(), nonProxyHost)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Determines whether the given host should be proxied or not, based on the\n     * comma-separated list of wildcards to not proxy (generally taken from the\n     * <code>http.nonProxyHosts</code> system property.\n     *\n     * @param host\n     *        the host to query (not <code>null</code>)\n     * @param nonProxyHosts\n     *        the pipe-separated list of hosts (or wildcards) that should not be\n     *        proxied, or <code>null</code> if all hosts are proxied\n     * @return <code>true</code> if the host should be proxied,\n     *         <code>false</code> otherwise\n     */\n    static boolean hostExcludedFromProxyEnvironment(final URI serverURI, String nonProxyHosts) {\n        if (serverURI == null || serverURI.getHost() == null || nonProxyHosts == null) {\n            return false;\n        }\n        nonProxyHosts = nonProxyHosts.trim();\n        if (nonProxyHosts.length() == 0) {\n            return false;\n        }\n        /*\n         * The no_proxy setting may be '*' to indicate nothing is proxied.\n         * However, this is the only allowable use of a wildcard.\n         */\n        if (\"*\".equals(nonProxyHosts)) //$NON-NLS-1$\n        {\n            return true;\n        }\n        final String serverHost = serverURI.getHost();\n        /* Map default ports to the appropriate default. */\n        int serverPort = serverURI.getPort();\n        if (serverPort == -1) {\n            try {\n                serverPort = Protocol.getProtocol(serverURI.getScheme().toLowerCase()).getDefaultPort();\n            } catch (final IllegalStateException e) {\n                serverPort = 80;\n            }\n        }\n        for (String nonProxyHost : nonProxyHosts.split(\",\")) //$NON-NLS-1$\n        {\n            int nonProxyPort = -1;\n            if (nonProxyHost.contains(\":\")) //$NON-NLS-1$\n            {\n                final String[] nonProxyParts = nonProxyHost.split(\":\", 2); //$NON-NLS-1$\n                nonProxyHost = nonProxyParts[0];\n                try {\n                    nonProxyPort = Integer.parseInt(nonProxyParts[1]);\n                } catch (final Exception e) {\n                    log.warn(MessageFormat.format(\n                        \"Could not parse port in non_proxy setting: {0}, ignoring port\", //$NON-NLS-1$\n                        nonProxyParts[1]));\n                }\n            }\n            /*\n             * If the no_proxy entry specifies a port, match it exactly. If it\n             * does not, this means to match all ports.\n             */\n            if (nonProxyPort != -1 && serverPort != nonProxyPort) {\n                continue;\n            }\n            /*\n             * Otherwise, the nonProxyHost portion is treated as the trailing\n             * DNS entry\n             */\n            if (LocaleInvariantStringHelpers.caseInsensitiveEndsWith(serverHost, nonProxyHost)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private static class CLCHTTPProxyConfiguration {\n        private final String host;\n        private final int port;\n        private final String username;\n        private final String password;\n<fim_suffix>        public CLCHTTPProxyConfiguration(\n            final String host,\n            final int port,\n            final String username,\n            final String password) {\n            Check.notNull(host, \"host\"); //$NON-NLS-1$\n            this.host = host;\n            this.port = port;\n            this.username = username;\n            this.password = password;\n        }<fim_middle>// function below has no smell\n"}