{"text": "<fim_prefix>        }\n      }\n      try {\n        return connect(op, url);\n      } catch (IOException ioe) {\n        if (redirectHost != null) {\n          if (excludeDatanodes.getValue() != null) {\n            excludeDatanodes = new ExcludeDatanodesParam(redirectHost + \",\"\n                + excludeDatanodes.getValue());\n          } else {\n            excludeDatanodes = new ExcludeDatanodesParam(redirectHost);\n          }\n        }\n        throw ioe;\n      }      \n    }\n    private HttpURLConnection connect(final HttpOpParam.Op op, final URL url)\n        throws IOException {\n      final HttpURLConnection conn =\n          (HttpURLConnection)connectionFactory.openConnection(url);\n      final boolean doOutput = op.getDoOutput();\n      conn.setRequestMethod(op.getType().toString());\n      conn.setInstanceFollowRedirects(false);\n      switch (op.getType()) {\n        // if not sending a message body for a POST or PUT operation, need\n        // to ensure the server/proxy knows this \n        case POST:\n        case PUT: {\n          conn.setDoOutput(true);\n          if (!doOutput) {\n            // explicitly setting content-length to 0 won't do spnego!!\n            // opening and closing the stream will send \"Content-Length: 0\"\n            conn.getOutputStream().close();\n          } else {\n            conn.setRequestProperty(\"Content-Type\",\n                MediaType.APPLICATION_OCTET_STREAM);\n            conn.setChunkedStreamingMode(32 << 10); //32kB-chunk\n          }\n          break;\n        }\n        default: {\n          conn.setDoOutput(doOutput);\n          break;\n        }\n      }\n      conn.connect();\n      return conn;\n    }\n    private T runWithRetry() throws IOException {\n      /**\n       * Do the real work.\n       *\n       * There are three cases that the code inside the loop can throw an\n       * IOException:\n       *\n       * <ul>\n       * <li>The connection has failed (e.g., ConnectException,\n       * @see FailoverOnNetworkExceptionRetry for more details)</li>\n       * <li>The namenode enters the standby state (i.e., StandbyException).</li>\n       * <li>The server returns errors for the command (i.e., RemoteException)</li>\n       * </ul>\n       *\n       * The call to shouldRetry() will conduct the retry policy. The policy\n       * examines the exception and swallows it if it decides to rerun the work.\n       */\n      for(int retry = 0; ; retry++) {\n        checkRetry = !redirected;\n        final URL url = getUrl();\n        try {\n          final HttpURLConnection conn = connect(url);\n          // output streams will validate on close\n          if (!op.getDoOutput()) {\n            validateResponse(op, conn, false);\n          }\n          return getResponse(conn);\n        } catch (AccessControlException ace) {\n          // no retries for auth failures\n          throw ace;\n        } catch (InvalidToken it) {\n          // try to replace the expired token with a new one.  the attempt\n          // to acquire a new token must be outside this operation's retry\n          // so if it fails after its own retries, this operation fails too.\n          if (op.getRequireAuth() || !replaceExpiredDelegationToken()) {\n            throw it;\n          }\n        } catch (IOException ioe) {\n          shouldRetry(ioe, retry);\n        }\n      }\n    }\n    private void shouldRetry(final IOException ioe, final int retry\n        ) throws IOException {\n      InetSocketAddress nnAddr = getCurrentNNAddr();\n      if (checkRetry) {\n        try {\n          final RetryPolicy.RetryAction a = retryPolicy.shouldRetry(\n              ioe, retry, 0, true);\n          boolean isRetry = a.action == RetryPolicy.RetryAction.RetryDecision.RETRY;\n          boolean isFailoverAndRetry =\n              a.action == RetryPolicy.RetryAction.RetryDecision.FAILOVER_AND_RETRY;\n          if (isRetry || isFailoverAndRetry) {\n            LOG.info(\"Retrying connect to namenode: \" + nnAddr\n                + \". Already tried \" + retry + \" time(s); retry policy is \"\n                + retryPolicy + \", delay \" + a.delayMillis + \"ms.\");\n            if (isFailoverAndRetry) {\n              resetStateToFailOver();\n            }\n            Thread.sleep(a.delayMillis);\n            return;\n          }\n        } catch(Exception e) {\n          LOG.warn(\"Original exception is \", ioe);\n          throw toIOException(e);\n        }\n      }\n      throw toIOException(ioe);\n    }\n    abstract T getResponse(HttpURLConnection conn) throws IOException;\n  }\n  /**\n   * Abstract base class to handle path-based operations with params\n   */\n  abstract class AbstractFsPathRunner<T> extends AbstractRunner<T> {\n    private final Path fspath;\n    private final Param<?,?>[] parameters;\n    AbstractFsPathRunner(final HttpOpParam.Op op, final Path fspath,\n        Param<?,?>... parameters) {\n      super(op, false);\n      this.fspath = fspath;\n      this.parameters = parameters;\n    }\n    AbstractFsPathRunner(final HttpOpParam.Op op, Param<?,?>[] parameters,\n        final Path fspath) {\n      super(op, false);\n      this.fspath = fspath;\n      this.parameters = parameters;\n    }\n    @Override\n    protected URL getUrl() throws IOException {\n      if (excludeDatanodes.getValue() != null) {\n        Param<?, ?>[] tmpParam = new Param<?, ?>[parameters.length + 1];\n        System.arraycopy(parameters, 0, tmpParam, 0, parameters.length);\n        tmpParam[parameters.length] = excludeDatanodes;\n        return toUrl(op, fspath, tmpParam);\n      } else {\n        return toUrl(op, fspath, parameters);\n      }\n    }\n  }\n  /**\n   * Default path-based implementation expects no json response\n   */\n  class FsPathRunner extends AbstractFsPathRunner<Void> {\n    FsPathRunner(Op op, Path fspath, Param<?,?>... parameters) {\n      super(op, fspath, parameters);\n    }\n    @Override\n    Void getResponse(HttpURLConnection conn) throws IOException {\n      return null;\n    }\n  }\n  /**\n   * Handle path-based operations with a json response\n   */\n  abstract class FsPathResponseRunner<T> extends AbstractFsPathRunner<T> {\n    FsPathResponseRunner(final HttpOpParam.Op op, final Path fspath,\n        Param<?,?>... parameters) {\n      super(op, fspath, parameters);\n    }\n    FsPathResponseRunner(final HttpOpParam.Op op, Param<?,?>[] parameters,\n        final Path fspath) {\n      super(op, parameters, fspath);\n    }\n    @Override\n    final T getResponse(HttpURLConnection conn) throws IOException {\n      try {\n        final Map<?,?> json = jsonParse(conn, false);\n        if (json == null) {\n          // match exception class thrown by parser\n          throw new IllegalStateException(\"Missing response\");\n        }\n        return decodeResponse(json);\n      } catch (IOException ioe) {\n        throw ioe;\n      } catch (Exception e) { // catch json parser errors\n        final IOException ioe =\n            new IOException(\"Response decoding failure: \"+e.toString(), e);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(ioe);\n        }\n        throw ioe;\n      } finally {\n        conn.disconnect();\n      }\n    }\n    abstract T decodeResponse(Map<?,?> json) throws IOException;\n  }\n  /**\n   * Handle path-based operations with json boolean response\n   */\n  class FsPathBooleanRunner extends FsPathResponseRunner<Boolean> {\n    FsPathBooleanRunner(Op op, Path fspath, Param<?,?>... parameters) {\n      super(op, fspath, parameters);\n    }\n    @Override\n    Boolean decodeResponse(Map<?,?> json) throws IOException {\n      return (Boolean)json.get(\"boolean\");\n    }\n  }\n  /**\n   * Handle create/append output streams\n   */\n  class FsPathOutputStreamRunner extends AbstractFsPathRunner<FSDataOutputStream> {\n    private final int bufferSize;\n    FsPathOutputStreamRunner(Op op, Path fspath, int bufferSize,\n        Param<?,?>... parameters) {\n      super(op, fspath, parameters);\n      this.bufferSize = bufferSize;\n    }\n    @Override\n    FSDataOutputStream getResponse(final HttpURLConnection conn)\n        throws IOException {\n      return new FSDataOutputStream(new BufferedOutputStream(\n          conn.getOutputStream(), bufferSize), statistics) {\n        @Override\n        public void close() throws IOException {\n          try {\n            super.close();\n          } finally {\n            try {\n              validateResponse(op, conn, true);\n            } finally {\n              conn.disconnect();\n            }\n          }\n        }\n      };\n    }\n  }\n  class FsPathConnectionRunner extends AbstractFsPathRunner<HttpURLConnection> {\n    FsPathConnectionRunner(Op op, Path fspath, Param<?,?>... parameters) {\n      super(op, fspath, parameters);\n    }\n<fim_suffix>    @Override\n    HttpURLConnection getResponse(final HttpURLConnection conn)\n        throws IOException {\n      return conn;\n    }<fim_middle>// function below has no smell\n"}