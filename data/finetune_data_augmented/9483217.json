{"text": "<fim_prefix>    LOG.info(\"Stopping container with container Id: \" + containerIDStr);\n    if (container == null) {\n      if (!nodeStatusUpdater.isContainerRecentlyStopped(containerID)) {\n        throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" is not handled by this NodeManager\");\n      }\n    } else {\n      if (container.isRecovering()) {\n        throw new NMNotYetReadyException(\"Container \" + containerIDStr\n            + \" is recovering, try later\");\n      }\n      context.getNMStateStore().storeContainerKilled(containerID);\n      container.sendKillEvent(ContainerExitStatus.KILLED_BY_APPMASTER,\n          \"Container killed by the ApplicationMaster.\");\n      NMAuditLogger.logSuccess(remoteUser, AuditConstants.STOP_CONTAINER,\n          \"ContainerManageImpl\",\n          containerID.getApplicationAttemptId().getApplicationId(),\n          containerID);\n    }\n  }\n  /**\n   * Get a list of container statuses running on this NodeManager\n   */\n  @Override\n  public GetContainerStatusesResponse getContainerStatuses(\n      GetContainerStatusesRequest request) throws YarnException, IOException {\n    List<ContainerStatus> succeededRequests = new ArrayList<ContainerStatus>();\n    Map<ContainerId, SerializedException> failedRequests =\n        new HashMap<ContainerId, SerializedException>();\n    UserGroupInformation remoteUgi = getRemoteUgi();\n    NMTokenIdentifier identifier = selectNMTokenIdentifier(remoteUgi);\n    if (identifier == null) {\n      throw RPCUtil.getRemoteException(INVALID_NMTOKEN_MSG);\n    }\n    String remoteUser = remoteUgi.getUserName();\n    for (ContainerId id : request.getContainerIds()) {\n      try {\n        ContainerStatus status = getContainerStatusInternal(id, identifier,\n            remoteUser);\n        succeededRequests.add(status);\n      } catch (YarnException e) {\n        failedRequests.put(id, SerializedException.newInstance(e));\n      }\n    }\n    return GetContainerStatusesResponse.newInstance(succeededRequests,\n      failedRequests);\n  }\n  protected ContainerStatus getContainerStatusInternal(ContainerId containerID,\n      NMTokenIdentifier nmTokenIdentifier, String remoteUser)\n      throws YarnException {\n    String containerIDStr = containerID.toString();\n    Container container = this.context.getContainers().get(containerID);\n    LOG.info(\"Getting container-status for \" + containerIDStr);\n    authorizeGetAndStopContainerRequest(containerID, container, false,\n        nmTokenIdentifier, remoteUser);\n    if (container == null) {\n      if (nodeStatusUpdater.isContainerRecentlyStopped(containerID)) {\n        throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" was recently stopped on node manager.\");\n      } else {\n        throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" is not handled by this NodeManager\");\n      }\n    }\n    ContainerStatus containerStatus = container.cloneAndGetContainerStatus();\n    logContainerStatus(\"Returning \", containerStatus);\n    return containerStatus;\n  }\n  private void logContainerStatus(String prefix, ContainerStatus status) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(prefix);\n    sb.append(\"ContainerStatus: [\");\n    sb.append(\"ContainerId: \");\n    sb.append(status.getContainerId()).append(\", \");\n    sb.append(\"ExecutionType: \");\n    sb.append(status.getExecutionType()).append(\", \");\n    sb.append(\"State: \");\n    sb.append(status.getState()).append(\", \");\n    sb.append(\"Capability: \");\n    sb.append(status.getCapability()).append(\", \");\n    sb.append(\"Diagnostics: \");\n    sb.append(LOG.isDebugEnabled() ? status.getDiagnostics() : \"...\");\n    sb.append(\", \");\n    sb.append(\"ExitStatus: \");\n    sb.append(status.getExitStatus()).append(\", \");\n    sb.append(\"IP: \");\n    sb.append(status.getIPs()).append(\", \");\n    sb.append(\"Host: \");\n    sb.append(status.getHost()).append(\", \");\n    sb.append(\"ExposedPorts: \");\n    sb.append(status.getExposedPorts()).append(\", \");\n    sb.append(\"ContainerSubState: \");\n    sb.append(status.getContainerSubState());\n    sb.append(\"]\");\n    LOG.info(sb.toString());\n  }\n  @Private\n  @VisibleForTesting\n  protected void authorizeGetAndStopContainerRequest(ContainerId containerId,\n      Container container, boolean stopRequest, NMTokenIdentifier identifier,\n      String remoteUser)\n      throws YarnException {\n    if (identifier == null) {\n      throw RPCUtil.getRemoteException(INVALID_NMTOKEN_MSG);\n    }\n    /*\n     * For get/stop container status; we need to verify that 1) User (NMToken)\n     * application attempt only has started container. 2) Requested containerId\n     * belongs to the same application attempt (NMToken) which was used. (Note:-\n     * This will prevent user in knowing another application's containers).\n     */\n    ApplicationId nmTokenAppId =\n        identifier.getApplicationAttemptId().getApplicationId();\n    if ((!nmTokenAppId.equals(containerId.getApplicationAttemptId().getApplicationId()))\n        || (container != null && !nmTokenAppId.equals(container\n            .getContainerId().getApplicationAttemptId().getApplicationId()))) {\n      String msg;\n      if (stopRequest) {\n        msg = identifier.getApplicationAttemptId()\n            + \" attempted to stop non-application container : \"\n            + containerId;\n        NMAuditLogger.logFailure(remoteUser, AuditConstants.STOP_CONTAINER,\n            \"ContainerManagerImpl\", \"Trying to stop unknown container!\",\n            nmTokenAppId, containerId);\n      } else {\n        msg = identifier.getApplicationAttemptId()\n            + \" attempted to get status for non-application container : \"\n            + containerId;\n      }\n      LOG.warn(msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n  }\n  class ContainerEventDispatcher implements EventHandler<ContainerEvent> {\n    @Override\n    public void handle(ContainerEvent event) {\n      Map<ContainerId,Container> containers =\n        ContainerManagerImpl.this.context.getContainers();\n      Container c = containers.get(event.getContainerID());\n      if (c != null) {\n        c.handle(event);\n        if (nmMetricsPublisher != null) {\n          nmMetricsPublisher.publishContainerEvent(event);\n        }\n      } else {\n        LOG.warn(\"Event \" + event + \" sent to absent container \" +\n            event.getContainerID());\n      }\n    }\n  }\n  class ApplicationEventDispatcher implements EventHandler<ApplicationEvent> {\n    @Override\n    public void handle(ApplicationEvent event) {\n      Application app =\n          ContainerManagerImpl.this.context.getApplications().get(\n              event.getApplicationID());\n      if (app != null) {\n        app.handle(event);\n        if (nmMetricsPublisher != null) {\n          nmMetricsPublisher.publishApplicationEvent(event);\n        }\n      } else {\n        LOG.warn(\"Event \" + event + \" sent to absent application \"\n            + event.getApplicationID());\n      }\n    }\n  }\n  private static final class LocalizationEventHandlerWrapper implements\n      EventHandler<LocalizationEvent> {\n    private EventHandler<LocalizationEvent> origLocalizationEventHandler;\n    private NMTimelinePublisher timelinePublisher;\n    LocalizationEventHandlerWrapper(EventHandler<LocalizationEvent> handler,\n        NMTimelinePublisher publisher) {\n      this.origLocalizationEventHandler = handler;\n      this.timelinePublisher = publisher;\n    }\n    @Override\n    public void handle(LocalizationEvent event) {\n      origLocalizationEventHandler.handle(event);\n      if (timelinePublisher != null) {\n        timelinePublisher.publishLocalizationEvent(event);\n      }\n    }\n  }\n  /**\n   * Implements AuxiliaryLocalPathHandler.\n   * It links NodeManager's LocalDirsHandlerService to the Auxiliary Services\n   */\n<fim_suffix>  static class AuxiliaryLocalPathHandlerImpl\n      implements AuxiliaryLocalPathHandler {\n    private LocalDirsHandlerService dirhandlerService;\n    AuxiliaryLocalPathHandlerImpl(\n        LocalDirsHandlerService dirhandlerService) {\n      this.dirhandlerService = dirhandlerService;\n    }\n    @Override\n    public Path getLocalPathForRead(String path) throws IOException {\n      return dirhandlerService.getLocalPathForRead(path);\n    }\n    @Override\n    public Path getLocalPathForWrite(String path) throws IOException {\n      return dirhandlerService.getLocalPathForWrite(path);\n    }\n    @Override\n    public Path getLocalPathForWrite(String path, long size)\n        throws IOException {\n      return dirhandlerService.getLocalPathForWrite(path, size, false);\n    }\n  }<fim_middle>// class below has no smell\n"}