{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.api.comm;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.hyracks.util.IntSerDeUtils;\n\npublic class FrameHelper {\n    public static int getTupleCountOffset(int frameSize) {\n        return frameSize - FrameConstants.SIZE_LEN;\n    }\n\n    /**\n     * The actual frameSize = frameCount * intitialFrameSize\n     * This method is used to put that frameCount into the first int of the frame buffer.\n     * @param outputFrame\n     * @param numberOfMinFrame\n     */\n<fim_suffix>    public static void serializeFrameSize(ByteBuffer outputFrame, int numberOfMinFrame) {\n        serializeFrameSize(outputFrame, 0, numberOfMinFrame);\n    }\n\n    public static void serializeFrameSize(ByteBuffer outputFrame, int start, int numberOfMinFrame) {\n        IntSerDeUtils.putInt(outputFrame.array(), start + FrameConstants.META_DATA_FRAME_COUNT_OFFSET,\n                numberOfMinFrame);\n    }\n\n    public static int deserializeNumOfMinFrame(ByteBuffer frame) {\n        return deserializeNumOfMinFrame(frame, 0);\n    }\n\n    public static int deserializeNumOfMinFrame(ByteBuffer buffer, int start) {\n        return IntSerDeUtils.getInt(buffer.array(), start + FrameConstants.META_DATA_FRAME_COUNT_OFFSET);\n    }\n\n    /**\n     * Add one tuple requires\n     * 4bytes to store the tuple offset\n     * 4bytes * |fields| to store the relative offset of each field\n     * nbytes the actual data.\n     * If the tupleLength includes the field slot, please set the fieldCount = 0\n     */\n    public static int calcRequiredSpace(int fieldCount, int tupleLength) {\n        return 4 + fieldCount * 4 + tupleLength;\n    }\n\n    /**\n     * A faster way of calculating the ceiling\n     *\n     * @param fieldCount   please set fieldCount to 0 if the tupleLength includes the fields' length\n     * @param tupleLength\n     * @param minFrameSize\n     * @return\n     */\n    public static int calcAlignedFrameSizeToStore(int fieldCount, int tupleLength, int minFrameSize) {\n        assert fieldCount >= 0 && tupleLength >= 0 && minFrameSize > 0;\n        return (1 + (calcRequiredSpace(fieldCount, tupleLength) + FrameConstants.META_DATA_LEN - 1) / minFrameSize)\n                * minFrameSize;\n    }\n\n    public static void clearRemainingFrame(ByteBuffer buffer, int position) {\n        buffer.array()[position] = 0;\n    }\n\n    public static boolean hasBeenCleared(ByteBuffer buffer, int position) {\n        return deserializeNumOfMinFrame(buffer, position) == 0;\n    }\n}<fim_middle>// function below has no smell\n"}