{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.nodes.builtin.base;\nimport static com.oracle.truffle.r.nodes.builtin.CastBuilder.Predef.singleElement;\nimport static com.oracle.truffle.r.runtime.RVisibility.OFF;\nimport static com.oracle.truffle.r.runtime.builtins.RBehavior.COMPLEX;\nimport static com.oracle.truffle.r.runtime.builtins.RBuiltinKind.INTERNAL;\nimport static com.oracle.truffle.r.runtime.env.frame.FrameSlotChangeMonitor.findOrAddFrameSlot;\nimport com.oracle.truffle.api.CompilerDirectives;\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.api.dsl.Cached;\nimport com.oracle.truffle.api.dsl.Specialization;\nimport com.oracle.truffle.api.frame.FrameDescriptor;\nimport com.oracle.truffle.api.frame.FrameSlotKind;\nimport com.oracle.truffle.api.frame.VirtualFrame;\nimport com.oracle.truffle.api.nodes.LoopNode;\nimport com.oracle.truffle.api.profiles.ConditionProfile;\nimport com.oracle.truffle.api.profiles.ValueProfile;\nimport com.oracle.truffle.r.nodes.access.FrameSlotNode;\nimport com.oracle.truffle.r.nodes.access.WriteSuperFrameVariableNode.ResolvedWriteSuperFrameVariableNode;\nimport com.oracle.truffle.r.nodes.access.WriteSuperFrameVariableNodeFactory.ResolvedWriteSuperFrameVariableNodeGen;\nimport com.oracle.truffle.r.nodes.access.WriteVariableNode.Mode;\nimport com.oracle.truffle.r.nodes.builtin.RBuiltinNode;\nimport com.oracle.truffle.r.nodes.builtin.base.AssignNodeGen.AssignInternalNodeGen;\nimport com.oracle.truffle.r.nodes.function.opt.ShareObjectNode;\nimport com.oracle.truffle.r.runtime.RError;\nimport com.oracle.truffle.r.runtime.RRuntime;\nimport com.oracle.truffle.r.runtime.builtins.RBuiltin;\nimport com.oracle.truffle.r.runtime.data.model.RAbstractStringVector;\nimport com.oracle.truffle.r.runtime.env.REnvironment;\nimport com.oracle.truffle.r.runtime.env.REnvironment.PutException;\nimport com.oracle.truffle.r.runtime.nodes.RBaseNode;\n/**\n * The {@code assign} builtin. There are two special cases worth optimizing:\n * <ul>\n * <li>{@code inherits == FALSE}. No need to search environment hierarchy.</li>\n * <li>{@code envir} corresponds to the currently active frame. Unfortunately this is masked\n * somewhat by the signature of the {@code .Internal}, which adds an frame. Not worth optimizing\n * anyway as using {@code assign} for the current frame is highly unlikely.</li>\n * </ul>\n *\n */\n@RBuiltin(name = \"assign\", visibility = OFF, kind = INTERNAL, parameterNames = {\"x\", \"value\", \"envir\", \"inherits\"}, behavior = COMPLEX)\npublic abstract class Assign extends RBuiltinNode.Arg4 {\n    private final boolean direct;\n    protected Assign() {\n        this(false);\n    }\n<fim_suffix>    protected Assign(boolean direct) {\n        this.direct = direct;\n    }\n    public abstract Object execute(VirtualFrame frame, RAbstractStringVector x, Object value, REnvironment pos, byte inherits);\n    @Override\n    public RBaseNode getErrorContext() {\n        return direct ? this : super.getErrorContext();\n    }\n    /**\n     * TODO: This method becomes obsolete when Assign and AssignFastPaths are modified to have the\n     * (String, Object, REnvironment, boolean) signature.\n     */\n    private String checkVariable(RAbstractStringVector xVec) {\n        int len = xVec.getLength();\n        if (len == 1) {\n            return xVec.getDataAt(0);\n        } else if (len == 0) {\n            throw error(RError.Message.INVALID_FIRST_ARGUMENT);\n        } else {\n            warning(RError.Message.ONLY_FIRST_VARIABLE_NAME);\n            return xVec.getDataAt(0);\n        }\n    }\n    static {\n        Casts casts = new Casts(Assign.class);\n        casts.arg(\"x\").asStringVector().shouldBe(singleElement(), RError.Message.ONLY_FIRST_VARIABLE_NAME).findFirst(RError.Message.INVALID_FIRST_ARGUMENT);\n        casts.arg(\"envir\").mustNotBeNull(RError.Message.USE_NULL_ENV_DEFUNCT).mustBe(REnvironment.class, RError.Message.INVALID_ARGUMENT, \"envir\");\n        // this argument could be made Boolean unless there were AssignFastPath relying upon the\n        // byte argument\n        casts.arg(\"inherits\").asLogicalVector().findFirst().mustNotBeNA();\n    }\n    /**\n     * The general case that requires searching the environment hierarchy.\n     */\n    @Specialization\n    protected Object assign(VirtualFrame frame, RAbstractStringVector xVec, Object value, REnvironment envir, byte inherits,\n                    @Cached(\"createBinaryProfile()\") ConditionProfile inheritsProfile,\n                    @Cached(\"create()\") ShareObjectNode share,\n                    @Cached(\"create()\") AssignInternalNode assign) {\n        String x = checkVariable(xVec);\n        REnvironment env = envir;\n        if (inheritsProfile.profile(RRuntime.fromLogical(inherits))) {\n            while (env != REnvironment.emptyEnv()) {\n                if (env.get(x) != null) {\n                    break;\n                }\n                env = env.getParent();\n            }\n            if (env == REnvironment.emptyEnv()) {\n                env = REnvironment.globalEnv();\n            }\n        } else {\n            if (CompilerDirectives.inInterpreter()) {\n                LoopNode.reportLoopCount(this, -1);\n            }\n            if (env == REnvironment.emptyEnv()) {\n                throw error(RError.Message.CANNOT_ASSIGN_IN_EMPTY_ENV);\n            }\n        }\n        assign.execute(frame, env, x, share.execute(value));\n        return value;\n    }\n    protected abstract static class AssignInternalNode extends RBaseNode {\n        public static AssignInternalNode create() {\n            return AssignInternalNodeGen.create();\n        }\n        protected final ValueProfile frameAccessProfile = ValueProfile.createClassProfile();\n        protected final ValueProfile frameProfile = ValueProfile.createClassProfile();\n        public abstract void execute(VirtualFrame frame, REnvironment env, String name, Object value);\n        protected static ResolvedWriteSuperFrameVariableNode createWrite(String name, FrameDescriptor envDesc) {\n            return ResolvedWriteSuperFrameVariableNodeGen.create(name, Mode.REGULAR, null, null, FrameSlotNode.create(findOrAddFrameSlot(envDesc, name, FrameSlotKind.Illegal)));\n        }\n        protected FrameDescriptor getFrameDescriptor(REnvironment env) {\n            return frameProfile.profile(env.getFrame(frameAccessProfile)).getFrameDescriptor();\n        }\n        @Specialization(guards = {\"getFrameDescriptor(env) == envDesc\", \"write.getName().equals(name)\"})\n        protected void assignCached(VirtualFrame frame, REnvironment env, @SuppressWarnings(\"unused\") String name, Object value,\n                        @Cached(\"env.getFrame().getFrameDescriptor()\") @SuppressWarnings(\"unused\") FrameDescriptor envDesc,\n                        @Cached(\"createWrite(name, envDesc)\") ResolvedWriteSuperFrameVariableNode write) {\n            write.execute(frame, value, frameProfile.profile(env.getFrame(frameAccessProfile)));\n        }\n        @Specialization(replaces = \"assignCached\")\n        @TruffleBoundary\n        protected void assign(REnvironment env, String name, Object value) {\n            try {<fim_middle>// function below has no smell\n"}