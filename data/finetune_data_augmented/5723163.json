{"text": "<fim_prefix>      Datetime_typeContext dateTimeType = predefined_type.datetime_type();\n      if (checkIfExist(dateTimeType.DATE())) {\n        typeDefinition = new DataTypeExpr(Type.DATE.name());\n      } else if (checkIfExist(dateTimeType.TIME(0))) {\n        if (checkIfExist(dateTimeType.ZONE())) {\n          typeDefinition = new DataTypeExpr(Type.TIMEZ.name());\n        } else {\n          typeDefinition = new DataTypeExpr(Type.TIME.name());\n        }\n      } else if (checkIfExist(dateTimeType.TIMETZ())) {\n        typeDefinition = new DataTypeExpr(Type.TIMEZ.name());\n      } else if (checkIfExist(dateTimeType.TIMESTAMP())) {\n         if (checkIfExist(dateTimeType.ZONE())) {\n           typeDefinition = new DataTypeExpr(Type.TIMESTAMPZ.name());\n         }  else {\n           typeDefinition = new DataTypeExpr(Type.TIMESTAMP.name());\n         }\n      } else if (checkIfExist(dateTimeType.TIMESTAMPTZ())) {\n        typeDefinition = new DataTypeExpr(Type.TIMESTAMPZ.name());\n      }\n      // bit data types\n    } else if (predefined_type.bit_type() != null) {\n      Bit_typeContext bitType = predefined_type.bit_type();\n      if (checkIfExist(bitType.VARBIT()) || checkIfExist(bitType.VARYING())) {\n        typeDefinition = new DataTypeExpr(Type.VARBIT.name());\n      } else {\n        typeDefinition = new DataTypeExpr(Type.BIT.name());\n      }\n      if (checkIfExist(bitType.type_length())) {\n        typeDefinition.setLengthOrPrecision(\n            Integer.parseInt(bitType.type_length().NUMBER().getText()));\n      }\n      // binary data types\n    } else if (checkIfExist(predefined_type.binary_type())) {\n      Binary_typeContext binaryType = predefined_type.binary_type();\n      if (checkIfExist(binaryType.VARBINARY()) || checkIfExist(binaryType.VARYING())) {\n        typeDefinition = new DataTypeExpr(Type.VARBINARY.name());\n      } else {\n        typeDefinition = new DataTypeExpr(Type.BINARY.name());\n      }\n      if (checkIfExist(binaryType.type_length())) {\n        typeDefinition.setLengthOrPrecision(Integer.parseInt(binaryType.type_length().NUMBER().getText()));\n      }\n    } else if (checkIfExist(predefined_type.complex_type())) {\n      Complex_typeContext complexType = predefined_type.complex_type();\n      if (checkIfExist(complexType.array_type())) {\n        DataTypeExpr elementType = visitData_type(complexType.array_type().data_type());\n        typeDefinition = new DataTypeExpr(new DataTypeExpr.ArrayType(elementType));\n      } else if (checkIfExist(complexType.record_type())) {\n        ColumnDefinition[] nestedRecordDefine = getDefinitions(complexType.record_type().table_elements());\n        typeDefinition = new DataTypeExpr(new DataTypeExpr.RecordType(nestedRecordDefine));\n      } else if (checkIfExist(complexType.map_type())) {\n        Map_typeContext mapTypeContext = complexType.map_type();\n        typeDefinition = new DataTypeExpr(\n            new MapType(visitData_type(mapTypeContext.key_type), visitData_type(mapTypeContext.value_type)));\n      }\n    } else {\n      throw new TajoInternalError(\"Reached code points that shouldn't be reached\");\n    }\n    return typeDefinition;\n  }\n  @Override\n  public Expr visitInsert_statement(Insert_statementContext ctx) {\n    Insert insertExpr = new Insert();\n    if (ctx.OVERWRITE() != null) {\n      insertExpr.setOverwrite();\n    }\n    if (ctx.table_name() != null) {\n      insertExpr.setTableName(buildIdentifierChain(ctx.table_name().identifier()));\n      if (ctx.column_reference_list() != null) {\n        ColumnReferenceExpr [] targetColumns =\n            new ColumnReferenceExpr[ctx.column_reference_list().column_reference().size()];\n        for (int i = 0; i < targetColumns.length; i++) {\n          targetColumns[i] = visitColumn_reference(ctx.column_reference_list().column_reference(i));\n        }\n        insertExpr.setTargetColumns(targetColumns);\n      }\n    }\n    if (ctx.LOCATION() != null) {\n      insertExpr.setLocation(stripQuote(ctx.path.getText()));\n      if (ctx.USING() != null) {\n        insertExpr.setStorageType(ctx.storage_type.getText());\n        if (ctx.param_clause() != null) {\n          insertExpr.setParams(escapeTableMeta(getParams(ctx.param_clause())));\n        }\n      }\n    }\n    if (checkIfExist(ctx.VALUES())) {\n      List<NamedExpr> values = ctx.row_value_predicand().stream()\n          .map(value -> new NamedExpr(visitRow_value_predicand(value)))\n          .collect(Collectors.toList());\n      Projection projection = new Projection();\n      projection.setNamedExprs(values);\n      insertExpr.setSubQuery(projection);\n    } else {\n      insertExpr.setSubQuery(visitQuery_expression(ctx.query_expression()));\n    }\n    Preconditions.checkState(insertExpr.hasTableName() || insertExpr.hasLocation(),\n        \"Either a table name or a location should be given.\");\n    Preconditions.checkState(insertExpr.hasTableName() ^ insertExpr.hasLocation(),\n        \"A table name and a location cannot coexist.\");\n    return insertExpr;\n  }\n  @Override\n  public Expr visitDrop_table_statement(Drop_table_statementContext ctx) {\n    return new DropTable(buildIdentifierChain(ctx.table_name().identifier()),\n        checkIfExist(ctx.if_exists()), checkIfExist(ctx.PURGE()));\n  }\n  private Map<String, String> getParams(Param_clauseContext ctx) {\n    Map<String, String> params = new HashMap<>();\n    for (int i = 0; i < ctx.param().size(); i++) {\n      params.put(stripQuote(ctx.param(i).key.getText()), stripQuote(ctx.param(i).value.getText()));\n    }\n    return params;\n  }\n  public Map<String, String> escapeTableMeta(Map<String, String> map) {\n    Map<String, String> params = new HashMap<>();\n    for (Map.Entry<String, String> entry : map.entrySet()) {\n      if (entry.getKey().equals(StorageConstants.TEXT_DELIMITER)) {\n        params.put(StorageConstants.TEXT_DELIMITER, StringUtils.unicodeEscapedDelimiter(entry.getValue()));\n      } else if (TimeZoneUtil.isTimezone(entry.getKey())) {\n        params.put(StorageConstants.TIMEZONE, TimeZoneUtil.getValidTimezone(entry.getValue()));\n      } else {\n        params.put(entry.getKey(), entry.getValue());\n      }\n    }\n    return params;\n  }\n  private static String stripQuote(String str) {\n    return str.substring(1, str.length() - 1);\n  }\n  @Override\n  public Expr visitCast_specification(Cast_specificationContext ctx) {\n    Expr operand = visitChildren(ctx.cast_operand());\n    DataTypeExpr castTarget = visitData_type(ctx.cast_target().data_type());\n    return new CastExpr(operand, castTarget);\n  }\n  @Override\n  public Expr visitUnsigned_value_specification(@NotNull Unsigned_value_specificationContext ctx) {\n    return visitChildren(ctx);\n  }\n  @Override\n  public Expr visitUnsigned_literal(@NotNull Unsigned_literalContext ctx) {\n    if (checkIfExist(ctx.unsigned_numeric_literal())) {\n      return visitUnsigned_numeric_literal(ctx.unsigned_numeric_literal());\n    } else {\n      return visitGeneral_literal(ctx.general_literal());\n    }\n  }\n  @Override\n  public Expr visitGeneral_literal(General_literalContext ctx) {\n    if (checkIfExist(ctx.Character_String_Literal())) {\n      return new LiteralValue(stripQuote(ctx.Character_String_Literal().getText()), LiteralType.String);\n    } else if (checkIfExist(ctx.datetime_literal())) {\n      return visitDatetime_literal(ctx.datetime_literal());\n    } else {\n      return new BooleanLiteral(checkIfExist(ctx.boolean_literal().TRUE()));\n    }\n  }\n<fim_suffix>  @Override\n  public Expr visitDatetime_literal(@NotNull Datetime_literalContext ctx) {\n    if (checkIfExist(ctx.time_literal())) {\n      return visitTime_literal(ctx.time_literal());\n    } else if (checkIfExist(ctx.date_literal())) {\n      return visitDate_literal(ctx.date_literal());\n    } else if (checkIfExist(ctx.interval_literal())) {\n      return visitInterval_literal(ctx.interval_literal());\n    } else {\n      return visitTimestamp_literal(ctx.timestamp_literal());\n    }\n  }<fim_middle>// function below has no smell\n"}