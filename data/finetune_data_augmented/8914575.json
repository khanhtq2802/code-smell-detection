{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.ql.plan;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\nimport org.apache.hadoop.hive.ql.exec.vector.ColumnVector.Type;\nimport org.apache.hadoop.hive.ql.exec.vector.expressions.IdentityExpression;\nimport org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\nimport org.apache.hadoop.hive.ql.exec.vector.ptf.VectorPTFEvaluatorBase;\nimport org.apache.hadoop.hive.ql.parse.LeadLagInfo;\nimport org.apache.hadoop.hive.ql.plan.Explain.Level;\nimport org.apache.hadoop.hive.ql.plan.Explain.Vectorization;\nimport org.apache.hadoop.hive.ql.plan.VectorPTFDesc.SupportedFunctionType;\nimport org.apache.hadoop.hive.ql.plan.ptf.PTFInputDef;\nimport org.apache.hadoop.hive.ql.plan.ptf.PartitionedTableFunctionDef;\nimport org.apache.hadoop.hive.ql.plan.ptf.WindowFrameDef;\nimport org.apache.hadoop.hive.ql.plan.ptf.WindowTableFunctionDef;\nimport org.apache.hadoop.hive.ql.udf.ptf.Noop;\nimport org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;\nimport org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\nimport org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n@Explain(displayName = \"PTF Operator\", explainLevels = { Level.USER, Level.DEFAULT, Level.EXTENDED })\npublic class PTFDesc extends AbstractOperatorDesc {\n  private static final long serialVersionUID = 1L;\n  @SuppressWarnings(\"unused\")\n  private static final Logger LOG = LoggerFactory.getLogger(PTFDesc.class.getName());\n  PartitionedTableFunctionDef funcDef;\n  transient LeadLagInfo llInfo;\n  /*\n   * is this PTFDesc for a Map-Side PTF Operation?\n   */\n  boolean isMapSide = false;\n  transient Configuration cfg;\n  public PartitionedTableFunctionDef getFuncDef() {\n    return funcDef;\n  }\n  public void setFuncDef(PartitionedTableFunctionDef funcDef) {\n    this.funcDef = funcDef;\n  }\n  public PartitionedTableFunctionDef getStartOfChain() {\n    return funcDef == null ? null : funcDef.getStartOfChain();\n  }\n  @Explain(displayName = \"Function definitions\", explainLevels = { Level.USER, Level.DEFAULT, Level.EXTENDED })\n  public List<PTFInputDef> getFuncDefExplain() {\n    if (funcDef == null) {\n      return null;\n    }\n    List<PTFInputDef> inputs = new ArrayList<PTFInputDef>();\n    for (PTFInputDef current = funcDef; current != null; current = current.getInput()) {\n      inputs.add(current);\n    }\n    Collections.reverse(inputs);\n    return inputs;\n  }\n<fim_suffix>  public LeadLagInfo getLlInfo() {\n    return llInfo;\n  }\n  public void setLlInfo(LeadLagInfo llInfo) {\n    this.llInfo = llInfo;\n  }\n  @Explain(displayName = \"Lead/Lag information\")\n  public String getLlInfoExplain() {\n    if (llInfo != null && llInfo.getLeadLagExprs() != null) {\n      return PlanUtils.getExprListString(llInfo.getLeadLagExprs());\n    }\n    return null;\n  }\n  public boolean forWindowing() {\n    return funcDef instanceof WindowTableFunctionDef;\n  }\n  public boolean forNoop() {\n    return funcDef.getTFunction() instanceof Noop;\n  }\n  @Explain(displayName = \"Map-side function\", displayOnlyOnTrue = true)\n  public boolean isMapSide() {\n    return isMapSide;\n  }\n  public void setMapSide(boolean isMapSide) {\n    this.isMapSide = isMapSide;\n  }\n  public Configuration getCfg() {\n    return cfg;\n  }\n  public void setCfg(Configuration cfg) {\n    this.cfg = cfg;\n  }\n  // Since we don't have a non-native or pass-thru version of VectorPTFOperator, we do not\n  // have enableConditionsMet / enableConditionsNotMet like we have for VectorReduceSinkOperator,\n  // etc.\n  public class PTFOperatorExplainVectorization extends OperatorExplainVectorization {\n    private final PTFDesc PTFDesc;\n    private final VectorPTFDesc vectorPTFDesc;\n    private final VectorPTFInfo vectorPTFInfo;\n    private VectorizationCondition[] nativeConditions;\n    public PTFOperatorExplainVectorization(PTFDesc PTFDesc, VectorPTFDesc vectorPTFDesc) {\n      // VectorPTFOperator is native vectorized.\n      super(vectorPTFDesc, true);\n      this.PTFDesc = PTFDesc;\n      this.vectorPTFDesc = vectorPTFDesc;\n      vectorPTFInfo = vectorPTFDesc.getVectorPTFInfo();\n    }\n    @Explain(vectorization = Vectorization.EXPRESSION, displayName = \"functionNames\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getFunctionNames() {\n      return Arrays.toString(vectorPTFDesc.getEvaluatorFunctionNames());\n    }\n    @Explain(vectorization = Vectorization.EXPRESSION, displayName = \"functionInputExpressions\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getFunctionInputExpressions() {\n      return Arrays.toString(vectorPTFInfo.getEvaluatorInputExpressions());\n    }\n    @Explain(vectorization = Vectorization.EXPRESSION, displayName = \"partitionExpressions\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getPartitionExpressions() {\n      VectorExpression[] partitionExpressions = vectorPTFInfo.getPartitionExpressions();\n      if (partitionExpressions == null) {\n        return null;\n      }\n      return Arrays.toString(partitionExpressions);\n    }\n    @Explain(vectorization = Vectorization.EXPRESSION, displayName = \"orderExpressions\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getOrderExpressions() {\n      VectorExpression[] orderExpressions = vectorPTFInfo.getOrderExpressions();\n      if (orderExpressions == null) {\n        return null;\n      }\n      return Arrays.toString(orderExpressions);\n    }\n    @Explain(vectorization = Vectorization.EXPRESSION, displayName = \"evaluatorClasses\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getEvaluatorClasses() {\n      VectorPTFEvaluatorBase[] evaluators = VectorPTFDesc.getEvaluators(vectorPTFDesc, vectorPTFInfo);\n      ArrayList<String> result = new ArrayList<String>(evaluators.length);\n      for (VectorPTFEvaluatorBase evaluator : evaluators) {\n        result.add(evaluator.getClass().getSimpleName());\n      }\n      return result.toString();\n    }\n    @Explain(vectorization = Vectorization.DETAIL, displayName = \"outputColumns\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getOutputColumns() {\n      return Arrays.toString(vectorPTFInfo.getOutputColumnMap());\n    }\n    @Explain(vectorization = Vectorization.DETAIL, displayName = \"outputTypes\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getOutputTypes() {\n      return Arrays.toString(vectorPTFDesc.getOutputTypeInfos());\n    }\n    @Explain(vectorization = Vectorization.DETAIL, displayName = \"keyInputColumns\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getKeyInputColumns() {\n      return Arrays.toString(vectorPTFInfo.getKeyInputColumnMap());\n    }\n    @Explain(vectorization = Vectorization.DETAIL, displayName = \"nonKeyInputColumns\", explainLevels = { Level.DEFAULT, Level.EXTENDED })\n    public String getNonKeyInputColumns() {\n      return Arrays.toString(vectorPTFInfo.getNonKeyInputColumnMap());\n    }<fim_middle>// function below has no smell\n"}