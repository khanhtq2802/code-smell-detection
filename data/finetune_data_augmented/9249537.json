{"text": "<fim_prefix>     * operating off a shared unbounded queue.  At any point, at most\n     * {@code nThreads} threads will be active processing tasks.\n     * If additional tasks are submitted when all threads are active,\n     * they will wait in the queue until a thread is available.\n     * If any thread terminates due to a failure during execution\n     * prior to shutdown, a new one will take its place if needed to\n     * execute subsequent tasks.  The threads in the pool will exist\n     * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n     *\n     * @param nThreads the number of threads in the pool\n     * @return the newly created thread pool\n     * @throws IllegalArgumentException if {@code nThreads <= 0}\n     */\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n    /**\n     * Creates a thread pool that maintains enough threads to support\n     * the given parallelism level, and may use multiple queues to\n     * reduce contention. The parallelism level corresponds to the\n     * maximum number of threads actively engaged in, or available to\n     * engage in, task processing. The actual number of threads may\n     * grow and shrink dynamically. A work-stealing pool makes no\n     * guarantees about the order in which submitted tasks are\n     * executed.\n     *\n     * @param parallelism the targeted parallelism level\n     * @return the newly created thread pool\n     * @throws IllegalArgumentException if {@code parallelism <= 0}\n     * @since 1.8\n     */\n    public static ExecutorService newWorkStealingPool(int parallelism) {\n        return new ForkJoinPool\n            (parallelism,\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n    /**\n     * Creates a work-stealing thread pool using the number of\n     * {@linkplain Runtime#availableProcessors available processors}\n     * as its target parallelism level.\n     *\n     * @return the newly created thread pool\n     * @see #newWorkStealingPool(int)\n     * @since 1.8\n     */\n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n    /**\n     * Creates a thread pool that reuses a fixed number of threads\n     * operating off a shared unbounded queue, using the provided\n     * ThreadFactory to create new threads when needed.  At any point,\n     * at most {@code nThreads} threads will be active processing\n     * tasks.  If additional tasks are submitted when all threads are\n     * active, they will wait in the queue until a thread is\n     * available.  If any thread terminates due to a failure during\n     * execution prior to shutdown, a new one will take its place if\n     * needed to execute subsequent tasks.  The threads in the pool will\n     * exist until it is explicitly {@link ExecutorService#shutdown\n     * shutdown}.\n     *\n     * @param nThreads the number of threads in the pool\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created thread pool\n     * @throws NullPointerException if threadFactory is null\n     * @throws IllegalArgumentException if {@code nThreads <= 0}\n     */\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    /**\n     * Creates an Executor that uses a single worker thread operating\n     * off an unbounded queue. (Note however that if this single\n     * thread terminates due to a failure during execution prior to\n     * shutdown, a new one will take its place if needed to execute\n     * subsequent tasks.)  Tasks are guaranteed to execute\n     * sequentially, and no more than one task will be active at any\n     * given time. Unlike the otherwise equivalent\n     * {@code newFixedThreadPool(1)} the returned executor is\n     * guaranteed not to be reconfigurable to use additional threads.\n     *\n     * @return the newly created single-threaded Executor\n     */\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n    /**\n     * Creates an Executor that uses a single worker thread operating\n     * off an unbounded queue, and uses the provided ThreadFactory to\n     * create a new thread when needed. Unlike the otherwise\n     * equivalent {@code newFixedThreadPool(1, threadFactory)} the\n     * returned executor is guaranteed not to be reconfigurable to use\n     * additional threads.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created single-threaded Executor\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    /**\n     * Creates a thread pool that creates new threads as needed, but\n     * will reuse previously constructed threads when they are\n     * available.  These pools will typically improve the performance\n     * of programs that execute many short-lived asynchronous tasks.\n     * Calls to {@code execute} will reuse previously constructed\n     * threads if available. If no existing thread is available, a new\n     * thread will be created and added to the pool. Threads that have\n     * not been used for sixty seconds are terminated and removed from\n     * the cache. Thus, a pool that remains idle for long enough will\n     * not consume any resources. Note that pools with similar\n     * properties but different details (for example, timeout parameters)\n     * may be created using {@link ThreadPoolExecutor} constructors.\n     *\n     * @return the newly created thread pool\n     */\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n    /**\n     * Creates a thread pool that creates new threads as needed, but\n     * will reuse previously constructed threads when they are\n     * available, and uses the provided\n     * ThreadFactory to create new threads when needed.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created thread pool\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n    /**\n     * Creates a single-threaded executor that can schedule commands\n     * to run after a given delay, or to execute periodically.\n     * (Note however that if this single\n     * thread terminates due to a failure during execution prior to\n     * shutdown, a new one will take its place if needed to execute\n     * subsequent tasks.)  Tasks are guaranteed to execute\n     * sequentially, and no more than one task will be active at any\n     * given time. Unlike the otherwise equivalent\n     * {@code newScheduledThreadPool(1)} the returned executor is\n     * guaranteed not to be reconfigurable to use additional threads.\n     *\n     * @return the newly created scheduled executor\n     */\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1));\n    }\n    /**\n     * Creates a single-threaded executor that can schedule commands\n     * to run after a given delay, or to execute periodically.  (Note\n     * however that if this single thread terminates due to a failure\n     * during execution prior to shutdown, a new one will take its\n     * place if needed to execute subsequent tasks.)  Tasks are\n     * guaranteed to execute sequentially, and no more than one task\n     * will be active at any given time. Unlike the otherwise\n     * equivalent {@code newScheduledThreadPool(1, threadFactory)}\n     * the returned executor is guaranteed not to be reconfigurable to\n     * use additional threads.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created scheduled executor\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1, threadFactory));\n    }\n    /**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @return the newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize < 0}\n     */\n<fim_suffix>    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }<fim_middle>// function below has no smell\n"}