{"text": "<fim_prefix>     * guaranteed to be constant only for the duration of the replacer function\n     * call and only if the replacer function does not modify this matcher's\n     * state.\n     *\n     * @implNote\n     * This implementation applies the replacer function to this matcher, which\n     * is an instance of {@code MatchResult}.\n     *\n     * @param  replacer\n     *         The function to be applied to the match result of this matcher\n     *         that returns a replacement string.\n     * @return  The string constructed by replacing the first matching\n     *          subsequence with the result of applying the replacer function to\n     *          the matched subsequence, substituting captured subsequences as\n     *          needed.\n     * @throws NullPointerException if the replacer function is null\n     * @throws ConcurrentModificationException if it is detected, on a\n     *         best-effort basis, that the replacer function modified this\n     *         matcher's state\n     * @since 9\n     */\n    public String replaceFirst(Function<MatchResult, String> replacer) {\n        Objects.requireNonNull(replacer);\n        reset();\n        if (!find())\n            return text.toString();\n        StringBuilder sb = new StringBuilder();\n        int ec = modCount;\n        String replacement = replacer.apply(this);\n        if (ec != modCount)\n            throw new ConcurrentModificationException();\n        appendReplacement(sb, replacement);\n        appendTail(sb);\n        return sb.toString();\n    }\n    /**\n     * Sets the limits of this matcher's region. The region is the part of the\n     * input sequence that will be searched to find a match. Invoking this\n     * method resets the matcher, and then sets the region to start at the\n     * index specified by the {@code start} parameter and end at the\n     * index specified by the {@code end} parameter.\n     *\n     * <p>Depending on the transparency and anchoring being used (see\n     * {@link #useTransparentBounds(boolean) useTransparentBounds} and\n     * {@link #useAnchoringBounds(boolean) useAnchoringBounds}), certain\n     * constructs such as anchors may behave differently at or around the\n     * boundaries of the region.\n     *\n     * @param  start\n     *         The index to start searching at (inclusive)\n     * @param  end\n     *         The index to end searching at (exclusive)\n     * @throws  IndexOutOfBoundsException\n     *          If start or end is less than zero, if\n     *          start is greater than the length of the input sequence, if\n     *          end is greater than the length of the input sequence, or if\n     *          start is greater than end.\n     * @return  this matcher\n     * @since 1.5\n     */\n    public Matcher region(int start, int end) {\n        if ((start < 0) || (start > getTextLength()))\n            throw new IndexOutOfBoundsException(\"start\");\n        if ((end < 0) || (end > getTextLength()))\n            throw new IndexOutOfBoundsException(\"end\");\n        if (start > end)\n            throw new IndexOutOfBoundsException(\"start > end\");\n        reset();\n        from = start;\n        to = end;\n        return this;\n    }\n    /**\n     * Reports the start index of this matcher's region. The\n     * searches this matcher conducts are limited to finding matches\n     * within {@link #regionStart() regionStart} (inclusive) and\n     * {@link #regionEnd() regionEnd} (exclusive).\n     *\n     * @return  The starting point of this matcher's region\n     * @since 1.5\n     */\n    public int regionStart() {\n        return from;\n    }\n    /**\n     * Reports the end index (exclusive) of this matcher's region.\n     * The searches this matcher conducts are limited to finding matches\n     * within {@link #regionStart() regionStart} (inclusive) and\n     * {@link #regionEnd() regionEnd} (exclusive).\n     *\n     * @return  the ending point of this matcher's region\n     * @since 1.5\n     */\n    public int regionEnd() {\n        return to;\n    }\n    /**\n     * Queries the transparency of region bounds for this matcher.\n     *\n     * <p> This method returns {@code true} if this matcher uses\n     * <i>transparent</i> bounds, {@code false} if it uses <i>opaque</i>\n     * bounds.\n     *\n     * <p> See {@link #useTransparentBounds(boolean) useTransparentBounds} for a\n     * description of transparent and opaque bounds.\n     *\n     * <p> By default, a matcher uses opaque region boundaries.\n     *\n     * @return {@code true} iff this matcher is using transparent bounds,\n     *         {@code false} otherwise.\n     * @see java.util.regex.Matcher#useTransparentBounds(boolean)\n     * @since 1.5\n     */\n    public boolean hasTransparentBounds() {\n        return transparentBounds;\n    }\n    /**\n     * Sets the transparency of region bounds for this matcher.\n     *\n     * <p> Invoking this method with an argument of {@code true} will set this\n     * matcher to use <i>transparent</i> bounds. If the boolean\n     * argument is {@code false}, then <i>opaque</i> bounds will be used.\n     *\n     * <p> Using transparent bounds, the boundaries of this\n     * matcher's region are transparent to lookahead, lookbehind,\n     * and boundary matching constructs. Those constructs can see beyond the\n     * boundaries of the region to see if a match is appropriate.\n     *\n     * <p> Using opaque bounds, the boundaries of this matcher's\n     * region are opaque to lookahead, lookbehind, and boundary matching\n     * constructs that may try to see beyond them. Those constructs cannot\n     * look past the boundaries so they will fail to match anything outside\n     * of the region.\n     *\n     * <p> By default, a matcher uses opaque bounds.\n     *\n     * @param  b a boolean indicating whether to use opaque or transparent\n     *         regions\n     * @return this matcher\n     * @see java.util.regex.Matcher#hasTransparentBounds\n     * @since 1.5\n     */\n    public Matcher useTransparentBounds(boolean b) {\n        transparentBounds = b;\n        return this;\n    }\n    /**\n     * Queries the anchoring of region bounds for this matcher.\n     *\n     * <p> This method returns {@code true} if this matcher uses\n     * <i>anchoring</i> bounds, {@code false} otherwise.\n     *\n     * <p> See {@link #useAnchoringBounds(boolean) useAnchoringBounds} for a\n     * description of anchoring bounds.\n     *\n     * <p> By default, a matcher uses anchoring region boundaries.\n     *\n     * @return {@code true} iff this matcher is using anchoring bounds,\n     *         {@code false} otherwise.\n     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)\n     * @since 1.5\n     */\n    public boolean hasAnchoringBounds() {\n        return anchoringBounds;\n    }\n    /**\n     * Sets the anchoring of region bounds for this matcher.\n     *\n     * <p> Invoking this method with an argument of {@code true} will set this\n     * matcher to use <i>anchoring</i> bounds. If the boolean\n     * argument is {@code false}, then <i>non-anchoring</i> bounds will be\n     * used.\n     *\n     * <p> Using anchoring bounds, the boundaries of this\n     * matcher's region match anchors such as ^ and $.\n     *\n     * <p> Without anchoring bounds, the boundaries of this\n     * matcher's region will not match anchors such as ^ and $.\n     *\n     * <p> By default, a matcher uses anchoring region boundaries.\n     *\n     * @param  b a boolean indicating whether or not to use anchoring bounds.\n     * @return this matcher\n     * @see java.util.regex.Matcher#hasAnchoringBounds\n     * @since 1.5\n     */\n    public Matcher useAnchoringBounds(boolean b) {\n        anchoringBounds = b;\n        return this;\n    }\n    /**\n     * <p>Returns the string representation of this matcher. The\n     * string representation of a {@code Matcher} contains information\n     * that may be useful for debugging. The exact format is unspecified.\n     *\n     * @return  The string representation of this matcher\n     * @since 1.5\n     */\n<fim_suffix>    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"java.util.regex.Matcher\")\n                .append(\"[pattern=\").append(pattern())\n                .append(\" region=\")\n                .append(regionStart()).append(',').append(regionEnd())\n                .append(\" lastmatch=\");\n        if ((first >= 0) && (group() != null)) {\n            sb.append(group());\n        }\n        sb.append(']');\n        return sb.toString();\n    }<fim_middle>// function below has no smell\n"}