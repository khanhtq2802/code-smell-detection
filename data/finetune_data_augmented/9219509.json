{"text": "<fim_prefix>     *         try {\n     *             SwingUtilities.invokeAndWait(doHelloWorld);\n     *         }\n     *         catch (Exception e) {\n     *             e.printStackTrace();\n     *         }\n     *         System.out.println(\"Finished on \" + Thread.currentThread());\n     *     }\n     * };\n     * appThread.start();\n     * </pre>\n     * Note that if the <code>Runnable.run</code> method throws an\n     * uncaught exception\n     * (on the event dispatching thread) it's caught and rethrown, as\n     * an <code>InvocationTargetException</code>, on the caller's thread.\n     * <p>\n     * Additional documentation and examples for this method can be\n     * found in\n     * <A HREF=\"https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html\">Concurrency in Swing</a>.\n     * <p>\n     * As of 1.3 this method is just a cover for\n     * <code>java.awt.EventQueue.invokeAndWait()</code>.\n     *\n     * @param doRun the instance of {@code Runnable}\n     * @exception  InterruptedException if we're interrupted while waiting for\n     *             the event dispatching thread to finish executing\n     *             <code>doRun.run()</code>\n     * @exception  InvocationTargetException  if an exception is thrown\n     *             while running <code>doRun</code>\n     *\n     * @see #invokeLater\n     */\n    public static void invokeAndWait(final Runnable doRun)\n        throws InterruptedException, InvocationTargetException\n    {\n        EventQueue.invokeAndWait(doRun);\n    }\n    /**\n     * Returns true if the current thread is an AWT event dispatching thread.\n     * <p>\n     * As of 1.3 this method is just a cover for\n     * <code>java.awt.EventQueue.isDispatchThread()</code>.\n     *\n     * @return true if the current thread is an AWT event dispatching thread\n     */\n    public static boolean isEventDispatchThread()\n    {\n        return EventQueue.isDispatchThread();\n    }\n    /*\n     * --- Accessibility Support ---\n     *\n     */\n    /**\n     * Get the index of this object in its accessible parent.<p>\n     *\n     * Note: as of the Java 2 platform v1.3, it is recommended that developers call\n     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead\n     * of using this method.\n     *\n     * @param c the component\n     * @return -1 of this object does not have an accessible parent.\n     * Otherwise, the index of the child in its accessible parent.\n     */\n    public static int getAccessibleIndexInParent(Component c) {\n        return c.getAccessibleContext().getAccessibleIndexInParent();\n    }\n    /**\n     * Returns the <code>Accessible</code> child contained at the\n     * local coordinate <code>Point</code>, if one exists.\n     * Otherwise returns <code>null</code>.\n     *\n     * @param c the component\n     * @param p the local coordinate\n     * @return the <code>Accessible</code> at the specified location,\n     *    if it exists; otherwise <code>null</code>\n     */\n    public static Accessible getAccessibleAt(Component c, Point p) {\n        if (c instanceof Container) {\n            return c.getAccessibleContext().getAccessibleComponent().getAccessibleAt(p);\n        } else if (c instanceof Accessible) {\n            Accessible a = (Accessible) c;\n            if (a != null) {\n                AccessibleContext ac = a.getAccessibleContext();\n                if (ac != null) {\n                    AccessibleComponent acmp;\n                    Point location;\n                    int nchildren = ac.getAccessibleChildrenCount();\n                    for (int i=0; i < nchildren; i++) {\n                        a = ac.getAccessibleChild(i);\n                        if ((a != null)) {\n                            ac = a.getAccessibleContext();\n                            if (ac != null) {\n                                acmp = ac.getAccessibleComponent();\n                                if ((acmp != null) && (acmp.isShowing())) {\n                                    location = acmp.getLocation();\n                                    Point np = new Point(p.x-location.x,\n                                                         p.y-location.y);\n                                    if (acmp.contains(np)){\n                                        return a;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return (Accessible) c;\n        }\n        return null;\n    }\n    /**\n     * Get the state of this object. <p>\n     *\n     * Note: as of the Java 2 platform v1.3, it is recommended that developers call\n     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead\n     * of using this method.\n     *\n     * @param c the component\n     * @return an instance of AccessibleStateSet containing the current state\n     * set of the object\n     * @see AccessibleState\n     */\n    public static AccessibleStateSet getAccessibleStateSet(Component c) {\n        return c.getAccessibleContext().getAccessibleStateSet();\n    }\n    /**\n     * Returns the number of accessible children in the object.  If all\n     * of the children of this object implement Accessible, than this\n     * method should return the number of children of this object. <p>\n     *\n     * Note: as of the Java 2 platform v1.3, it is recommended that developers call\n     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead\n     * of using this method.\n     *\n     * @param c the component\n     * @return the number of accessible children in the object.\n     */\n    public static int getAccessibleChildrenCount(Component c) {\n        return c.getAccessibleContext().getAccessibleChildrenCount();\n    }\n    /**\n     * Return the nth Accessible child of the object. <p>\n     *\n     * Note: as of the Java 2 platform v1.3, it is recommended that developers call\n     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead\n     * of using this method.\n     *\n     * @param c the component\n     * @param i zero-based index of child\n     * @return the nth Accessible child of the object\n     */\n    public static Accessible getAccessibleChild(Component c, int i) {\n        return c.getAccessibleContext().getAccessibleChild(i);\n    }\n    /**\n     * Return the child <code>Component</code> of the specified\n     * <code>Component</code> that is the focus owner, if any.\n     *\n     * @param c the root of the <code>Component</code> hierarchy to\n     *        search for the focus owner\n     * @return the focus owner, or <code>null</code> if there is no focus\n     *         owner, or if the focus owner is not <code>comp</code>, or a\n     *         descendant of <code>comp</code>\n     *\n     * @see java.awt.KeyboardFocusManager#getFocusOwner\n     * @deprecated As of 1.4, replaced by\n     *   <code>KeyboardFocusManager.getFocusOwner()</code>.\n     */\n    @Deprecated\n    public static Component findFocusOwner(Component c) {\n        Component focusOwner = KeyboardFocusManager.\n            getCurrentKeyboardFocusManager().getFocusOwner();\n        // verify focusOwner is a descendant of c\n        for (Component temp = focusOwner; temp != null;\n             temp = (temp instanceof Window) ? null : temp.getParent())\n        {\n            if (temp == c) {\n                return focusOwner;\n            }\n        }\n        return null;\n    }\n    /**\n     * If c is a JRootPane descendant return its JRootPane ancestor.\n     * If c is a RootPaneContainer then return its JRootPane.\n     *\n     * @param c the component\n     * @return the JRootPane for Component c or {@code null}.\n     */\n    public static JRootPane getRootPane(Component c) {\n        if (c instanceof RootPaneContainer) {\n            return ((RootPaneContainer)c).getRootPane();\n        }\n        for( ; c != null; c = c.getParent()) {\n            if (c instanceof JRootPane) {\n                return (JRootPane)c;\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns the root component for the current component tree.\n     *\n     * @param c the component\n     * @return the first ancestor of c that's a Window or the last Applet ancestor\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static Component getRoot(Component c) {\n        Component applet = null;\n        for(Component p = c; p != null; p = p.getParent()) {\n            if (p instanceof Window) {\n                return p;\n            }\n            if (p instanceof Applet) {\n                applet = p;\n            }\n        }\n        return applet;\n    }\n<fim_suffix>    static JComponent getPaintingOrigin(JComponent c) {\n        Container p = c;\n        while ((p = p.getParent()) instanceof JComponent) {\n            JComponent jp = (JComponent) p;\n            if (jp.isPaintingOrigin()) {\n                return jp;\n            }\n        }\n        return null;\n    }<fim_middle>// function below has no smell\n"}