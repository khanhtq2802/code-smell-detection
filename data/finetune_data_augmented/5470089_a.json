{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.virtualhost;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.UUID;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.qpid.server.logging.EventLogger;\nimport org.apache.qpid.server.logging.messages.MessageStoreMessages;\nimport org.apache.qpid.server.logging.messages.TransactionLogMessages;\nimport org.apache.qpid.server.logging.subjects.MessageStoreLogSubject;\nimport org.apache.qpid.server.message.MessageReference;\nimport org.apache.qpid.server.message.ServerMessage;\nimport org.apache.qpid.server.model.Queue;\nimport org.apache.qpid.server.plugin.MessageMetaDataType;\nimport org.apache.qpid.server.queue.QueueEntry;\nimport org.apache.qpid.server.store.MessageEnqueueRecord;\nimport org.apache.qpid.server.store.MessageStore;\nimport org.apache.qpid.server.store.StorableMessageMetaData;\nimport org.apache.qpid.server.store.StoredMessage;\nimport org.apache.qpid.server.store.Transaction;\nimport org.apache.qpid.server.store.Transaction.EnqueueRecord;\nimport org.apache.qpid.server.store.handler.DistributedTransactionHandler;\nimport org.apache.qpid.server.store.handler.MessageHandler;\nimport org.apache.qpid.server.store.handler.MessageInstanceHandler;\nimport org.apache.qpid.server.transport.util.Functions;\nimport org.apache.qpid.server.txn.DtxBranch;\nimport org.apache.qpid.server.txn.DtxRegistry;\nimport org.apache.qpid.server.txn.ServerTransaction;\nimport org.apache.qpid.server.txn.Xid;\nimport org.apache.qpid.server.util.Action;\nimport org.apache.qpid.server.util.ServerScopedRuntimeException;\npublic class SynchronousMessageStoreRecoverer implements MessageStoreRecoverer\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(SynchronousMessageStoreRecoverer.class);\n<fim_suffix>    @Override\n    public ListenableFuture<Void> recover(QueueManagingVirtualHost<?> virtualHost)\n    {\n        EventLogger eventLogger = virtualHost.getEventLogger();\n        MessageStore store = virtualHost.getMessageStore();\n        MessageStore.MessageStoreReader storeReader = store.newMessageStoreReader();\n        MessageStoreLogSubject logSubject = new MessageStoreLogSubject(virtualHost.getName(), store.getClass().getSimpleName());\n        Map<Queue<?>, Integer> queueRecoveries = new TreeMap<>();\n        Map<Long, ServerMessage<?>> recoveredMessages = new HashMap<>();\n        Map<Long, StoredMessage<?>> unusedMessages = new TreeMap<>();\n        Map<UUID, Integer> unknownQueuesWithMessages = new HashMap<>();\n        Map<Queue<?>, Integer> queuesWithUnknownMessages = new HashMap<>();\n        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_START());\n        storeReader.visitMessages(new MessageVisitor(recoveredMessages, unusedMessages));\n        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_START(null, false));\n        try\n        {\n            storeReader.visitMessageInstances(new MessageInstanceVisitor(virtualHost,\n                                                                         store,\n                                                                         queueRecoveries,\n                                                                         recoveredMessages,\n                                                                         unusedMessages,\n                                                                         unknownQueuesWithMessages,\n                                                                         queuesWithUnknownMessages));\n        }\n        finally\n        {\n            if (!unknownQueuesWithMessages.isEmpty())\n            {\n                unknownQueuesWithMessages.forEach((queueId, count) -> {\n                    LOGGER.info(\"Discarded {} entry(s) associated with queue id '{}' as a queue with this \"\n                                 + \"id does not appear in the configuration.\",\n                                 count, queueId);\n                });\n            }\n            if (!queuesWithUnknownMessages.isEmpty())\n            {\n                queuesWithUnknownMessages.forEach((queue, count) -> {\n                    LOGGER.info(\"Discarded {} entry(s) associated with queue '{}' as the referenced message \"\n                                 + \"does not exist.\",\n                                 count, queue.getName());\n                });\n            }\n        }\n        for(Map.Entry<Queue<?>, Integer> entry : queueRecoveries.entrySet())\n        {\n            Queue<?> queue = entry.getKey();\n            Integer deliveredCount = entry.getValue();\n            eventLogger.message(logSubject, TransactionLogMessages.RECOVERED(deliveredCount, queue.getName()));\n            eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(queue.getName(), true));\n            queue.completeRecovery();\n        }\n        for (Queue<?> q : virtualHost.getChildren(Queue.class))\n        {\n            if (!queueRecoveries.containsKey(q))\n            {\n                q.completeRecovery();\n            }\n        }\n        storeReader.visitDistributedTransactions(new DistributedTransactionVisitor(virtualHost,\n                                                                                   eventLogger,\n                                                                                   logSubject, recoveredMessages, unusedMessages));\n        for(StoredMessage<?> m : unusedMessages.values())\n        {\n            LOGGER.debug(\"Message id '{}' is orphaned, removing\", m.getMessageNumber());\n            m.remove();\n        }\n        if (unusedMessages.size() > 0)\n        {\n            LOGGER.info(\"Discarded {} orphaned message(s).\", unusedMessages.size());\n        }\n        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(null, false));\n        eventLogger.message(logSubject,\n                             MessageStoreMessages.RECOVERED(recoveredMessages.size() - unusedMessages.size()));\n        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_COMPLETE());\n        return Futures.immediateFuture(null);\n    }\n    @Override\n    public void cancel()\n    {\n        // No-op\n    }\n    private static class MessageVisitor implements MessageHandler\n    {\n        private final Map<Long, ServerMessage<?>> _recoveredMessages;\n        private final Map<Long, StoredMessage<?>> _unusedMessages;\n        MessageVisitor(final Map<Long, ServerMessage<?>> recoveredMessages,\n                       final Map<Long, StoredMessage<?>> unusedMessages)\n        {\n            _recoveredMessages = recoveredMessages;\n            _unusedMessages = unusedMessages;\n        }\n        @Override\n        public boolean handle(StoredMessage<?> message)\n        {\n            StorableMessageMetaData metaData = message.getMetaData();\n            @SuppressWarnings(\"rawtypes\")\n            MessageMetaDataType type = metaData.getType();\n            @SuppressWarnings(\"unchecked\")\n            ServerMessage<?> serverMessage = type.createMessage(message);\n            _recoveredMessages.put(message.getMessageNumber(), serverMessage);\n            _unusedMessages.put(message.getMessageNumber(), message);\n            return true;\n        }\n    }\n    private static class MessageInstanceVisitor implements MessageInstanceHandler\n    {\n        private final QueueManagingVirtualHost<?> _virtualHost;\n        private final MessageStore _store;\n        private final Map<Queue<?>, Integer> _queueRecoveries;\n        private final Map<Long, ServerMessage<?>> _recoveredMessages;\n        private final Map<Long, StoredMessage<?>> _unusedMessages;\n        private final Map<UUID, Integer> _unknownQueuesWithMessages;\n        private Map<Queue<?>, Integer> _queuesWithUnknownMessages;\n        private MessageInstanceVisitor(final QueueManagingVirtualHost<?> virtualHost,\n                                       final MessageStore store,\n                                       final Map<Queue<?>, Integer> queueRecoveries,\n                                       final Map<Long, ServerMessage<?>> recoveredMessages,\n                                       final Map<Long, StoredMessage<?>> unusedMessages,\n                                       final Map<UUID, Integer> unknownQueuesWithMessages,\n                                       final Map<Queue<?>, Integer> queuesWithUnknownMessages)\n        {\n            _virtualHost = virtualHost;\n            _store = store;\n            _queueRecoveries = queueRecoveries;\n            _recoveredMessages = recoveredMessages;\n            _unusedMessages = unusedMessages;\n            _unknownQueuesWithMessages = unknownQueuesWithMessages;\n            _queuesWithUnknownMessages = queuesWithUnknownMessages;\n        }\n        @Override\n        public boolean handle(final MessageEnqueueRecord record)\n        {\n            final UUID queueId = record.getQueueId();\n            long messageId = record.getMessageNumber();\n            Queue<?> queue = _virtualHost.getAttainedQueue(queueId);<fim_middle>// function below is feature envy and long method\n"}