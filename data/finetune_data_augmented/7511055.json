{"text": "<fim_prefix>/*\n * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.nodes.graphbuilderconf;\n\nimport static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;\nimport static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.graalvm.compiler.api.replacements.Fold;\nimport org.graalvm.compiler.debug.GraalError;\nimport org.graalvm.compiler.graph.Node.NodeIntrinsic;\nimport org.graalvm.compiler.nodes.ValueNode;\n\nimport jdk.vm.ci.meta.MetaAccessProvider;\nimport jdk.vm.ci.meta.ResolvedJavaMethod;\nimport jdk.vm.ci.meta.ResolvedJavaType;\n\n/**\n * Abstract class for a plugin generated for a method annotated by {@link NodeIntrinsic} or\n * {@link Fold}.\n */\n<fim_suffix>public abstract class GeneratedInvocationPlugin implements InvocationPlugin {\n\n    /**\n     * Gets the class of the annotation for which this plugin was generated.\n     */\n    public abstract Class<? extends Annotation> getSource();\n\n    @Override\n    public abstract boolean execute(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode[] args);\n\n    @Override\n    public StackTraceElement getApplySourceLocation(MetaAccessProvider metaAccess) {\n        Class<?> c = getClass();\n        for (Method m : c.getDeclaredMethods()) {\n            if (m.getName().equals(\"execute\")) {\n                return metaAccess.lookupJavaMethod(m).asStackTraceElement(0);\n            }\n        }\n        throw new GraalError(\"could not find method named \\\"execute\\\" in \" + c.getName());\n    }\n\n    protected boolean checkInjectedArgument(GraphBuilderContext b, ValueNode arg, ResolvedJavaMethod foldAnnotatedMethod) {\n        if (arg.isNullConstant()) {\n            return true;\n        }\n\n        if (IS_IN_NATIVE_IMAGE || IS_BUILDING_NATIVE_IMAGE) {\n            // The reflection here is problematic for SVM.\n            return true;\n        }\n\n        MetaAccessProvider metaAccess = b.getMetaAccess();\n        ResolvedJavaMethod executeMethod = metaAccess.lookupJavaMethod(getExecuteMethod());\n        ResolvedJavaType thisClass = metaAccess.lookupJavaType(getClass());\n        ResolvedJavaMethod thisExecuteMethod = thisClass.resolveConcreteMethod(executeMethod, thisClass);\n        if (b.getMethod().equals(thisExecuteMethod)) {\n            // The \"execute\" method of this plugin is itself being compiled. In (only) this context,\n            // the injected argument of the call to the @Fold annotated method will be non-null.\n            return true;\n        }\n        throw new AssertionError(\"must pass null to injected argument of \" + foldAnnotatedMethod.format(\"%H.%n(%p)\") + \", not \" + arg);\n    }\n\n    private static Method getExecuteMethod() {\n        try {\n            return GeneratedInvocationPlugin.class.getMethod(\"execute\", GraphBuilderContext.class, ResolvedJavaMethod.class, InvocationPlugin.Receiver.class, ValueNode[].class);\n        } catch (NoSuchMethodException | SecurityException e) {\n            throw new GraalError(e);\n        }\n    }\n}<fim_middle>// class below has no smell\n"}