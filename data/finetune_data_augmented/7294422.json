{"text": "<fim_prefix>\t\tIDialogSettings settings = GrailsUiActivator.getDefault().getDialogSettings().getSection(sectionName);\n\t\tif (settings == null)\n\t\t\tsettings = GrailsUiActivator.getDefault().getDialogSettings().addNewSection(sectionName);\n\t\treturn settings;\n\t}\n\tprivate void storeBounds() {\n\t\tIDialogSettings dialogSettings = getDialogSettings();\n\t\tboolean controlRestoresSize = !dialogSettings.getBoolean(STORE_DISABLE_RESTORE_SIZE);\n\t\tboolean controlRestoresLocation = !dialogSettings.getBoolean(STORE_DISABLE_RESTORE_LOCATION);\n\t\tif (bounds == null)\n\t\t\treturn;\n\t\tif (controlRestoresSize) {\n\t\t\tdialogSettings.put(STORE_SIZE_WIDTH, bounds.width);\n\t\t\tdialogSettings.put(STORE_SIZE_HEIGHT, bounds.height);\n\t\t}\n\t\tif (controlRestoresLocation) {\n\t\t\tdialogSettings.put(STORE_LOCATION_X, bounds.x);\n\t\t\tdialogSettings.put(STORE_LOCATION_Y, bounds.y);\n\t\t}\n\t}\n\tprivate Rectangle restoreBounds() {\n\t\tIDialogSettings dialogSettings = getDialogSettings();\n\t\tboolean controlRestoresSize = !dialogSettings.getBoolean(STORE_DISABLE_RESTORE_SIZE);\n\t\tboolean controlRestoresLocation = !dialogSettings.getBoolean(STORE_DISABLE_RESTORE_LOCATION);\n\t\tRectangle bounds = new Rectangle(-1, -1, -1, -1);\n\t\tif (controlRestoresSize) {\n\t\t\ttry {\n\t\t\t\tbounds.width = dialogSettings.getInt(STORE_SIZE_WIDTH);\n\t\t\t\tbounds.height = dialogSettings.getInt(STORE_SIZE_HEIGHT);\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\tbounds.width = -1;\n\t\t\t\tbounds.height = -1;\n\t\t\t}\n\t\t}\n\t\tif (controlRestoresLocation) {\n\t\t\ttry {\n\t\t\t\tbounds.x = dialogSettings.getInt(STORE_LOCATION_X);\n\t\t\t\tbounds.y = dialogSettings.getInt(STORE_LOCATION_Y);\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\tbounds.x = -1;\n\t\t\t\tbounds.y = -1;\n\t\t\t}\n\t\t}\n\t\t// sanity check\n\t\tif (bounds.x == -1 && bounds.y == -1 && bounds.width == -1 && bounds.height == -1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!isValid(bounds)) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn bounds;\n\t\t}\t\t\n\t}\n\t/**\n\t * When restoring window coordinates persisted in preferences, this validity check is\n\t * used to determine whether coordinates look reasonable enough to be reused \n\t * (to avoid having the prompt show up on the other, possibly turned off montitor) \n\t * <p>\n\t * This implementation checks whether the bounds fall completely within the bounds\n\t * of the 'parentShell' which is typically the Eclipse workbench window.\n\t */\n\tprivate boolean isValid(Rectangle bounds) {\n\t\tRectangle validBounds = getValidBounds();\n\t\tif (validBounds!=null && validBounds.intersects(bounds)) {\n\t\t\t//Must fall completely inside the valid bounds\n\t\t\tRectangle intersection = validBounds.intersection(bounds);\n\t\t\treturn intersection.width==bounds.width && intersection.height == bounds.height;\n\t\t}\n\t\treturn false;\n\t}\n\t// ----------- all to do with filtering text\n\tprivate Text createCommandText(Composite parent) {\n\t\tpromptLabel = new Label(parent, SWT.NONE);\n\t\tpromptLabel.setText(\"grails> \");\n\t\tcommandText = new Text(parent, SWT.NONE);\n\t\tGridData data = new GridData(GridData.FILL_HORIZONTAL);\n\t\tGC gc = new GC(parent);\n\t\tgc.setFont(parent.getFont());\n\t\tFontMetrics fontMetrics = gc.getFontMetrics();\n\t\tgc.dispose();\n\t\tdata.heightHint = Dialog.convertHeightInCharsToPixels(fontMetrics, 1);\n\t\tdata.horizontalAlignment = GridData.FILL;\n\t\tdata.verticalAlignment = GridData.CENTER;\n\t\tcommandText.setLayoutData(data);\n\t\tcommandText.addKeyListener(new KeyAdapter() {\n\t\t\tpublic void keyPressed(KeyEvent e) {\n\t\t\t\tif (e.character == SWT.ESC) { // ESC\n\t\t\t\t\tdispose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.doit && (e.keyCode == 0x0D || e.keyCode == SWT.KEYPAD_CR) && isDeactivateListenerActive) { // return\n\t\t\t\t\te.doit = false;\n\t\t\t\t\tIProject project = getSelectedProject();\n\t\t\t\t\tif (!isValidProject(project)) {\n\t\t\t\t\t\topenInformationMessage(\"Invalid Project \", getStatusMessage());\n\t\t\t\t\t}\n\t\t\t\t\telse if (explainNewWizardToUser()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taddCommandToHistory(commandText.getText());\n\t\t\t\t\t\tGrailsLaunchUtils.launch(JavaCore.create(getSelectedProject()), commandText.getText());\n\t\t\t\t\t\tif (!isPinned()) dispose();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.doit && e.keyCode == SWT.ARROW_DOWN || e.keyCode == SWT.ARROW_UP) {\n\t\t\t\t\te.doit = false;\n\t\t\t\t\tcommandHistoryPopup();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\trefreshContentAssist();\n\t\treturn commandText;\n\t}\n\t/**\n\t * See STS-988: warn user when they are attempting to create plugin or app from the GrailsCommandPrompt.\n\t * => Should use a 'new' wizard instead.\n\t */\n\tprivate boolean explainNewWizardToUser() {\n\t\tString command = commandText.getText();\n\t\tif (command.contains(\"create-plugin\")) {\n\t\t\topenInformationMessage(\"Nested projects are not supported in Eclipse\", \n\t\t\t\t\t\"The Grails Command prompt tool is only intended to run commands in the context of an existing \" +\n\t\t\t\t\t\"Grails plugin or app project.\\n\\n\" +\n\t\t\t\t\t\"To execute the 'create-plugin' command, please use the 'new Grails Plugin Wizard' accessible from the 'New' menu\");\n\t\t\treturn true;\n\t\t} else if (command.contains(\"create-app\")) {\n\t\t\topenInformationMessage(\"Nested projects are not supported in Eclipse\",\n\t\t\t\t\t\"The Grails Command prompt tool is intended to run commands in the context of an existing \" +\n\t\t\t\t\t\"Grails plugin or app project.\\n\\n\" +\n\t\t\t\t\t\"To execute the 'create-app' command, please use the 'new Grails Project Wizard' accessible from the 'New' menu\");\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void openInformationMessage(String title, String message) {\n\t\tShell shell = dialogShell;\n\t\tif (shell.isDisposed())\n\t\t\tshell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n\t\tisDeactivateListenerActive = false;\n\t\ttry {\n\t\t\tMessageDialog.openInformation(shell, title, message);\n\t\t}\n\t\tfinally {\n\t\t\tisDeactivateListenerActive = true;\n\t\t}\n\t}\n\tprivate boolean isPinned() {\n\t\treturn isPinned;\n\t}\n\tprivate void setPinned(boolean pinit) {\n\t\tthis.isPinned = pinit;\n\t\trefreshStatusField();\n\t\tgetDialogSettings().put(STORE_PINNED_STATE, pinit); // Future dialogs start in same pinned state\n\t}\n\t/**\n\t * Static inner class which sets the layout for the inplace view. Without this, the inplace view will not be\n\t * populated.\n\t * \n\t * @see org.eclipse.jdt.internal.ui.text.AbstractInformationControl\n\t */\n\tprivate static class BorderFillLayout extends Layout {\n\t\t/** The border widths. */\n\t\tfinal int fBorderSize;\n\t\t/**\n\t\t * Creates a fill layout with a border.\n\t\t */\n<fim_suffix>\t\tpublic BorderFillLayout(int borderSize) {\n\t\t\tif (borderSize < 0)\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\tfBorderSize = borderSize;\n\t\t}<fim_middle>// function below has no smell\n"}