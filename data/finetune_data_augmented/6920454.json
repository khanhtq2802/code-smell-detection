{"text": "<fim_prefix>    AccountDb.OtpType type = AccountDb.OtpType.TOTP;\n    Integer counter = new Integer(0); // only interesting for HOTP\n    if (OTP_SCHEME.equals(scheme)) {\n      if (authority != null && authority.equals(TOTP)) {\n        type = AccountDb.OtpType.TOTP;\n      } else if (authority != null && authority.equals(HOTP)) {\n        type = AccountDb.OtpType.HOTP;\n        String counterParameter = uri.getQueryParameter(COUNTER_PARAM);\n        if (counterParameter != null) {\n          counter = Integer.valueOf(counterParameter);\n        }\n      }\n      if (path != null && path.length() > 1) {\n        user = path.substring(1); // path is \"/user\", so remove leading /\n      }\n      secret = uri.getQueryParameter(SECRET_PARAM);\n      // TODO: remove TOTP scheme\n    } else if (TOTP.equals(scheme)) {\n      if (authority != null) {\n        user = authority;\n      }\n      secret = uri.getFragment();\n    } else {  // https://www.google.com... URI format\n      String userParam = uri.getQueryParameter(USER_PARAM);\n      if (userParam != null) {\n        user = userParam;\n      }\n      secret = uri.getFragment();\n    }\n    if (secret == null) {\n      // Secret key not found in URI\n      return;\n    }\n    // TODO: April 2010 - remove version parameter handling.\n    String version = uri.getQueryParameter(VERSION_PARAM);\n    if (version == null) { // version is null for legacy URIs\n      try {\n        secret = Base32String.encode(Base32Legacy.decode(secret));\n      } catch (DecodingException e) {\n        // Error decoding legacy key from URI\n        e.printStackTrace();\n      }\n    }\n    if (!secret.equals(getSecret(user)) ||\n        counter != AccountDb.getCounter(user) ||\n        type != AccountDb.getType(user)) {\n      saveSecret(user, secret, null, type);\n      mStatusText.setText(sResources.getString(SECRET_SAVED));\n    }\n  }\n  static String getSecret(String user) {\n    return AccountDb.getSecret(user);\n  }\n  static void saveSecret(String user, String secret, \n      String originalUser, AccountDb.OtpType type) {\n    if (originalUser == null) {\n      originalUser = user;\n    }\n    if (secret != null) {\n      AccountDb.update(user, secret, originalUser, type);\n      Alert.startVibrate(VIBRATE_DURATION);\n    }\n  }\n  private LabelField mVersionText;\n  private LabelField mStatusText;\n  private RichTextField mEnterPinTextView;\n  private PinListField mUserList;\n  private PinListFieldCallback mUserAdapter;\n  private PinInfo[] mUsers = {};\n  private boolean mUpdateAvailable;\n  private int mTimer = -1;\n  static final String DEFAULT_USER = \"Default account\";\n  private static final String OTP_SCHEME = \"otpauth\";\n  private static final String TOTP = \"totp\"; // time-based\n  private static final String HOTP = \"hotp\"; // counter-based\n  private static final String USER_PARAM = \"user\";\n  private static final String SECRET_PARAM = \"secret\";\n  private static final String VERSION_PARAM = \"v\";\n  private static final String COUNTER_PARAM = \"counter\";\n  public AuthenticatorScreen() {\n    setTitle(sResources.getString(APP_NAME));\n    // LabelField cannot scroll content that is bigger than the screen,\n    // so use RichTextField instead.\n    mEnterPinTextView = new RichTextField(sResources.getString(ENTER_PIN));\n    mUserList = new PinListField();\n    mUserAdapter = new PinListFieldCallback(mUsers);\n    setAdapter();\n    ApplicationDescriptor applicationDescriptor = ApplicationDescriptor\n        .currentApplicationDescriptor();\n    String version = applicationDescriptor.getVersion();\n    mVersionText = new LabelField(version, FIELD_RIGHT | FIELD_BOTTOM);\n    mStatusText = new LabelField(\"\", FIELD_HCENTER | FIELD_BOTTOM);\n    add(mEnterPinTextView);\n    add(mUserList);\n    add(new LabelField(\" \")); // One-line spacer\n    add(mStatusText);\n    add(mVersionText);\n    FieldUtils.setVisible(mEnterPinTextView, false);\n    UpdateCallback callback = this;\n    new UpdateTask(callback).start();\n  }\n  private void setAdapter() {\n    int lastIndex = mUserList.getSelectedIndex();\n    mUserList.setCallback(mUserAdapter);\n    mUserList.setSize(mUsers.length);\n    mUserList.setRowHeight(mUserAdapter.getRowHeight());\n    mUserList.setSelectedIndex(lastIndex);\n  }\n  /**\n   * {@inheritDoc}\n   */\n  protected void onDisplay() {\n    super.onDisplay();\n    onResume();\n  }\n  /**\n   * {@inheritDoc}\n   */\n  protected void onExposed() {\n    super.onExposed();\n    onResume();\n  }\n  /**\n   * {@inheritDoc}\n   */\n  protected void onObscured() {\n    onPause();\n    super.onObscured();\n  }\n  private void onResume() {\n    refreshUserList();\n    if (AUTO_REFRESH) {\n      startTimer();\n    }\n  }\n  private void onPause() {\n    if (isTimerSet()) {\n      stopTimer();\n    }\n  }\n  private boolean isTimerSet() {\n    return mTimer != -1;\n  }\n  private void startTimer() {\n    if (isTimerSet()) {\n      stopTimer();\n    }\n    Application application = getApplication();\n    Runnable runnable = this;\n    boolean repeat = true;\n    mTimer = application.invokeLater(runnable, REFRESH_INTERVAL, repeat);\n  }\n  private void stopTimer() {\n    if (isTimerSet()) {\n      Application application = getApplication();\n      application.cancelInvokeLater(mTimer);\n      mTimer = -1;\n    }\n  }\n  /**\n   * {@inheritDoc}\n   */\n  public void run() {\n    refreshUserList();\n  }\n  void refreshUserList() {\n    String[] cursor = AccountDb.getNames();\n    if (cursor.length > 0) {\n      if (mUsers.length != cursor.length) {\n        mUsers = new PinInfo[cursor.length];\n      }\n      for (int i = 0; i < cursor.length; i++) {\n        String user = cursor[i];\n        computeAndDisplayPin(user, i, false);\n      }\n      mUserAdapter = new PinListFieldCallback(mUsers);\n      setAdapter(); // force refresh of display\n      if (!FieldUtils.isVisible(mUserList)) {\n        mEnterPinTextView.setText(sResources.getString(ENTER_PIN));\n        FieldUtils.setVisible(mEnterPinTextView, true);\n        FieldUtils.setVisible(mUserList, true);\n      }\n    } else {\n      // If the user started up this app but there is no secret key yet,\n      // then tell the user to visit a web page to get the secret key.\n      mUsers = new PinInfo[0]; // clear any existing user PIN state\n      tellUserToGetSecretKey();\n    }\n  }\n  /**\n   * Tells the user to visit a web page to get a secret key.\n   */\n  private void tellUserToGetSecretKey() {\n    // TODO: fill this in with code to send our phone number to the server\n    String notInitialized = sResources.getString(NOT_INITIALIZED);\n    mEnterPinTextView.setText(notInitialized);\n    FieldUtils.setVisible(mEnterPinTextView, true);\n    FieldUtils.setVisible(mUserList, false);\n  }\n  /**\n   * Computes the PIN and saves it in mUsers. This currently runs in the UI\n   * thread so it should not take more than a second or so. If necessary, we can\n   * move the computation to a background thread.\n   * \n   * @param user the user email to display with the PIN\n   * @param position the index for the screen of this user and PIN\n   * @param computeHotp true if we should increment counter and display new hotp\n   * \n   * @return the generated PIN\n   */\n<fim_suffix>  String computeAndDisplayPin(String user, int position, boolean computeHotp) {\n    OtpType type = AccountDb.getType(user);\n    String secret = getSecret(user);\n    PinInfo currentPin;\n    if (mUsers[position] != null) {\n      currentPin = mUsers[position]; // existing PinInfo, so we'll update it\n    } else {\n      currentPin = new PinInfo();\n      currentPin.mPin = sResources.getString(EMPTY_PIN);\n    }\n    currentPin.mUser = user;\n    if (type == OtpType.TOTP) {\n      currentPin.mPin = computePin(secret, null);\n    } else if (type == OtpType.HOTP) {\n      currentPin.mIsHotp = true;\n      if (computeHotp) {\n        AccountDb.incrementCounter(user);\n        Integer counter = AccountDb.getCounter(user);\n        currentPin.mPin = computePin(secret, new Long(counter.longValue()));\n      }\n    }\n    mUsers[position] = currentPin;\n    return currentPin.mPin;\n  }<fim_middle>// function below has no smell\n"}