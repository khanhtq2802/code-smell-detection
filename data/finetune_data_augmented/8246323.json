{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cocoon.components.source.impl;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport org.apache.avalon.framework.activity.Initializable;\nimport org.apache.avalon.framework.service.ServiceException;\nimport org.apache.avalon.framework.service.ServiceManager;\nimport org.apache.avalon.framework.service.Serviceable;\nimport org.apache.excalibur.source.Source;\nimport org.apache.excalibur.source.SourceException;\nimport org.apache.excalibur.source.SourceNotFoundException;\nimport org.apache.excalibur.source.SourceValidity;\nimport org.apache.excalibur.source.impl.validity.TimeStampValidity;\nimport org.apache.excalibur.xml.sax.XMLizable;\nimport org.apache.excalibur.xmlizer.XMLizer;\nimport org.apache.cocoon.CascadingIOException;\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.caching.Cache;\nimport org.apache.cocoon.caching.IdentifierCacheKey;\nimport org.apache.cocoon.components.sax.XMLByteStreamCompiler;\nimport org.apache.cocoon.components.sax.XMLByteStreamInterpreter;\nimport org.apache.cocoon.util.AbstractLogEnabled;\nimport org.apache.cocoon.xml.ContentHandlerWrapper;\nimport org.apache.cocoon.xml.XMLConsumer;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\n/**\n * This class implements a proxy like source that uses another source\n * to get the content. This implementation can cache the content for\n * a given period of time.\n *\n * <h2>Syntax for Protocol</h2>\n * <pre>\n *   cached:http://www.apache.org/[?cocoon:cache-expires=60&cocoon:cache-name=main][&cocoon:cache-fail=true]\n * </pre>\n *\n * <p>The above examples show how the real source <code>http://www.apache.org</code>\n * is wrapped and the cached contents is used for <code>60</code> seconds.\n * The second querystring parameter instructs that the cache key be extended with the string\n * <code>main</code>. This allows the use of multiple cache entries for the same source.</p>\n *\n * <p>The value of the expires parameter holds some additional semantics.\n * Specifying <code>-1</code> will yield the cached response to be considered valid\n * always. Value <code>0</code> can be used to achieve the exact opposite. That is to say,\n * the cached contents will be thrown out and updated immediately and unconditionally.<p>\n * \n * <p>The <code>cache-fail</code> argument lets subsequent syncronous requests, that have to be \n * refreshed, fail, in the case that the wrapped source can't be reached. The default value \n * for <code>cache-fail</code> is <code>true</code>.\n *\n * @version $Id$\n */\npublic class CachingSource extends AbstractLogEnabled\n                           implements Serviceable, Initializable, XMLizable,\n                                      Source {\n    // TODO: Decouple from eventcache block.\n    // ---------------------------------------------------- Constants\n    public static final String CACHE_EXPIRES_PARAM = \"cache-expires\";\n    public static final String CACHE_NAME_PARAM = \"cache-name\";\n    public static final String CACHE_FAIL_PARAM = \"cache-fail\";\n    private static final SourceMeta DUMMY = new SourceMeta();\n    // ---------------------------------------------------- Instance variables\n    /** The used protocol */\n    final protected String protocol;\n    /** The full URI string */\n    final protected String uri;\n    /** The full URI string of the underlying source */\n    final protected String sourceUri;\n    /** The source object for the real content */\n    protected Source source;\n    /** The ServiceManager */\n    protected ServiceManager manager;\n    /** The current cache */\n    protected Cache cache;\n    /** The cached response (if any) */\n    private CachedSourceResponse response;\n    /** The cached response (if any) */\n    private CachedSourceResponse previousResponse;\n    /** Did we just update meta info? */\n    private boolean freshMeta;\n    /** The key used in the store */\n    final protected IdentifierCacheKey cacheKey;\n    /** Number of seconds before cached object becomes invalid */\n    final protected int expires;\n    /** Fail because of a syncronous refresh excpetion */\n    final protected boolean fail;\n    /** cache key extension */\n    final protected String cacheName;\n    /** asynchronic refresh strategy ? */\n    final protected boolean async;\n    private CachingSourceValidityStrategy validityStrategy;\n    /**\n     * Construct a new object.\n     * @param validityStrategy\n     */\n    public CachingSource(final String protocol,\n                         final String uri,\n                         final String sourceUri,\n                         final Source source,\n                         final int expires,\n                         final String cacheName,\n                         final boolean async,\n                         final CachingSourceValidityStrategy validityStrategy, \n                         final boolean fail) {\n        this.protocol = protocol;\n        this.uri = uri;\n        this.sourceUri = sourceUri;\n        this.source = source;\n        this.expires = expires;\n        this.cacheName = cacheName;\n        this.async = async;\n        this.validityStrategy = validityStrategy;\n        this.fail = fail;\n        String key = \"source:\" + getSourceURI();\n        if (cacheName != null) {\n            key += \":\" + cacheName;\n        }\n        this.cacheKey = new IdentifierCacheKey(key, false);\n    }\n    // ---------------------------------------------------- Lifecycle\n    /**\n     * Set the ServiceManager.\n     */\n    public void service(final ServiceManager manager) throws ServiceException {\n        this.manager = manager;\n    }\n    /**\n     * Initialize the Source.\n     */\n    public void initialize() throws Exception {\n        boolean checkValidity = true;\n        if (this.async && this.expires > 0 || this.expires == -1) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger().debug(\"Using cached response if available.\");\n            }\n            checkValidity = false;\n        }\n        this.response = (CachedSourceResponse) this.cache.get(this.cacheKey);\n        // save response if subsequent request should never fail\n        if(!fail) {\n            this.previousResponse = this.response;\n        }\n        if (this.response == null) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger().debug(\"No cached response found.\");\n            }\n            checkValidity = false;\n        } else if (this.expires == 0) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger().debug(\"Not using cached response.\");\n            }\n            this.response = null;\n            checkValidity = false;\n        }\n        if (checkValidity && !checkValidity()) {\n            // remove invalid response\n            clearResponse();\n        }\n    }\n    /**\n     * Cleanup.\n     */\n    public void dispose() {\n        this.response = null;\n        this.previousResponse = null;\n        this.source = null;\n        this.manager = null;\n        this.cache = null;\n    }\n    // ---------------------------------------------------- CachedSourceResponse object management\n    private CachedSourceResponse getResponse() {\n        CachedSourceResponse response = this.response;\n        if (response == null) {\n            response = new CachedSourceResponse(getCacheValidities());\n        }\n        return response;\n    }\n<fim_suffix>    private void setResponse(CachedSourceResponse response) throws IOException {\n        this.response = response;\n        if (this.expires != 0) {\n            try {\n                this.cache.store(this.cacheKey, this.response);\n            } catch (ProcessingException e) {\n                throw new CascadingIOException(\"Failure storing response.\", e);\n            }\n        }\n    }\n    private void clearResponse() {\n        this.response = null;\n        if(!fail) {\n            this.cache.remove(this.cacheKey);\n        }\n    }\n    /**\n     * Initialize the cached response with meta info.\n     *\n     * @throws IOException  if an the binary response could not be initialized\n     */\n    protected SourceMeta getResponseMeta() throws IOException {\n        CachedSourceResponse response = getResponse();\n        if (response.getExtra() == null) {\n            response.setExtra(readMeta(this.source));\n            this.freshMeta = true;<fim_middle>// function below has no smell\n"}