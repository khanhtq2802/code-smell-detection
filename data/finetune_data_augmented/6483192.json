{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2014, 2015 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\npackage com.ibm.j9ddr.tools.ddrinteractive.commands;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.ibm.j9ddr.command.CommandParser;\nimport com.ibm.j9ddr.tools.ddrinteractive.Command;\nimport com.ibm.j9ddr.tools.ddrinteractive.Context;\nimport com.ibm.j9ddr.tools.ddrinteractive.DDRInteractiveCommandException;\n\n<fim_suffix>public class ForeachCommand extends Command \n{\n\tpublic static String[] foreachArgs = null;\n\t\n\tpublic ForeachCommand()\n\t{\n\t\taddCommand(\"foreach\", \"\", \"build up a list of elements to operate on \");\n\t\taddCommand(\"do\", \"<command>\", \"repeat a command for each element in the list\");\n\t}\n\n\tpublic void run(String command, final String[] args, final Context context, final PrintStream out) throws DDRInteractiveCommandException \n\t{\n\t\tif (command.equals(\"!do\")) {\n\t\t\tboolean echo = false;\n\t\t\tboolean quiet = false;\n\t\t\tString token = null;\n\t\t\tint commandIndex = 0;\n\t\t\t\n\t\t\t\n\t\t\twhile (commandIndex < args.length) {\n\t\t\t\tif (args[commandIndex].equals(\"help\")) {\n\t\t\t\t\tout.println(\"The !do command is used to repeat a command on the elements gathered by the !foreach command.\");\n\t\t\t\t\tout.println(\"Syntax:\t!do [echo] [quiet] [token=<token>] <cmd> [args]\");\n\t\t\t\t\tout.println();\n\t\t\t\t\tout.println(\"\\techo\\t\\tOutput each command before it is run.\");\n\t\t\t\t\tout.println(\"\\tquiet\\t\\tSuppress delimiters between command outputs.\");\n\t\t\t\t\tout.println(\"\\ttoken=<chars>\\tSpecify a substitution token. Occurrencs of this string in the args will be replaced by the current element.\");\n\t\t\t\t\treturn;\n\t\t\t\t} else if (args[commandIndex].equals(\"echo\")) {\n\t\t\t\t\techo = true;\n\t\t\t\t\tcommandIndex += 1;\n\t\t\t\t} else if (args[commandIndex].equals(\"quiet\")) {\n\t\t\t\t\tquiet = true;\n\t\t\t\t\tcommandIndex += 1;\n\t\t\t\t} else if (args[commandIndex].startsWith(\"token=\")) {\n\t\t\t\t\ttoken = args[commandIndex].substring(\"token=\".length());\n\t\t\t\t\tcommandIndex += 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (commandIndex >= args.length) {\n\t\t\t\tout.println(\"The do command requires another command to repeat.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ((null == foreachArgs) || (0 == foreachArgs.length)) {\n\t\t\t\tout.println(\"Element list is empty. Use the foreach command to populate it.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < foreachArgs.length; i++) {\n\t\t\t\tif (!quiet && (i > 0)) {\n\t\t\t\t\tout.println(\"========================================\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tString[] newArgs;\n\t\t\t\t\tif (null == token) {\n\t\t\t\t\t\tnewArgs = substituteArgs(args, commandIndex, i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewArgs = substituteArgs(args, commandIndex, i, token);\n\t\t\t\t\t}\n\t\t\t\t\tif (echo) {\n\t\t\t\t\t\tSystem.out.println(\"> \" + args[commandIndex] + \" \" + Arrays.toString(newArgs));\n\t\t\t\t\t}\n\t\t\t\t\tCommandParser commandParser = new CommandParser(args[commandIndex], newArgs);\n\t\t\t\t\tcontext.execute(commandParser, out);\n\t\t\t\t} catch (ParseException e) {\n\t\t\t\t\te.printStackTrace(out);\n\t\t\t\t} catch (Throwable th) {\n\t\t\t\t\tout.println(\"Exception while executing \" + args[commandIndex] + \" \" + foreachArgs[i]);\n\t\t\t\t\tth.printStackTrace(out);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else if(command.equals(\"!foreach\")) {\n\t\t\tif (args.length > 0) {\n\t\t\t\tout.println(\"The !foreach command takes no arguments, but will read lines from the console until it encounters a blank line.\");\n\t\t\t\tout.println(\"These lines can then be used as arguments to commands specified using !do.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tArrayList<String> lines = new ArrayList<String>();\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile (true) {\n\t\t\t\tString line;\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (0 == line.length()) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlines.add(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// split by ,\n\t\t\tString[] newArgs = new String[lines.size()];\n\t\t\tlines.toArray(newArgs);\n\t\t\tforeachArgs = newArgs;\n\t\t}\n\t}\n\n\tprivate String[] substituteArgs(String[] args, int commandIndex, int foreachIndex) \n\t{\n\t\t/* Concatenate:\n\t\t * \t\t<command> <command_args> <foreach_args>\n\t\t */\n\t\tString[] newArgs = new String[args.length - commandIndex];\n\t\tSystem.arraycopy(args, commandIndex + 1, newArgs, 0, args.length - commandIndex - 1);\n\t\tnewArgs[newArgs.length - 1] = foreachArgs[foreachIndex];\n\t\treturn newArgs;\n\t}\n\t\n\tprivate String[] substituteArgs(String[] args, int commandIndex, int foreachIndex, String token) \n\t{\n\t\t/* Concatenate:\n\t\t * \t\t<command> <command_args>\n\t\t * Replacing any occurence of token with <foreach_args>\n\t\t */\n\t\tString[] newArgs = new String[args.length - commandIndex - 1];\n\t\tSystem.arraycopy(args, commandIndex + 1, newArgs, 0, args.length - commandIndex - 1);\n\t\tfor (int i = 0; i < newArgs.length; i++) {\n\t\t\tnewArgs[i] = newArgs[i].replace(token, foreachArgs[foreachIndex]);\n\t\t}\n\t\treturn newArgs;\n\t}\n}<fim_middle>// class below is blob\n"}