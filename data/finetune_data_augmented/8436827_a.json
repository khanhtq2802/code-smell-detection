{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.quickfixj;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.apache.camel.Component;\nimport org.apache.camel.Consumer;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.MultipleConsumersSupport;\nimport org.apache.camel.Processor;\nimport org.apache.camel.Producer;\nimport org.apache.camel.ResolveEndpointFailedException;\nimport org.apache.camel.component.quickfixj.converter.QuickfixjConverters;\nimport org.apache.camel.spi.Metadata;\nimport org.apache.camel.spi.UriEndpoint;\nimport org.apache.camel.spi.UriParam;\nimport org.apache.camel.spi.UriPath;\nimport org.apache.camel.support.DefaultEndpoint;\nimport quickfix.Message;\nimport quickfix.SessionID;\n\n/**\n * The quickfix component allows to send Financial Interchange (FIX) messages to the QuickFix engine.\n */\n<fim_suffix>@UriEndpoint(firstVersion = \"2.1.0\", scheme = \"quickfix\", title = \"QuickFix\", syntax = \"quickfix:configurationName\", label = \"messaging\")\npublic class QuickfixjEndpoint extends DefaultEndpoint implements QuickfixjEventListener, MultipleConsumersSupport {\n    public static final String EVENT_CATEGORY_KEY = \"EventCategory\";\n    public static final String SESSION_ID_KEY = \"SessionID\";\n    public static final String MESSAGE_TYPE_KEY = \"MessageType\";\n    public static final String DATA_DICTIONARY_KEY = \"DataDictionary\";\n\n    private final QuickfixjEngine engine;\n    private final List<QuickfixjConsumer> consumers = new CopyOnWriteArrayList<>();\n\n    @UriPath @Metadata(required = true)\n    private String configurationName;\n    @UriParam\n    private SessionID sessionID;\n    @UriParam\n    private boolean lazyCreateEngine;\n\n    public QuickfixjEndpoint(QuickfixjEngine engine, String uri, Component component) {\n        super(uri, component);\n        this.engine = engine;\n    }\n\n    public SessionID getSessionID() {\n        return sessionID;\n    }\n\n    /**\n     * The optional sessionID identifies a specific FIX session. The format of the sessionID is:\n     * (BeginString):(SenderCompID)[/(SenderSubID)[/(SenderLocationID)]]->(TargetCompID)[/(TargetSubID)[/(TargetLocationID)]]\n     */\n    public void setSessionID(SessionID sessionID) {\n        this.sessionID = sessionID;\n    }\n\n    public String getConfigurationName() {\n        return configurationName;\n    }\n\n    /**\n     * The configFile is the name of the QuickFIX/J configuration to use for the FIX engine (located as a resource found in your classpath).\n     */\n    public void setConfigurationName(String configurationName) {\n        this.configurationName = configurationName;\n    }\n\n    public boolean isLazyCreateEngine() {\n        return lazyCreateEngine;\n    }\n\n    /**\n     * This option allows to create QuickFIX/J engine on demand.\n     * Value true means the engine is started when first message is send or there's consumer configured in route definition.\n     * When false value is used, the engine is started at the endpoint creation.\n     * When this parameter is missing, the value of component's property lazyCreateEngines is being used.\n     */\n    public void setLazyCreateEngine(boolean lazyCreateEngine) {\n        this.lazyCreateEngine = lazyCreateEngine;\n    }\n\n    @Override\n    public Consumer createConsumer(Processor processor) throws Exception {\n        log.info(\"Creating QuickFIX/J consumer: {}, ExchangePattern={}\", sessionID != null ? sessionID : \"No Session\", getExchangePattern());\n        QuickfixjConsumer consumer = new QuickfixjConsumer(this, processor);\n        configureConsumer(consumer);\n        consumers.add(consumer);\n        return consumer;\n    }\n\n    @Override\n    public Producer createProducer() throws Exception {\n        log.info(\"Creating QuickFIX/J producer: {}\", sessionID != null ? sessionID : \"No Session\");\n        if (isWildcarded()) {\n            throw new ResolveEndpointFailedException(\"Cannot create consumer on wildcarded session identifier: \" + sessionID);\n        }\n        return new QuickfixjProducer(this);\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    public void onEvent(QuickfixjEventCategory eventCategory, SessionID sessionID, Message message) throws Exception {\n        if (this.sessionID == null || isMatching(sessionID)) {\n            for (QuickfixjConsumer consumer : consumers) {\n                Exchange exchange = QuickfixjConverters.toExchange(this, sessionID, message, eventCategory, getExchangePattern());\n                consumer.onExchange(exchange);\n                if (exchange.getException() != null) {\n                    throw exchange.getException();\n                }\n            }\n        }\n    }\n\n    private boolean isMatching(SessionID sessionID) {\n        if (this.sessionID.equals(sessionID)) {\n            return true;\n        }\n        return isMatching(this.sessionID.getBeginString(), sessionID.getBeginString())\n            && isMatching(this.sessionID.getSenderCompID(), sessionID.getSenderCompID())\n            && isMatching(this.sessionID.getSenderSubID(), sessionID.getSenderSubID())\n            && isMatching(this.sessionID.getSenderLocationID(), sessionID.getSenderLocationID())\n            && isMatching(this.sessionID.getTargetCompID(), sessionID.getTargetCompID())\n            && isMatching(this.sessionID.getTargetSubID(), sessionID.getTargetSubID()) \n            && isMatching(this.sessionID.getTargetLocationID(), sessionID.getTargetLocationID());\n    }\n\n    private boolean isMatching(String s1, String s2) {\n        return s1.equals(\"\") || s1.equals(\"*\") || s1.equals(s2);\n    }\n\n    private boolean isWildcarded() {\n        if (sessionID == null) {\n            return false;\n        }\n        return sessionID.getBeginString().equals(\"*\")\n            || sessionID.getSenderCompID().equals(\"*\")\n            || sessionID.getSenderSubID().equals(\"*\")\n            || sessionID.getSenderLocationID().equals(\"*\")\n            || sessionID.getTargetCompID().equals(\"*\")\n            || sessionID.getTargetSubID().equals(\"*\")\n            || sessionID.getTargetLocationID().equals(\"*\");\n    }\n\n    @Override\n    public boolean isMultipleConsumersSupported() {\n        return true;\n    }\n\n    /**\n     * Initializing and starts the engine if it wasn't initialized so far.\n     */\n    public void ensureInitialized() throws Exception {\n        if (!engine.isInitialized()) {\n            synchronized (engine) {\n                if (!engine.isInitialized()) {\n                    engine.initializeEngine();\n                    engine.start();\n                }\n            }\n        }\n    }\n\n    public QuickfixjEngine getEngine() {\n        return engine;\n    }\n    \n    @Override\n    protected void doStop() throws Exception {\n        // clear list of consumers\n        consumers.clear();\n    }\n}<fim_middle>// class below is blob and data class\n"}