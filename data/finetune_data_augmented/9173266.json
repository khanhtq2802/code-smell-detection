{"text": "<fim_prefix>\t\treturn size;\n\t}\n\t/**\n\t * Computes the size of the legend. Note the computation relies on the title\n\t * size, so the title block must be layouted first before this.\n\t * \n\t * @param lg\n\t * @param sea\n\t * \n\t * @throws ChartException\n\t */\n\tpublic final Size compute( IDisplayServer xs, Chart cm,\n\t\t\tSeriesDefinition[] seda, RunTimeContext rtc ) throws ChartException\n\t{\n\t\t// THREE CASES:\n\t\t// 1. ALL SERIES IN ONE ARRAYLIST\n\t\t// 2. ONE SERIES PER ARRAYLIST\n\t\t// 3. ALL OTHERS\n\t\tLegendData lgData = new LegendData( xs, cm, seda, rtc );\n\t\t// Get maximum block width/height available\n\t\tinitAvailableSize( lgData );\n\t\t// Calculate if minSlice applicable.\n\t\tboolean bMinSliceDefined = false;\n\t\tif ( cm instanceof ChartWithoutAxes )\n\t\t{\n\t\t\tbMinSliceDefined = ( (ChartWithoutAxes) cm ).isSetMinSlice( );\n\t\t\tlgData.sMinSliceLabel = ( (ChartWithoutAxes) cm ).getMinSliceLabel( );\n\t\t\tif ( lgData.sMinSliceLabel == null\n\t\t\t\t\t|| lgData.sMinSliceLabel.length( ) == 0 )\n\t\t\t{\n\t\t\t\tlgData.sMinSliceLabel = IConstants.UNDEFINED_STRING;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlgData.sMinSliceLabel = rtc.externalizedMessage( lgData.sMinSliceLabel );\n\t\t\t}\n\t\t}\n\t\t// calculate if need an extra legend item when minSlice defined.\n\t\tif ( bMinSliceDefined\n\t\t\t\t&& lgData.bPaletteByCategory\n\t\t\t\t&& cm instanceof ChartWithoutAxes )\n\t\t{\n\t\t\tcalculateExtraLegend( cm, rtc, lgData );\n\t\t}\n\t\t// consider legend title size.\n\t\tSize titleSize = getTitleSize( lgData );\n\t\tdouble[] size = null;\n\t\tBoolean bDataEmpty = null;\n\t\tif ( rtc != null )\n\t\t{\n\t\t\tbDataEmpty = rtc.getState( RunTimeContext.StateKey.DATA_EMPTY_KEY );\n\t\t}\n\t\tif ( bDataEmpty == null )\n\t\t{\n\t\t\tbDataEmpty = false;\n\t\t}\n\t\tif ( !bDataEmpty )\n\t\t{\n\t\t\t// COMPUTATIONS HERE MUST BE IN SYNC WITH THE ACTUAL RENDERER\n\t\t\tContentProvider cProvider = ContentProvider.newInstance( lgData );\n\t\t\tContentPlacer cPlacer = ContentPlacer.newInstance( lgData );\n\t\t\tLegendItemHints lih;\n\t\t\twhile ( ( lih = cProvider.nextContent( ) ) != null )\n\t\t\t{\n\t\t\t\tif ( !cPlacer.placeContent( lih ) )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcPlacer.finishPlacing( );\n\t\t\tsize = cPlacer.getSize( );\n\t\t}\n\t\tif ( size == null )\n\t\t{\n\t\t\t// return SizeImpl.create( 0, 0 );\n\t\t\tsize = new double[]{\n\t\t\t\t\t0, 0\n\t\t\t};\n\t\t}\n\t\tdouble dWidth = size[0], dHeight = size[1];\n\t\tif ( titleSize != null )\n\t\t{\n\t\t\tint iTitlePos = lgData.lg.getTitlePosition( ).getValue( );\n\t\t\tif ( iTitlePos == Position.ABOVE || iTitlePos == Position.BELOW )\n\t\t\t{\n\t\t\t\tdWidth = Math.max( dWidth, titleSize.getWidth( ) );\n\t\t\t\tdHeight = dHeight + titleSize.getHeight( );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdWidth = dWidth + titleSize.getWidth( );\n\t\t\t\tdHeight = Math.max( dHeight, titleSize.getHeight( ) );\n\t\t\t}\n\t\t}\n\t\tif ( rtc != null )\n\t\t{\n\t\t\tList<LegendItemHints> legendItems = lgData.legendItems;\n\t\t\tLegendItemHints[] liha = legendItems.toArray( new LegendItemHints[legendItems.size( )] );\n\t\t\t// update context hints here.\n\t\t\tLegendLayoutHints lilh = new LegendLayoutHints( SizeImpl.create( dWidth,\n\t\t\t\t\tdHeight ),\n\t\t\t\t\ttitleSize,\n\t\t\t\t\tlgData.laTitle,\n\t\t\t\t\tlgData.bMinSliceApplied,\n\t\t\t\t\tlgData.sMinSliceLabel,\n\t\t\t\t\tliha );\n\t\t\trtc.setLegendLayoutHints( lilh );\n\t\t}\n\t\tsz = SizeImpl.create( dWidth, dHeight );\n\t\treturn sz;\n\t}\n\t// calculate if need an extra legend item when minSlice defined.\n\tprivate void calculateExtraLegend( Chart cm, RunTimeContext rtc,\n\t\t\tLegendData legendData ) throws ChartException\n\t{\n\t\tMap<Series, LegendItemRenderingHints> renders = rtc.getSeriesRenderers( );\n\t\tif ( renders != null\n\t\t\t\t&& !( (ChartWithoutAxes) cm ).getSeriesDefinitions( ).isEmpty( ) )\n\t\t{\n\t\t\tList<SeriesDefinition> sedList = ChartUtil.getAllOrthogonalSeriesDefinitions( cm );\n\t\t\tboolean started = false;\n\t\t\tfor ( SeriesDefinition sed : sedList )\n\t\t\t{\n\t\t\t\tList<Series> sdRuntimeSA = sed.getRunTimeSeries( );\n\t\t\t\tfor ( Series seRuntime : sdRuntimeSA )\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tDataSetIterator dsiOrtho = new DataSetIterator( seRuntime.getDataSet( ) );\n\t\t\t\t\t\tLegendItemRenderingHints lirh = renders.get( seRuntime );\n\t\t\t\t\t\tif ( lirh == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBaseRenderer br = lirh.getRenderer( );\n\t\t\t\t\t\tCollection<Integer> fsa = br.getFilteredMinSliceEntry( dsiOrtho );\n\t\t\t\t\t\tif ( fsa.size( ) > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlegendData.bMinSliceApplied = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !started )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstarted = true;\n\t\t\t\t\t\t\tlegendData.filteredMinSliceEntry = fsa;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlegendData.filteredMinSliceEntry.retainAll( fsa );\n\t\t\t\t\t\t\tif ( legendData.filteredMinSliceEntry.size( ) == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( Exception ex )\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ChartException( ChartEnginePlugin.ID,\n\t\t\t\t\t\t\t\tChartException.RENDERING,\n\t\t\t\t\t\t\t\tex );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Returns a non empty value, if it is null or empty string, replace with\n\t * specified value.\n\t * \n\t * @param value\n\t *            specified value.\n\t * @param defaultValue\n\t *            default return value.\n\t * @return a non empty value.\n\t */\n\tprivate static Object getNonEmptyValue( Object value, Object defaultValue )\n\t{\n\t\tif ( value == null || value.toString( ).length( ) == 0 )\n\t\t{\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn value;\n\t}\n\tprivate static abstract class ContentProvider\n\t{\n\t\tprivate ChartUtil.CacheDecimalFormat dfCache;\n\t\tprotected final LegendData lgData;\n\t\tprotected final boolean bNeedInvert;\n\t\tprotected FormatSpecifier fs = null;\n\t\tprotected ContentProvider( LegendData lgData )\n\t\t{\n\t\t\tthis.lgData = lgData;\n\t\t\tthis.bNeedInvert = needInvert( lgData.bPaletteByCategory,\n\t\t\t\t\tlgData.cm,\n\t\t\t\t\tlgData.seda );\n\t\t\tthis.dfCache = new ChartUtil.CacheDecimalFormat( lgData.rtc.getULocale( ) );\n\t\t}\n<fim_suffix>\t\tpublic static ContentProvider newInstance( LegendData lgData )\n\t\t\t\tthrows ChartException\n\t\t{\n\t\t\tLegendItemType itemType = lgData.lg.getItemType( );\n\t\t\tif ( itemType.getValue( ) == LegendItemType.CATEGORIES )\n\t\t\t{\n\t\t\t\treturn new CategoryContentProvider( lgData );\n\t\t\t}\n\t\t\telse if ( itemType.getValue( ) == LegendItemType.SERIES )\n\t\t\t{\n\t\t\t\treturn new ValueContentProvider( lgData );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new ChartException( ChartEnginePlugin.ID,\n\t\t\t\t\t\tChartException.GENERATION,\n\t\t\t\t\t\t\"exception.illegal.rendering.legend.itemtype\", //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\titemType\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMessages.getResourceBundle( lgData.rtc.getULocale( ) ) );\n\t\t\t}\n\t\t}<fim_middle>// function below has no smell\n"}