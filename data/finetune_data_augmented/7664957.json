{"text": "<fim_prefix>/*\n * Copyright 2005-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.ws.server.endpoint.adapter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.oxm.Marshaller;\nimport org.springframework.oxm.Unmarshaller;\nimport org.springframework.util.Assert;\nimport org.springframework.ws.WebServiceMessage;\nimport org.springframework.ws.context.MessageContext;\nimport org.springframework.ws.server.EndpointMapping;\nimport org.springframework.ws.server.endpoint.MethodEndpoint;\nimport org.springframework.ws.support.MarshallingUtils;\n\n/**\n * Adapter that supports endpoint methods that use marshalling. Supports methods with the following signature:\n * <pre>\n * void handleMyMessage(MyUnmarshalledType request);\n * </pre>\n * or\n * <pre>\n * MyMarshalledType handleMyMessage(MyUnmarshalledType request);\n * </pre>\n * I.e. methods that take a single parameter that {@link Unmarshaller#supports(Class) is supported} by the {@link\n * Unmarshaller}, and return either {@code void} or a type {@link Marshaller#supports(Class) supported} by the\n * {@link Marshaller}. The method can have any name, as long as it is mapped by an {@link EndpointMapping}.\n *\n * <p>This endpoint needs a {@code Marshaller} and {@code Unmarshaller}, both of which can be set using\n * properties.\n *\n * @author Arjen Poutsma\n * @see #setMarshaller(org.springframework.oxm.Marshaller)\n * @see #setUnmarshaller(org.springframework.oxm.Unmarshaller)\n * @since 1.0.0\n * @deprecated as of Spring Web Services 2.0, in favor of {@link DefaultMethodEndpointAdapter} and {@link\n *\t\t\t   org.springframework.ws.server.endpoint.adapter.method.MarshallingPayloadMethodProcessor\n *\t\t\t   MarshallingPayloadMethodProcessor}.\n */\n<fim_suffix>@Deprecated\npublic class MarshallingMethodEndpointAdapter extends AbstractMethodEndpointAdapter implements InitializingBean {\n\n\tprivate Marshaller marshaller;\n\n\tprivate Unmarshaller unmarshaller;\n\n\t/**\n\t * Creates a new {@code MarshallingMethodEndpointAdapter}. The {@link Marshaller} and {@link Unmarshaller} must\n\t * be injected using properties.\n\t *\n\t * @see #setMarshaller(org.springframework.oxm.Marshaller)\n\t * @see #setUnmarshaller(org.springframework.oxm.Unmarshaller)\n\t */\n\tpublic MarshallingMethodEndpointAdapter() {\n\t}\n\n\t/**\n\t * Creates a new {@code MarshallingMethodEndpointAdapter} with the given marshaller. If the given {@link\n\t * Marshaller} also implements the {@link Unmarshaller} interface, it is used for both marshalling and\n\t * unmarshalling. Otherwise, an exception is thrown.\n\t *\n\t * <p>Note that all {@link Marshaller} implementations in Spring also implement the {@link Unmarshaller} interface,\n\t * so that you can safely use this constructor.\n\t *\n\t * @param marshaller object used as marshaller and unmarshaller\n\t * @throws IllegalArgumentException when {@code marshaller} does not implement the {@link Unmarshaller}\n\t *\t\t\t\t\t\t\t\t\tinterface\n\t */\n\tpublic MarshallingMethodEndpointAdapter(Marshaller marshaller) {\n\t\tAssert.notNull(marshaller, \"marshaller must not be null\");\n\t\tif (!(marshaller instanceof Unmarshaller)) {\n\t\t\tthrow new IllegalArgumentException(\"Marshaller [\" + marshaller + \"] does not implement the Unmarshaller \" +\n\t\t\t\t\t\"interface. Please set an Unmarshaller explicitly by using the \" +\n\t\t\t\t\t\"MarshallingMethodEndpointAdapter(Marshaller, Unmarshaller) constructor.\");\n\t\t}\n\t\telse {\n\t\t\tthis.setMarshaller(marshaller);\n\t\t\tthis.setUnmarshaller((Unmarshaller) marshaller);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new {@code MarshallingMethodEndpointAdapter} with the given marshaller and unmarshaller.\n\t *\n\t * @param marshaller   the marshaller to use\n\t * @param unmarshaller the unmarshaller to use\n\t */\n\tpublic MarshallingMethodEndpointAdapter(Marshaller marshaller, Unmarshaller unmarshaller) {\n\t\tAssert.notNull(marshaller, \"marshaller must not be null\");\n\t\tAssert.notNull(unmarshaller, \"unmarshaller must not be null\");\n\t\tthis.setMarshaller(marshaller);\n\t\tthis.setUnmarshaller(unmarshaller);\n\t}\n\n\t/** Returns the marshaller used for transforming objects into XML. */\n\tpublic Marshaller getMarshaller() {\n\t\treturn marshaller;\n\t}\n\n\t/** Sets the marshaller used for transforming objects into XML. */\n\tpublic final void setMarshaller(Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}\n\n\t/** Returns the unmarshaller used for transforming XML into objects. */\n\tpublic Unmarshaller getUnmarshaller() {\n\t\treturn unmarshaller;\n\t}\n\n\t/** Sets the unmarshaller used for transforming XML into objects. */\n\tpublic final void setUnmarshaller(Unmarshaller unmarshaller) {\n\t\tthis.unmarshaller = unmarshaller;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tAssert.notNull(getMarshaller(), \"marshaller is required\");\n\t\tAssert.notNull(getUnmarshaller(), \"unmarshaller is required\");\n\t}\n\n\t@Override\n\tprotected void invokeInternal(MessageContext messageContext, MethodEndpoint methodEndpoint) throws Exception {\n\t\tWebServiceMessage request = messageContext.getRequest();\n\t\tObject requestObject = unmarshalRequest(request);\n\t\tObject responseObject = methodEndpoint.invoke(new Object[]{requestObject});\n\t\tif (responseObject != null) {\n\t\t\tWebServiceMessage response = messageContext.getResponse();\n\t\t\tmarshalResponse(responseObject, response);\n\t\t}\n\t}\n\n\tprivate Object unmarshalRequest(WebServiceMessage request) throws IOException {\n\t\tObject requestObject = MarshallingUtils.unmarshal(getUnmarshaller(), request);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Unmarshalled payload request to [\" + requestObject + \"]\");\n\t\t}\n\t\treturn requestObject;\n\t}\n\n\tprivate void marshalResponse(Object responseObject, WebServiceMessage response) throws IOException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Marshalling [\" + responseObject + \"] to response payload\");\n\t\t}\n\t\tMarshallingUtils.marshal(getMarshaller(), responseObject, response);\n\t}\n\n\t/**\n\t * Supports a method with a single, unmarshallable parameter, and that return {@code void} or a marshallable\n\t * type.\n\t *\n\t * @see Marshaller#supports(Class)\n\t * @see Unmarshaller#supports(Class)\n\t */\n\t@Override\n\tprotected boolean supportsInternal(MethodEndpoint methodEndpoint) {\n\t\tMethod method = methodEndpoint.getMethod();\n\t\treturn supportsReturnType(method) && supportsParameters(method);\n\t}\n\n\tprivate boolean supportsReturnType(Method method) {\n\t\treturn (Void.TYPE.equals(method.getReturnType()) || getMarshaller().supports(method.getReturnType()));\n\t}\n\n\tprivate boolean supportsParameters(Method method) {\n\t\tif (method.getParameterTypes().length != 1) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn getUnmarshaller().supports(method.getParameterTypes()[0]);\n\t\t}\n\t}\n}<fim_middle>// class below has no smell\n"}