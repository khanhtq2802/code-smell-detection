{"text": "<fim_prefix>/*\n * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.code;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.graalvm.compiler.code.CompilationResult.CodeAnnotation;\nimport org.graalvm.compiler.code.CompilationResult.CodeComment;\nimport org.graalvm.compiler.code.CompilationResult.JumpTable;\nimport jdk.vm.ci.code.CodeUtil;\n/**\n * A HexCodeFile is a textual format for representing a chunk of machine code along with extra\n * information that can be used to enhance a disassembly of the code.\n *\n * A pseudo grammar for a HexCodeFile is given below.\n *\n * <pre>\n *     HexCodeFile ::= Platform Delim HexCode Delim (OptionalSection Delim)*\n *\n *     OptionalSection ::= Comment | OperandComment | JumpTable | LookupTable\n *\n *     Platform ::= \"Platform\" ISA WordWidth\n *\n *     HexCode ::= \"HexCode\" StartAddress HexDigits\n *\n *     Comment ::= \"Comment\" Position String\n *\n *     OperandComment ::= \"OperandComment\" Position String\n *\n *     JumpTable ::= \"JumpTable\" Position EntrySize Low High\n *\n *     LookupTable ::= \"LookupTable\" Position NPairs KeySize OffsetSize\n *\n *     Position, EntrySize, Low, High, NPairs KeySize OffsetSize ::= int\n *\n *     Delim := \"&lt;||@\"\n * </pre>\n *\n * There must be exactly one HexCode and Platform part in a HexCodeFile. The length of HexDigits\n * must be even as each pair of digits represents a single byte.\n * <p>\n * Below is an example of a valid Code input:\n *\n * <pre>\n *\n *  Platform AMD64 64  &lt;||@\n *  HexCode 0 e8000000009090904883ec084889842410d0ffff48893c24e800000000488b3c24488bf0e8000000004883c408c3  &lt;||@\n *  Comment 24 frame-ref-map: +0 {0}\n *  at java.lang.String.toLowerCase(String.java:2496) [bci: 1]\n *              |0\n *     locals:  |stack:0:a\n *     stack:   |stack:0:a\n *    &lt;||@\n *  OperandComment 24 {java.util.Locale.getDefault()}  &lt;||@\n *  Comment 36 frame-ref-map: +0 {0}\n *  at java.lang.String.toLowerCase(String.java:2496) [bci: 4]\n *              |0\n *     locals:  |stack:0:a\n *    &lt;||@\n *  OperandComment 36 {java.lang.String.toLowerCase(Locale)}  lt;||@\n *\n * </pre>\n */\npublic class HexCodeFile {\n    public static final String NEW_LINE = CodeUtil.NEW_LINE;\n    public static final String SECTION_DELIM = \" <||@\";\n    public static final String COLUMN_END = \" <|@\";\n    public static final Pattern SECTION = Pattern.compile(\"(\\\\S+)\\\\s+(.*)\", Pattern.DOTALL);\n    public static final Pattern COMMENT = Pattern.compile(\"(\\\\d+)\\\\s+(.*)\", Pattern.DOTALL);\n    public static final Pattern OPERAND_COMMENT = COMMENT;\n    public static final Pattern JUMP_TABLE = Pattern.compile(\"(\\\\d+)\\\\s+(\\\\d+)\\\\s+(-{0,1}\\\\d+)\\\\s+(-{0,1}\\\\d+)\\\\s*\");\n    public static final Pattern LOOKUP_TABLE = Pattern.compile(\"(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s*\");\n    public static final Pattern HEX_CODE = Pattern.compile(\"(\\\\p{XDigit}+)(?:\\\\s+(\\\\p{XDigit}*))?\");\n    public static final Pattern PLATFORM = Pattern.compile(\"(\\\\S+)\\\\s+(\\\\S+)\", Pattern.DOTALL);\n    /**\n     * Delimiter placed before a HexCodeFile when embedded in a string/stream.\n     */\n    public static final String EMBEDDED_HCF_OPEN = \"<<<HexCodeFile\";\n    /**\n     * Delimiter placed after a HexCodeFile when embedded in a string/stream.\n     */\n    public static final String EMBEDDED_HCF_CLOSE = \"HexCodeFile>>>\";\n    /**\n     * Map from a machine code position to a list of comments for the position.\n     */\n    public final Map<Integer, List<String>> comments = new TreeMap<>();\n    /**\n     * Map from a machine code position to a comment for the operands of the instruction at the\n     * position.\n     */\n    public final Map<Integer, List<String>> operandComments = new TreeMap<>();\n    public final byte[] code;\n    public final ArrayList<JumpTable> jumpTables = new ArrayList<>();\n    public final String isa;\n    public final int wordWidth;\n    public final long startAddress;\n    public HexCodeFile(byte[] code, long startAddress, String isa, int wordWidth) {\n        this.code = code;\n        this.startAddress = startAddress;\n        this.isa = isa;\n        this.wordWidth = wordWidth;\n    }\n    /**\n     * Parses a string in the format produced by {@link #toString()} to produce a\n     * {@link HexCodeFile} object.\n     */\n    public static HexCodeFile parse(String input, int sourceOffset, String source, String sourceName) {\n        return new Parser(input, sourceOffset, source, sourceName).hcf;\n    }\n    /**\n     * Formats this HexCodeFile as a string that can be parsed with\n     * {@link #parse(String, int, String, String)}.\n     */\n<fim_suffix>    @Override\n    public String toString() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        writeTo(baos);\n        return baos.toString();\n    }\n    public String toEmbeddedString() {\n        return EMBEDDED_HCF_OPEN + NEW_LINE + toString() + EMBEDDED_HCF_CLOSE;\n    }\n    public void writeTo(OutputStream out) {\n        PrintStream ps = out instanceof PrintStream ? (PrintStream) out : new PrintStream(out);\n        ps.printf(\"Platform %s %d %s%n\", isa, wordWidth, SECTION_DELIM);\n        ps.printf(\"HexCode %x %s %s%n\", startAddress, HexCodeFile.hexCodeString(code), SECTION_DELIM);\n        for (JumpTable table : jumpTables) {\n            ps.printf(\"JumpTable %d %d %d %d %s%n\", table.position, table.entrySize, table.low, table.high, SECTION_DELIM);\n        }\n        for (Map.Entry<Integer, List<String>> e : comments.entrySet()) {\n            int pos = e.getKey();\n            for (String comment : e.getValue()) {\n                ps.printf(\"Comment %d %s %s%n\", pos, comment, SECTION_DELIM);\n            }\n        }\n        for (Map.Entry<Integer, List<String>> e : operandComments.entrySet()) {\n            for (String c : e.getValue()) {<fim_middle>// function below has no smell\n"}