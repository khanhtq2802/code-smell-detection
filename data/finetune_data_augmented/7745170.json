{"text": "<fim_prefix> * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.core.entity.factory;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.brooklyn.api.entity.Entity;\nimport org.apache.brooklyn.api.entity.EntitySpec;\nimport org.apache.brooklyn.api.mgmt.EntityManager;\nimport org.apache.brooklyn.api.mgmt.ManagementContext;\nimport org.apache.brooklyn.core.entity.Entities;\nimport org.apache.brooklyn.core.entity.StartableApplication;\nimport org.apache.brooklyn.entity.stock.BasicApplication;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.annotations.Beta;\n/**\n * Experimental mechanism for defining/building applications. In future releases, this\n * API will change. Its concepts will most likely be merged with a TOSCA implementation\n * and with {@link EntitySpec}.\n *\n * For building an application. Users can sub-class and override doBuild(), putting the logic for  \n * creating and wiring together entities in there.\n * \n * The builder is mutable; a given instance should be used to build only a single application.\n * Once {@link #manage()} has been called, the application will be built and no additional configuration\n * should be performed through this builder.  \n * \n * Example (simplified) code for sub-classing is:\n * <pre>\n * {@code\n *   app = new ApplicationBuilder() {\n *       //@Override\n *       public void doBuild() {\n *           MySqlNode db = addChild(EntitySpec.create(MySqlNode.class)));\n *           JBoss7Server as = addChild(EntitySpec.create(JBoss7Server.class)\n *                   .configure(HTTP_PORT, \"8080+\")\n *                   .configure(javaSysProp(\"brooklyn.example.db.url\"), attributeWhenReady(db, MySqlNode.MYSQL_URL));\n *       }\n *   }.manage();\n * }\n * </pre>\n * \n * @author aled\n * \n * @deprecated since 0.9.0; use {@link EntitySpec} and {@link EntityManager#createEntity(EntitySpec)}, having \n *             added the children to the spec etc.\n */\n@Deprecated\n@Beta\npublic abstract class ApplicationBuilder {\n    @SuppressWarnings(\"unused\")\n    private static final Logger LOG = LoggerFactory.getLogger(ApplicationBuilder.class);\n    @SuppressWarnings(\"unchecked\")\n    @Beta\n    /** @deprecated since 0.7.0 the management context should normally be passed in;\n     * for TestApplication also see TestApplication.Factory.newManagedInstanceForTests() */ \n    @Deprecated\n    public static <T extends StartableApplication> T newManagedApp(Class<T> type) {\n        if (type.isInterface()) {\n            return (T) newManagedApp(EntitySpec.create(type));\n        } else {\n            return (T) newManagedApp(EntitySpec.create(StartableApplication.class, type));\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends StartableApplication> T newManagedApp(EntitySpec<T> spec) {\n        return (T) new ApplicationBuilder(spec) {\n            @Override protected void doBuild() {\n            }\n        }.manage();\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Beta\n    public static <T extends StartableApplication> T newManagedApp(Class<T> type, ManagementContext managementContext) {\n        if (type.isInterface()) {\n            return (T) newManagedApp(EntitySpec.create(type), managementContext);\n        } else {\n            return (T) newManagedApp(EntitySpec.create(StartableApplication.class, type), managementContext);\n        }\n    }\n    /** @deprecated class can be removed; users of this convenience method can now simply do mgmt.getEntityManager().createEntity(spec) */ \n    @SuppressWarnings(\"unchecked\")\n    @Beta\n    public static <T extends StartableApplication> T newManagedApp(EntitySpec<T> spec, ManagementContext managementContext) {\n        return (T) new ApplicationBuilder(spec) {\n            @Override protected void doBuild() {\n            }\n        }.manage(managementContext);\n    }\n    protected volatile boolean managed = false;\n    protected final AtomicBoolean inManage = new AtomicBoolean(false);\n    private EntitySpec<? extends StartableApplication> appSpec;\n    private ManagementContext managementContext;\n    private StartableApplication app;\n    public ApplicationBuilder() {\n        this.appSpec = EntitySpec.create(BasicApplication.class);\n    }\n    public ApplicationBuilder(EntitySpec<? extends StartableApplication> appSpec) {\n        this.appSpec = EntitySpec.create(appSpec);\n    }\n    public final ApplicationBuilder appDisplayName(String val) {\n        checkPreManage();\n        appSpec.displayName(val);\n        return this;\n    }\n    protected final <T extends Entity> T createEntity(EntitySpec<T> spec) {\n        checkDuringManage();\n        EntityManager entityManager = managementContext.getEntityManager();\n        return entityManager.createEntity(spec);\n    }\n    /**\n     * Adds the given entity as a child of the application being built.\n     * To be called during {@link #doBuild()}.\n     */\n    protected final <T extends Entity> T addChild(T entity) {\n        checkDuringManage();\n        return app.addChild(entity);\n    }\n    /**\n     * Returns the type of the application being built.\n     */\n    public final Class<? extends StartableApplication> getType() {\n        return appSpec.getType();\n    }\n    /**\n     * Configures the application instance.\n     */\n    public final ApplicationBuilder configure(Map<?,?> config) {\n        checkPreManage();\n        appSpec.configure(config);\n        return this;\n    }\n    /**\n     * Adds the given entity as a child of the application being built.\n     */\n    protected final <T extends Entity> T addChild(EntitySpec<T> spec) {\n        checkDuringManage();\n        return addChild(createEntity(spec));\n    }\n    protected final <T extends Entity> T addChild(Map<?,?> config, Class<T> type) {\n        checkDuringManage();\n        EntitySpec<T> spec = EntitySpec.create(type).configure(config);\n        return addChild(createEntity(spec));\n    }\n    protected final ManagementContext getManagementContext() {\n        return checkNotNull(managementContext, \"must only be called after manage()\");\n    }\n    protected final StartableApplication getApp() {\n        return checkNotNull(app, \"must only be called after manage()\");\n    }\n    /**\n     * For overriding, to create and wire together entities.\n     */\n    protected abstract void doBuild();\n    /**\n     * Creates a new {@link ManagementContext}, and then builds and manages the application.\n     * \n     * @see #manage(ManagementContext)\n     */\n    public final StartableApplication manage() {\n        return manage(Entities.newManagementContext());\n    }\n    /**\n     * Builds and manages the application, calling the user's {@link #doBuild()} method.\n     * \n     * @throws IllegalStateException If already managed, or if called during {@link #doBuild()}, or if \n     *                               multiple concurrent calls\n     */\n    public final StartableApplication manage(ManagementContext managementContext) {\n        if (!inManage.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"Concurrent and re-entrant calls to manage() forbidden on \"+this);\n        }\n        try {\n            checkNotManaged();\n            this.managementContext = managementContext;\n            this.app = managementContext.getEntityManager().createEntity(appSpec);\n            doBuild();\n            // not needed with 0.9.0 (TODO - remove when confirmed)\n//            Entities.startManagement(app, managementContext);\n            managed = true;\n            return app;\n        } finally {\n            inManage.set(false);\n        }\n    }\n    protected void checkPreManage() {\n        if (inManage.get()) {\n            throw new IllegalStateException(\"Builder being managed; cannot perform operation during call to manage(), or in doBuild()\");\n        }\n        if (managed) {\n            throw new IllegalStateException(\"Builder already managed; cannot perform operation after call to manage()\");\n        }\n    }\n    protected void checkNotManaged() {\n        if (managed) {\n            throw new IllegalStateException(\"Builder already managed; cannot perform operation after call to manage()\");\n        }\n    }\n<fim_suffix>    protected void checkDuringManage() {\n        if (!inManage.get() || app == null) {\n            throw new IllegalStateException(\"Operation only permitted during manage, e.g. called from doBuild() of \"+this);\n        }\n    }<fim_middle>// function below has no smell\n"}