{"text": "<fim_prefix>            if (F.eq(coordinator().id(), nodeId)) {\n                // Refresh info about coordinator node.\n                crdNode = null;\n                if (curOpFinishMsg != null)\n                    sendFinish(curOpFinishMsg);\n            }\n        }\n    }\n    /**\n     * Handle finish operation message from a node.\n     *\n     * @param nodeId Node ID.\n     * @param msg Message.\n     */\n    private void onFinishMessage(UUID nodeId, UserManagementOperationFinishedMessage msg) {\n        if (log.isDebugEnabled())\n            log.debug(msg.toString());\n        synchronized (mux) {\n            UserOperationFinishFuture fut = opFinishFuts.get(msg.operationId());\n            if (fut == null) {\n                fut = new UserOperationFinishFuture(msg.operationId());\n                opFinishFuts.put(msg.operationId(), fut);\n            }\n            if (msg.success())\n                fut.onSuccessOnNode(nodeId);\n            else\n                fut.onOperationFailOnNode(nodeId, msg.errorMessage());\n        }\n    }\n    /**\n     * Called when all required finish messages are received,\n     * send ACK message to complete operation futures on all nodes.\n     *\n     * @param opId Operation ID.\n     * @param err Error.\n     */\n    private void onFinishOperation(IgniteUuid opId, IgniteCheckedException err) {\n        try {\n            UserAcceptedMessage msg = new UserAcceptedMessage(opId, err);\n            ctx.discovery().sendCustomEvent(msg);\n        }\n        catch (IgniteCheckedException e) {\n            if (!e.hasCause(IgniteFutureCancelledException.class))\n                U.error(log, \"Unexpected exception on send UserAcceptedMessage.\", e);\n        }\n    }\n    /**\n     * @param nodeId Node ID.\n     * @param msg Message.\n     */\n    private void onAuthenticateRequestMessage(UUID nodeId, UserAuthenticateRequestMessage msg) {\n        UserAuthenticateResponseMessage respMsg;\n        try {\n            User u = authenticateOnServer(msg.name(), msg.password());\n            respMsg = new UserAuthenticateResponseMessage(msg.id(), null);\n        }\n        catch (IgniteCheckedException e) {\n            respMsg = new UserAuthenticateResponseMessage(msg.id(), e.toString());\n            e.printStackTrace();\n        }\n        try {\n            ctx.io().sendToGridTopic(nodeId, GridTopic.TOPIC_AUTH, respMsg, GridIoPolicy.SYSTEM_POOL);\n        }\n        catch (IgniteCheckedException e) {\n            U.error(log, \"Unexpected exception on send UserAuthenticateResponseMessage.\", e);\n        }\n    }\n    /**\n     * @param msg Message.\n     */\n    private void onAuthenticateResponseMessage(UserAuthenticateResponseMessage msg) {\n        GridFutureAdapter<Void> fut = authFuts.get(msg.id());\n        fut.onDone(null, !msg.success() ? new IgniteAccessControlException(msg.errorMessage()) : null);\n        authFuts.remove(msg.id());\n    }\n    /**\n     * Local node joined to topology. Discovery cache is available but no discovery custom message are received.\n     * Initial user set and initial user operation (received on join) are processed here.\n     */\n    public void onLocalJoin() {\n        if (coordinator() == null)\n            return;\n        if (F.eq(coordinator().id(), ctx.localNodeId())) {\n            if (!isEnabled)\n                return;\n            assert initUsrs == null;\n            // Creates default user on coordinator if it is the first start of PDS cluster\n            // or start of in-memory cluster.\n            if (users.isEmpty())\n                addDefaultUser();\n        }\n        else {\n            Boolean rmtEnabled = coordinator().attribute(IgniteNodeAttributes.ATTR_AUTHENTICATION_ENABLED);\n            // The cluster doesn't support authentication (ver < 2.5)\n            if (rmtEnabled == null)\n                rmtEnabled = false;\n            if (isEnabled != rmtEnabled) {\n                if (rmtEnabled)\n                    U.warn(log, \"User authentication is enabled on cluster. Enables on local node\");\n                else {\n                    validateErr = \"User authentication is disabled on cluster\";\n                    return;\n                }\n            }\n            isEnabled = rmtEnabled;\n            if (!isEnabled) {\n                try {\n                    stop(false);\n                }\n                catch (IgniteCheckedException e) {\n                    U.warn(log, \"Unexpected exception on stopped authentication processor\", e);\n                }\n                return;\n            }\n            if (ctx.clientNode())\n                return;\n            assert initUsrs != null;\n            // Can be empty on initial start of PDS cluster (default user will be created and stored after activate)\n            if (!F.isEmpty(initUsrs.usrs)) {\n                if (users == null)\n                    users = new ConcurrentHashMap<>();\n                else\n                    users.clear();\n                for (User u : initUsrs.usrs)\n                    users.put(u.name(), u);\n                exec.execute(new RefreshUsersStorageWorker(initUsrs.usrs));\n            }\n            for (UserManagementOperation op : initUsrs.activeOps)\n                submitOperation(op);\n        }\n        readyForAuthFut.onDone();\n    }\n    /**\n     * Called on node activate.\n     */\n    public void onActivate() {\n        activateFut.onDone();\n    }\n    /**\n     *\n     */\n    private void waitActivate() {\n        try {\n            activateFut.get();\n        }\n        catch (IgniteCheckedException e) {\n            // No-op.\n        }\n    }\n    /**\n     * @param msg Finish message.\n     */\n    private void sendFinish(UserManagementOperationFinishedMessage msg) {\n        try {\n            ctx.io().sendToGridTopic(coordinator(), GridTopic.TOPIC_AUTH, msg, GridIoPolicy.SYSTEM_POOL);\n        }\n        catch (Exception e) {\n            U.error(log, \"Failed to send UserManagementOperationFinishedMessage [op=\" + msg.operationId() +\n                \", node=\" + coordinator() + \", err=\" + msg.errorMessage() + ']', e);\n        }\n    }\n    /**\n     * Register operation, future and add operation worker to execute queue.\n     *\n     * @param op User operation.\n     */\n    private void submitOperation(UserManagementOperation op) {\n        synchronized (mux) {\n            UserOperationFinishFuture fut = opFinishFuts.get(op.id());\n            if (fut == null) {\n                fut = new UserOperationFinishFuture(op.id());\n                opFinishFuts.put(op.id(), fut);\n            }\n            if (!fut.workerSubmitted()) {\n                fut.workerSubmitted(true);\n                activeOps.put(op.id(), op);\n                exec.execute(new UserOperationWorker(op, fut));\n            }\n        }\n    }\n    /**\n     * @param n Node.\n     * @return {@code true} if node holds user information. Otherwise returns {@code false}.\n     */\n    private static boolean isNodeHoldsUsers(ClusterNode n) {\n        return !n.isClient() && !n.isDaemon();\n    }\n    /**\n     * Initial data is collected on coordinator to send to join node.\n     */\n    private static final class InitialUsersData implements Serializable {\n        /** */\n        private static final long serialVersionUID = 0L;\n        /** Users. */\n        @GridToStringInclude\n        private final ArrayList<User> usrs;\n        /** Active user operations. */\n        @GridToStringInclude\n        private final ArrayList<UserManagementOperation> activeOps;\n        /**\n         * @param usrs Users.\n         * @param ops Active operations on cluster.\n         */\n        InitialUsersData(Collection<User> usrs, Collection<UserManagementOperation> ops) {\n            this.usrs = new ArrayList<>(usrs);\n            activeOps = new ArrayList<>(ops);\n        }\n        /** {@inheritDoc} */\n        @Override public String toString() {\n            return S.toString(InitialUsersData.class, this);\n        }\n    }\n    /**i\n     *\n     */\n    private final class UserProposedListener implements CustomEventListener<UserProposedMessage> {\n        /** {@inheritDoc} */\n        @Override public void onCustomEvent(AffinityTopologyVersion topVer, ClusterNode snd,\n            final UserProposedMessage msg) {\n            if (!isEnabled || ctx.isStopping() || ctx.clientNode())\n                return;\n            if (log.isDebugEnabled())\n                log.debug(msg.toString());\n            submitOperation(msg.operation());\n        }\n    }\n    /**\n     *\n     */\n<fim_suffix>    private final class UserAcceptedListener implements CustomEventListener<UserAcceptedMessage> {\n        /** {@inheritDoc} */\n        @Override public void onCustomEvent(AffinityTopologyVersion topVer, ClusterNode snd, UserAcceptedMessage msg) {\n            if (!isEnabled || ctx.isStopping())\n                return;\n            if (log.isDebugEnabled())\n                log.debug(msg.toString());\n            synchronized (mux) {\n                UserOperationFinishFuture f = opFinishFuts.get(msg.operationId());\n                if (f != null) {\n                    if (msg.error() != null)\n                        f.onDone(null, msg.error());\n                    else\n                        f.onDone();\n                }\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}