{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pivot.collections.adapter;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.RandomAccess;\n\nimport org.apache.pivot.collections.List;\nimport org.apache.pivot.collections.ListListener;\nimport org.apache.pivot.collections.Sequence;\nimport org.apache.pivot.util.ImmutableIterator;\nimport org.apache.pivot.util.ListenerList;\nimport org.apache.pivot.util.Utils;\n\n/**\n * Implementation of the {@link List} interface that is backed by an instance of\n * {@link java.util.List}.\n * @param <T> Type of elements in the list.\n */\npublic class ListAdapter<T> implements List<T>, Serializable {\n    private static final long serialVersionUID = 1649736907064653706L;\n\n    private java.util.List<T> list = null;\n    private Comparator<T> comparator = null;\n\n    private transient ListListenerList<T> listListeners = new ListListenerList<>();\n\n    public ListAdapter(final java.util.List<T> list) {\n        Utils.checkNull(list, \"list\");\n\n        this.list = list;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public ListAdapter(final T... a) {\n        this.list = Arrays.asList(a);\n    }\n\n    public java.util.List<T> getList() {\n        return list;\n    }\n\n<fim_suffix>    @Override\n    public int add(final T item) {\n        int index = -1;\n\n        if (comparator == null) {\n            index = getLength();\n        } else {\n            // Perform a binary search to find the insertion point\n            index = Collections.binarySearch(list, item, comparator);\n            if (index < 0) {\n                index = -(index + 1);\n            }\n        }\n\n        list.add(index, item);\n        listListeners.itemInserted(this, index);\n\n        return index;\n    }\n\n    @Override\n    public void insert(final T item, final int index) {\n        if (comparator != null && Collections.binarySearch(list, item, comparator) != -(index + 1)) {\n            throw new IllegalArgumentException(\n                \"Given insertion point \" + index + \" does not match the sorted insertion location.\");\n        }\n\n        list.add(index, item);\n        listListeners.itemInserted(this, index);\n    }\n\n    @Override\n    public T update(final int index, final T item) {\n        if (comparator != null) {\n            // Ensure that the new item is greater or equal to its\n            // predecessor and less than or equal to its successor\n            T predecessor = null;\n            T successor = null;\n\n            if (list instanceof RandomAccess) {\n                if (index > 0) {\n                    predecessor = list.get(index - 1);\n                }\n\n                if (index < getLength() - 1) {\n                    successor = list.get(index + 1);\n                }\n            } else {\n                if (index == 0) {\n                    // We're at the head of the list; successor is at index 1\n                    successor = list.get(1);\n                } else {\n                    ListIterator<T> listIterator = list.listIterator(index - 1);\n\n                    // Get the predecessor\n                    predecessor = listIterator.next();\n\n                    // Advance to the item being updated\n                    listIterator.next();\n\n                    // Get the successor if one exists\n                    if (listIterator.hasNext()) {\n                        successor = listIterator.next();\n                    }\n                }\n            }\n\n            if ((predecessor != null && comparator.compare(item, predecessor) < 0)\n                || (successor != null && comparator.compare(item, successor) > 0)) {\n                throw new IllegalArgumentException(\"Updated item at index \" + index\n                    + \" is not in correct sorted order.\");\n            }\n        }\n\n        T previousItem;\n\n        if (list instanceof RandomAccess) {\n            previousItem = list.get(index);\n\n            if (previousItem != item) {\n                list.set(index, item);\n            }\n\n            listListeners.itemUpdated(this, index, previousItem);\n        } else {\n            ListIterator<T> listIterator = list.listIterator(index);\n            previousItem = listIterator.next();\n\n            if (previousItem != item) {\n                try {\n                    listIterator.set(item);\n                } catch (UnsupportedOperationException exception) {\n                    list.set(index, item);\n                }\n            }\n\n            listListeners.itemUpdated(this, index, previousItem);\n        }\n\n        return previousItem;\n    }\n\n    @Override\n    public int remove(final T item) {\n        int index = indexOf(item);\n        if (index != -1) {\n            remove(index, 1);\n        }\n\n        return index;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Sequence<T> remove(final int index, final int count) {\n        java.util.List<T> removedList = null;\n        try {\n            removedList = list.getClass().getDeclaredConstructor().newInstance();\n        } catch (IllegalAccessException | InstantiationException exception) {\n            throw new RuntimeException(exception);\n        } catch (NoSuchMethodException | InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        }\n\n        List<T> removed = new ListAdapter<>(removedList);\n\n        if (count > 0) {\n            for (int i = count - 1; i >= 0; i--) {\n                removedList.add(0, list.remove(index + i));\n            }\n\n            listListeners.itemsRemoved(this, index, removed);\n        }\n\n        return removed;\n    }\n\n    @Override\n    public void clear() {\n        if (getLength() > 0) {\n            list.clear();\n            listListeners.listCleared(this);\n        }\n    }\n\n    @Override\n    public T get(final int index) {\n        return list.get(index);\n    }\n\n    @Override\n    public int indexOf(final T item) {\n        return list.indexOf(item);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return (list.isEmpty());\n    }\n\n    @Override\n    public int getLength() {\n        return list.size();\n    }\n\n    @Override\n    public Comparator<T> getComparator() {\n        return comparator;\n    }\n\n    @Override\n    public void setComparator(final Comparator<T> comparator) {\n        Comparator<T> previousComparator = this.comparator;\n\n        if (previousComparator != comparator) {\n            if (comparator != null) {\n                Collections.sort(list, comparator);\n            }\n\n            this.comparator = comparator;\n\n            listListeners.comparatorChanged(this, previousComparator);\n        }\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new ImmutableIterator<>(list.iterator());\n    }\n\n    @Override\n    public ListenerList<ListListener<T>> getListListeners() {\n        return listListeners;\n    }\n\n    @Override\n    public String toString() {\n        return list.toString();\n    }\n}<fim_middle>// function below has no smell\n"}