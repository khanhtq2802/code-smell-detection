{"text": "<fim_prefix>/*\n * Copyright 2016 zhanhb.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springsource.loaded.support;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.WeakReference;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.lang.NullPointerException;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n *\n * @author zhanhb\n * @param <K>\n * @param <V>\n */\npublic class ConcurrentWeakIdentityHashMap<K, V> extends AbstractMap<K, V>\n        implements ConcurrentMap<K, V> {\n\n    private final ConcurrentMap<Key<K>, V> map;\n    private final ReferenceQueue<K> queue = new ReferenceQueue<K>();\n    private transient Set<Map.Entry<K, V>> es;\n\n    public ConcurrentWeakIdentityHashMap(int initialCapacity) {\n        this.map = new ConcurrentHashMap<Key<K>, V>(initialCapacity);\n    }\n\n    @SuppressWarnings(\"CollectionWithoutInitialCapacity\")\n    public ConcurrentWeakIdentityHashMap() {\n        this.map = new ConcurrentHashMap<Key<K>, V>();\n    }\n\n    @Override\n    public V get(Object key) {\n        purgeKeys();\n        return map.get(new Key<Object>(key, null));\n    }\n\n    @Override\n    public V put(K key, V value) {\n        purgeKeys();\n        return map.put(new Key<K>(key, queue), value);\n    }\n\n    @Override\n    public int size() {\n        purgeKeys();\n        return map.size();\n    }\n\n    @SuppressWarnings({\"NestedAssignment\", \"element-type-mismatch\"})\n    private void purgeKeys() {\n        Reference<? extends K> reference;\n        while ((reference = queue.poll()) != null) {\n            map.remove(reference);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"NestedAssignment\")\n    public Set<Map.Entry<K, V>> entrySet() {\n        Set<Map.Entry<K, V>> entrySet;\n        return ((entrySet = this.es) == null) ? es = new EntrySet() : entrySet;\n    }\n\n    @Override\n    public V putIfAbsent(K key, V value) {\n        purgeKeys();\n        return map.putIfAbsent(new Key<K>(key, queue), value);\n    }\n\n    @Override\n    public V remove(Object key) {\n        return map.remove(new Key<Object>(key, null));\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        purgeKeys();\n        return map.remove(new Key<Object>(key, null), value);\n    }\n\n    @Override\n    public boolean replace(K key, V oldValue, V newValue) {\n        purgeKeys();\n        return map.replace(new Key<K>(key, null), oldValue, newValue);\n    }\n\n    @Override\n    public V replace(K key, V value) {\n        purgeKeys();\n        return map.replace(new Key<K>(key, null), value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        purgeKeys();\n        return map.containsKey(new Key<Object>(key, null));\n    }\n\n    @Override\n    @SuppressWarnings(\"empty-statement\")\n    public void clear() {\n        while (queue.poll() != null);\n        map.clear();\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        purgeKeys();\n        return map.containsValue(value);\n    }\n\n    private static class Key<T> extends WeakReference<T> {\n\n        private final int hash;\n\n        Key(T t, ReferenceQueue<T> queue) {\n            super(t, queue);\n            if(t == null) {\n                throw new NullPointerException();\n            } else {\n                hash = System.identityHashCode(t);\n            }\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return this == obj || obj instanceof Key && ((Key<?>) obj).get() == get();\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n\n    }\n\n    private class Iter implements Iterator<Map.Entry<K, V>> {\n\n        private final Iterator<Map.Entry<Key<K>, V>> it;\n        private Map.Entry<K, V> nextValue;\n\n        Iter(Iterator<Map.Entry<Key<K>, V>> it) {\n            this.it = it;\n        }\n\n<fim_suffix>        @Override\n        public boolean hasNext() {\n            if (nextValue != null) {\n                return true;\n            }\n            while (it.hasNext()) {\n                Map.Entry<Key<K>, V> entry = it.next();\n                K key = entry.getKey().get();\n                if (key != null) {\n                    nextValue = new Entry(key, entry.getValue());\n                    return true;\n                } else {\n                    it.remove();\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            Map.Entry<K, V> entry = nextValue;\n            nextValue = null;\n            return entry;\n        }\n\n        @Override\n        public void remove() {\n            it.remove();\n            nextValue = null;\n        }\n\n    }\n\n    private class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new Iter(map.entrySet().iterator());\n        }\n\n        @Override\n        public int size() {\n            return ConcurrentWeakIdentityHashMap.this.size();\n        }\n\n        @Override\n        public void clear() {\n            ConcurrentWeakIdentityHashMap.this.clear();\n        }\n\n        @Override\n        @SuppressWarnings(\"element-type-mismatch\")\n        public boolean contains(Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n            Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;\n            return ConcurrentWeakIdentityHashMap.this.get(e.getKey()) == e.getValue();\n        }\n\n        @Override\n        public boolean remove(Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n            Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;\n            return ConcurrentWeakIdentityHashMap.this.remove(e.getKey(), e.getValue());\n        }\n    }\n\n    private class Entry extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 1L;\n\n        Entry(K key, V value) {\n            super(key, value);\n        }\n\n        @Override\n        public V setValue(V value) {\n            ConcurrentWeakIdentityHashMap.this.put(getKey(), value);\n            return super.setValue(value);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Map.Entry) {\n                Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n                return getKey() == e.getKey() && getValue() == e.getValue();\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            return System.identityHashCode(getKey())\n                    ^ System.identityHashCode(getValue());\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}