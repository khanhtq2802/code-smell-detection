{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *\n */\npackage org.apache.polygene.runtime.value;\n\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport org.apache.polygene.api.composite.CompositeInstance;\nimport org.apache.polygene.api.serialization.Serializer;\nimport org.apache.polygene.runtime.composite.MixinsInstance;\nimport org.apache.polygene.runtime.composite.TransientInstance;\nimport org.apache.polygene.runtime.property.PropertyInstance;\nimport org.apache.polygene.spi.module.ModuleSpi;\n\n/**\n * ValueComposite instance\n */\n<fim_suffix>public final class ValueInstance extends TransientInstance\n    implements CompositeInstance, MixinsInstance\n{\n    public ValueInstance( ValueModel compositeModel, Object[] mixins, ValueStateInstance state )\n    {\n        super( compositeModel, mixins, state );\n    }\n\n    /**\n     * Perform equals with {@code o} argument.\n     * <p>\n     * The definition of equals() for the Value is that if both the state and descriptor are equal,\n     * then the values are equal.\n     * </p>\n     *\n     * @param o The other object to compare.\n     *\n     * @return Returns a {@code boolean} indicator whether this object is equals the other.\n     */\n    @Override\n    public boolean equals( Object o )\n    {\n        if( this == o )\n        {\n            return true;\n        }\n        if( o == null || !Proxy.isProxyClass( o.getClass() ) )\n        {\n            return false;\n        }\n\n        try\n        {\n            ValueInstance that = (ValueInstance) Proxy.getInvocationHandler( o );\n            // Descriptor equality\n            if( !descriptor().equals( that.descriptor() ) )\n            {\n                return false;\n            }\n            // State equality\n            return state.equals( that.state );\n        }\n        catch( ClassCastException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    public ValueStateInstance state()\n    {\n        return (ValueStateInstance) state;\n    }\n\n    @Override\n    public ValueModel descriptor()\n    {\n        return (ValueModel) compositeModel;\n    }\n\n    /**\n     * When a ValueBuilder is about to start, ensure that all state has builder infos, i.e. they are mutable.\n     */\n    public void prepareToBuild()\n    {\n        descriptor().state().properties().forEach(\n            descriptor -> ( (PropertyInstance<Object>) state.propertyFor( descriptor.accessor() ) )\n                .prepareToBuild( descriptor ) );\n\n        descriptor().state().associations().forEach(\n            descriptor -> state().associationFor( descriptor.accessor() )\n                                 .setAssociationInfo( descriptor.builderInfo() ) );\n\n        descriptor().state().manyAssociations().forEach(\n            descriptor -> state().manyAssociationFor( descriptor.accessor() )\n                                 .setAssociationInfo( descriptor.builderInfo() ) );\n\n        descriptor().state().namedAssociations().forEach(\n            descriptor -> state().namedAssociationFor( descriptor.accessor() )\n                                 .setAssociationInfo( descriptor.builderInfo() ) );\n    }\n\n    /**\n     * When a ValueBuilder is finished and is about to instantiate a Value, call this to ensure that the state has correct\n     * settings, i.e. is immutable.\n     */\n    public void prepareBuilderState()\n    {\n        descriptor().state().properties().forEach(\n            descriptor -> ( (PropertyInstance<Object>) state.propertyFor( descriptor.accessor() ) )\n                .prepareBuilderState( descriptor ) );\n\n        descriptor().state().associations().forEach(\n            descriptor -> state().associationFor( descriptor.accessor() ).setAssociationInfo( descriptor ) );\n\n        descriptor().state().manyAssociations().forEach(\n            descriptor -> state().manyAssociationFor( descriptor.accessor() ).setAssociationInfo( descriptor ) );\n\n        descriptor().state().namedAssociations().forEach(\n            descriptor -> state().namedAssociationFor( descriptor.accessor() ).setAssociationInfo( descriptor ) );\n    }\n\n    /**\n     * Calculate hash code.\n     *\n     * @return the hashcode of this instance.\n     */\n    @Override\n    public int hashCode()\n    {\n        int hash = compositeModel.hashCode() * 23; // Descriptor\n        return hash + state.hashCode() * 5; // State\n    }\n\n    public String toJsonString()\n    {\n        Serializer serialization = ( (ModuleSpi) module().instance() ).serialization();\n        if( serialization != null )\n        {\n            return serialization.serialize( Serializer.Options.NO_TYPE_INFO, proxy() );\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        String json = toJsonString();\n        if( json != null )\n        {\n            return json;\n        }\n        return \"ValueInstance{\" +\n               \"mixins=\" + Arrays.toString( mixins ) +\n               \", state=\" + state +\n               \", compositeModel=\" + compositeModel +\n               '}';\n    }\n}<fim_middle>// class below has no smell\n"}