{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.index;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.lucene.store.ByteBuffersDataInput;\nimport org.apache.lucene.store.ByteBuffersDataOutput;\nimport org.apache.lucene.util.Accountable;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefBuilder;\nimport org.apache.lucene.util.StringHelper;\n\n/**\n * Prefix codes term instances (prefixes are shared). This is expected to be\n * faster to build than a FST and might also be more compact if there are no\n * common suffixes.\n * @lucene.internal\n */\npublic class PrefixCodedTerms implements Accountable {\n  private final List<ByteBuffer> content;\n  private final long size;\n  private long delGen;\n  private int lazyHash;\n\n  private PrefixCodedTerms(List<ByteBuffer> content, long size) {\n    this.content = Objects.requireNonNull(content);\n    this.size = size;\n  }\n\n  @Override\n  public long ramBytesUsed() {\n    return content.stream().mapToLong(buf -> buf.capacity()).sum() + 2 * Long.BYTES; \n  }\n\n  /** Records del gen for this packet. */\n  public void setDelGen(long delGen) {\n    this.delGen = delGen;\n  }\n  \n  /** Builds a PrefixCodedTerms: call add repeatedly, then finish. */\n  public static class Builder {\n    private ByteBuffersDataOutput output = new ByteBuffersDataOutput();\n    private Term lastTerm = new Term(\"\");\n    private BytesRefBuilder lastTermBytes = new BytesRefBuilder();\n    private long size;\n\n    /** Sole constructor. */\n    public Builder() {}\n\n    /** add a term */\n    public void add(Term term) {\n      add(term.field(), term.bytes());\n    }\n\n    /** add a term.  This fully consumes in the incoming {@link BytesRef}. */\n    public void add(String field, BytesRef bytes) {\n      assert lastTerm.equals(new Term(\"\")) || new Term(field, bytes).compareTo(lastTerm) > 0;\n\n      try {\n        final int prefix;\n        if (size > 0 && field.equals(lastTerm.field)) {\n          // same field as the last term\n          prefix = StringHelper.bytesDifference(lastTerm.bytes, bytes);\n          output.writeVInt(prefix << 1);\n        } else {\n          // field change\n          prefix = 0;\n          output.writeVInt(1);\n          output.writeString(field);\n        }\n\n        int suffix = bytes.length - prefix;\n        output.writeVInt(suffix);\n        output.writeBytes(bytes.bytes, bytes.offset + prefix, suffix);\n        lastTermBytes.copyBytes(bytes);\n        lastTerm.bytes = lastTermBytes.get();\n        lastTerm.field = field;\n        size += 1;\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n    /** return finalized form */\n    public PrefixCodedTerms finish() {\n      return new PrefixCodedTerms(output.toBufferList(), size);\n    }\n  }\n\n  /** An iterator over the list of terms stored in a {@link PrefixCodedTerms}. */\n  public static class TermIterator extends FieldTermIterator {\n    final ByteBuffersDataInput input;\n    final BytesRefBuilder builder = new BytesRefBuilder();\n    final BytesRef bytes = builder.get();\n    final long end;\n    final long delGen;\n    String field = \"\";\n\n    private TermIterator(long delGen, ByteBuffersDataInput input) {\n      this.input = input;\n      end = input.size();\n      this.delGen = delGen;\n    }\n\n<fim_suffix>    @Override\n    public BytesRef next() {\n      if (input.position() < end) {\n        try {\n          int code = input.readVInt();\n          boolean newField = (code & 1) != 0;\n          if (newField) {\n            field = input.readString();\n          }\n          int prefix = code >>> 1;\n          int suffix = input.readVInt();\n          readTermBytes(prefix, suffix);\n          return bytes;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      } else {\n        field = null;\n        return null;\n      }\n    }\n\n    // TODO: maybe we should freeze to FST or automaton instead?\n    private void readTermBytes(int prefix, int suffix) throws IOException {\n      builder.grow(prefix + suffix);\n      input.readBytes(builder.bytes(), prefix, suffix);\n      builder.setLength(prefix + suffix);\n    }\n\n    @Override\n    public String field() {\n      return field;\n    }\n\n    @Override\n    public long delGen() {\n      return delGen;\n    }\n  }\n\n  /** Return an iterator over the terms stored in this {@link PrefixCodedTerms}. */\n  public TermIterator iterator() {\n    return new TermIterator(delGen, new ByteBuffersDataInput(content));\n  }\n\n  /** Return the number of terms stored in this {@link PrefixCodedTerms}. */\n  public long size() {\n    return size;\n  }\n\n  @Override\n  public int hashCode() {\n    if (lazyHash == 0) {\n      int h = 1;\n      for (ByteBuffer bb : content) {\n        h = h + 31 * bb.hashCode();\n      }\n      h = 31 * h + (int) (delGen ^ (delGen >>> 32));\n      lazyHash = h;\n    }\n    return lazyHash;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n\n    if (obj == null || getClass() != obj.getClass()) { \n      return false;\n    }\n\n    PrefixCodedTerms other = (PrefixCodedTerms) obj;\n    return delGen == other.delGen &&\n           this.content.equals(other.content);\n  }\n}<fim_middle>// function below has no smell\n"}