{"text": "<fim_prefix>\n<fim_suffix>public final class LiveSignalEnforcement extends AbstractEnforcement<Signal> {\n    private static final int CACHE_TIMEOUT_SECONDS = 2 * 60;\n    private final EnforcerRetriever enforcerRetriever;\n    private final Cache<String, ActorRef> responseReceivers;\n    private LiveSignalEnforcement(final Context context, final Cache<EntityId, Entry<EntityId>> thingIdCache,\n            final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache,\n            final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache) {\n        super(context);\n        requireNonNull(thingIdCache);\n        requireNonNull(policyEnforcerCache);\n        requireNonNull(aclEnforcerCache);\n        enforcerRetriever =\n                PolicyOrAclEnforcerRetrieverFactory.create(thingIdCache, policyEnforcerCache, aclEnforcerCache);\n        final Caffeine<Object, Object> caffeine = Caffeine.newBuilder()\n                .expireAfterWrite(CACHE_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        responseReceivers = CaffeineCache.of(caffeine);\n    }\n    /**\n     * {@link EnforcementProvider} for {@link LiveSignalEnforcement}.\n     */\n    public static final class Provider implements EnforcementProvider<Signal> {\n        private final Cache<EntityId, Entry<EntityId>> thingIdCache;\n        private final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache;\n        private final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache;\n        /**\n         * Constructor.\n         *\n         * @param thingIdCache the thing-id-cache.\n         * @param policyEnforcerCache the policy-enforcer cache.\n         * @param aclEnforcerCache the acl-enforcer cache.\n         */\n        public Provider(final Cache<EntityId, Entry<EntityId>> thingIdCache,\n                final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache,\n                final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache) {\n            this.thingIdCache = requireNonNull(thingIdCache);\n            this.policyEnforcerCache = requireNonNull(policyEnforcerCache);\n            this.aclEnforcerCache = requireNonNull(aclEnforcerCache);\n        }\n        @Override\n        public Class<Signal> getCommandClass() {\n            return Signal.class;\n        }\n        @Override\n        public boolean isApplicable(final Signal signal) {\n            return LiveSignalEnforcement.isLiveSignal(signal);\n        }\n        @Override\n        public AbstractEnforcement<Signal> createEnforcement(final Context context) {\n            return new LiveSignalEnforcement(context, thingIdCache, policyEnforcerCache, aclEnforcerCache);\n        }\n    }\n    @Override\n    public CompletionStage<Void> enforce(final Signal signal, final ActorRef sender,\n            final DiagnosticLoggingAdapter log) {\n        LogUtil.enhanceLogWithCorrelationIdOrRandom(signal);\n        return enforcerRetriever.retrieve(entityId(), (enforcerKeyEntry, enforcerEntry) -> {\n            if (enforcerEntry.exists()) {\n                final Enforcer enforcer = enforcerEntry.getValue();\n                final String correlationId = signal.getDittoHeaders().getCorrelationId().get();\n                if (signal instanceof SendClaimMessage) {\n                    // claim messages require no enforcement, publish them right away:\n                    publishMessageCommand((SendClaimMessage) signal, enforcer, sender);\n                    if (signal.getDittoHeaders().isResponseRequired()) {\n                        responseReceivers.put(correlationId, sender);\n                    }\n                } else if (signal instanceof CommandResponse) {\n                    // no enforcement for responses required - the original sender will get the answer:\n                    final Optional<ActorRef> responseReceiver = responseReceivers.getBlocking(correlationId);\n                    if (responseReceiver.isPresent()) {\n                        responseReceiver.get().tell(signal, sender);\n                        responseReceivers.invalidate(correlationId);\n                    } else {\n                        log(signal).warning(\"No outstanding responses receiver for CommandResponse <{}>\",\n                                signal.getType());\n                    }\n                } else if (signal instanceof Command) {\n                    // enforce both Live Commands and MessageCommands\n                    if (signal instanceof MessageCommand) {\n                        final boolean wasPublished = enforceMessageCommand((MessageCommand) signal, enforcer, sender);\n                        if (wasPublished && signal.getDittoHeaders().isResponseRequired()) {\n                            responseReceivers.put(correlationId, sender);\n                        }\n                    } else if (signal instanceof ThingCommand) {\n                        // enforce Live Thing Commands\n                        final boolean authorized;\n                        if (enforcer instanceof AclEnforcer) {\n                            authorized = ThingCommandEnforcement.authorizeByAcl(enforcer, (ThingCommand<?>) signal)\n                                    .isPresent();\n                        } else {\n                            authorized = ThingCommandEnforcement.authorizeByPolicy(enforcer, (ThingCommand<?>) signal)\n                                    .isPresent();\n                        }\n                        if (authorized) {\n                            final Command<?> withReadSubjects =\n                                    addReadSubjectsToThingSignal((Command<?>) signal, enforcer);\n                            log(withReadSubjects).info(\"Live Command was authorized: <{}>\", withReadSubjects);\n                            publishToMediator(withReadSubjects, StreamingType.LIVE_COMMANDS.getDistributedPubSubTopic(),\n                                    sender);\n                            if (signal.getDittoHeaders().isResponseRequired()) {\n                                responseReceivers.put(correlationId, sender);\n                            }\n                        } else {\n                            log(signal).info(\"Live Command was NOT authorized: <{}>\", signal);\n                            ThingCommandEnforcement.respondWithError((ThingCommand) signal, sender, self());\n                        }\n                    } else {\n                        log(signal).error(\"Ignoring unsupported live signal: <{}>\", signal);\n                    }\n                } else if (signal instanceof ThingEvent) {\n                    // enforce Live Events\n                    final boolean authorized = enforcer.hasUnrestrictedPermissions(\n                            // only check access to root resource for now\n                            PoliciesResourceType.thingResource(\"/\"),\n                            signal.getDittoHeaders().getAuthorizationContext(),\n                            WRITE);\n                    if (authorized) {\n                        log(signal).info(\"Live Event was authorized: <{}>\", signal);\n                        final Event<?> withReadSubjects = addReadSubjectsToThingSignal((Event<?>) signal, enforcer);\n                        publishToMediator(withReadSubjects, StreamingType.LIVE_EVENTS.getDistributedPubSubTopic(),\n                                sender);\n                    } else {\n                        final EventSendNotAllowedException eventSendNotAllowedException =\n                                EventSendNotAllowedException.newBuilder(((ThingEvent) signal).getThingId())\n                                        .dittoHeaders(signal.getDittoHeaders())\n                                        .build();\n                        log(signal).info(\"Live Event was NOT authorized: <{}>\", signal);\n                        replyToSender(eventSendNotAllowedException, sender);\n                    }\n                }\n            } else {\n                // drop live command to nonexistent things and respond with error.\n                log(signal).info(\"Command of type <{}> with ID <{}> could not be dispatched as no enforcer could be\" +\n                                \" looked up! Answering with ThingNotAccessibleException.\", signal.getType(),\n                        signal.getId());\n                final ThingNotAccessibleException error = ThingNotAccessibleException.newBuilder(entityId().getId())\n                        .dittoHeaders(signal.getDittoHeaders())\n                        .build();\n                replyToSender(error, sender);\n            }\n        });\n    }\n    /**\n     * Tests whether a signal is applicable for live signal enforcement.\n     *\n     * @param signal the signal to test.\n     * @return whether the signal belongs to the live channel.\n     */\n    static boolean isLiveSignal(final Signal signal) {\n        return signal.getDittoHeaders().getChannel().filter(TopicPath.Channel.LIVE.getName()::equals).isPresent();\n    }\n    private boolean enforceMessageCommand(final MessageCommand command, final Enforcer enforcer,\n            final ActorRef sender) {\n        if (isAuthorized(command, enforcer)) {\n            publishMessageCommand(command, enforcer, sender);\n            return true;\n        } else {\n            rejectMessageCommand(command, sender);\n            return false;\n        }\n    }\n    private void publishMessageCommand(final MessageCommand command, final Enforcer enforcer, final ActorRef sender) {\n        final ResourceKey resourceKey =\n                ResourceKey.newInstance(MessageCommand.RESOURCE_TYPE, command.getResourcePath());\n        final Set<String> messageReaders = enforcer.getSubjectIdsWithPermission(resourceKey, Permission.READ)\n                .getGranted();\n        final DittoHeaders headersWithReadSubjects = command.getDittoHeaders()\n                .toBuilder()\n                .readSubjects(messageReaders)\n                .build();\n        final MessageCommand commandWithReadSubjects = command.setDittoHeaders(headersWithReadSubjects);\n        publishToMediator(commandWithReadSubjects, commandWithReadSubjects.getTypePrefix(), sender);\n        // answer the sender immediately for fire-and-forget message commands.\n        getResponseForFireAndForgetMessage(commandWithReadSubjects)\n                .ifPresent(response -> replyToSender(response, sender));\n    }<fim_middle>// class below is blob\n"}