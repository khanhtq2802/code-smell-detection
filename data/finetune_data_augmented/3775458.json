{"text": "<fim_prefix>     * If {@code t} precedes this Timestamp then {@code 1} is returned.\n     * If the Timestamps represent the same point in time, then\n     * {@code 0} is returned.\n     * Note that a {@code 0} result does not imply that the two Timestamps are\n     * {@link #equals}, as the local offset or precision of the two Timestamps\n     * may be different.\n     *\n     * <p>\n     * This method is provided in preference to individual methods for each of\n     * the six boolean comparison operators (&lt;, ==, &gt;, &gt;=, !=, &lt;=).\n     * The suggested idiom for performing these comparisons is:\n     * {@code (x.compareTo(y)}<em>&lt;op&gt;</em>{@code 0)},\n     * where <em>&lt;op&gt;</em> is one of the six comparison operators.\n     *\n     * <p>\n     * For example, the pairs below will return a {@code 0} result:\n     * <ul>\n     *   <li>{@code 2009T}</li>\n     *   <li>{@code 2009-01T}</li>\n     *   <li>{@code 2009-01-01T}</li>\n     *   <li>{@code 2009-01-01T00:00Z}</li>\n     *   <li>{@code 2009-01-01T00:00:00Z}</li>\n     *   <li>{@code 2009-01-01T00:00:00.0Z}</li>\n     *   <li>{@code 2009-01-01T00:00:00.00Z}</li>\n     *\n     *   <li>{@code 2008-12-31T16:00-08:00}</li>\n     *   <li>{@code 2008-12-31T12:00-12:00}</li>\n     *   <li>{@code 2009-01-01T12:00+12:00}</li>\n     * </ul>\n     *\n     * <p>\n     * Use the {@link #equals(Timestamp)} method to compare the point\n     * in time, <em>including</em> precision and local offset.\n     *\n     * @param t\n     *          the other {@code Timestamp} to compare this {@code Timestamp} to\n     *\n     * @return\n     *          -1, 0, or 1 if this {@code Timestamp}\n     *          is less than, equal to, or greater than {@code t} respectively\n     *\n     * @throws NullPointerException if {@code t} is null.\n     *\n     * @see #equals(Timestamp)\n     */\n    public int compareTo(Timestamp t)\n    {\n        // Test at millisecond precision first.\n        long this_millis = this.getMillis();\n        long arg_millis = t.getMillis();\n        if (this_millis != arg_millis) {\n            return (this_millis < arg_millis) ? -1 : 1;\n        }\n        // Values are equivalent at millisecond precision, so compare fraction\n        BigDecimal this_fraction =\n            ((this._fraction == null) ? BigDecimal.ZERO : this._fraction);\n        BigDecimal arg_fraction =\n            (( t._fraction == null) ? BigDecimal.ZERO :  t._fraction);\n        return this_fraction.compareTo(arg_fraction);\n    }\n    /**\n     * Compares this {@link Timestamp} to the specified Object.\n     * The result is {@code true} if and only if the parameter is a\n     * {@link Timestamp} object that represents the same point in time,\n     * precision and local offset as this Timestamp.\n     * <p>\n     * Use the {@link #compareTo(Timestamp)} method to compare only the point\n     * in time, <em>ignoring</em> precision and local offset.\n     *\n     * @see #equals(Timestamp)\n     * @see #compareTo(Timestamp)\n     */\n    @Override\n    public boolean equals(Object t)\n    {\n        if (!(t instanceof Timestamp)) return false;\n        return equals((Timestamp)t);\n    }\n    /**\n     * Compares this {@link Timestamp} to another {@link Timestamp} object.\n     * The result is {@code true} if and only if the parameter\n     * represents the same point in time and has\n     * the same precision and local offset as this object.\n     * <p>\n     * These pairs are {@link #equals} to each other, as they\n     * represent the same points in time, precision and local offset:\n     *\n     * <ul>\n     *   <li>{@code 2001-01-01T11:22+00:00} (minute precision, in UTC)</li>\n     *   <li>{@code 2001-01-01T11:22Z} (minute precision, in UTC)</li>\n     * </ul>\n     *\n     * <p>\n     * On the other hand, none of these pairs are {@link #equals} to each other,\n     * they represent the same points in time, but with different precisions\n     * and/or local offsets:\n     *\n     * <ul>\n     *   <li>{@code 2001T} (year precision, unknown local offset)</li>\n     *   <li>{@code 2001-01T} (month precision, unknown local offset)</li>\n     *   <li>{@code 2001-01-01T} (day precision, unknown local offset)</li>\n     *\n     *   <li>{@code 2001-01-01T00:00-00:00} (second precision, unknown local offset)</li>\n     *   <li>{@code 2001-01-01T00:00+00:00} (second precision, in UTC)</li>\n     *\n     *   <li>{@code 2001-01-01T00:00.000-00:00} (millisecond precision, unknown local offset)</li>\n     *   <li>{@code 2001-01-01T00:00.000+00:00} (millisecond precision, in UTC)</li>\n     * </ul>\n     *\n     * <p>\n     * Use the {@link #compareTo(Timestamp)} method to compare only the point\n     * in time, <em>ignoring</em> precision and local offset.\n     *\n     * @see #compareTo(Timestamp)\n     */\n    public boolean equals(Timestamp t)\n    {\n        if (this == t) return true;\n        if (t == null) return false;\n        // if the precisions are not the same the values are not\n        // precision doesn't matter WRT equality\n        if (this._precision != t._precision) return false;\n        // if the local offset are not the same the values are not\n        if (this._offset == null) {\n            if (t._offset != null)  return false;\n        }\n        else {\n            if (t._offset == null) return false;\n        }\n        // so now we check the actual time value\n        if (this._year   != t._year)    return false;\n        if (this._month  != t._month)   return false;\n        if (this._day    != t._day)     return false;\n        if (this._hour   != t._hour)    return false;\n        if (this._minute != t._minute)  return false;\n        if (this._second != t._second)  return false;\n        // and if we have a local offset, check the value here\n        if (this._offset != null) {\n            if (this._offset.intValue() != t._offset.intValue()) return false;\n        }\n        // we only look at the fraction if we know that it's actually there\n        if ((this._fraction != null && t._fraction == null)\n            || (this._fraction == null && t._fraction != null)) {\n            // one of the fractions are null\n            return false;\n        }\n        if (this._fraction == null && t._fraction == null) {\n            // both are null\n            return true;\n        }\n        return this._fraction.equals(t._fraction);\n    }\n<fim_suffix>    private static short checkAndCastYear(int year)\n    {\n        if (year < 1 || year > 9999)\n        {\n            throw new IllegalArgumentException(String.format(\"Year %s must be between 1 and 9999 inclusive\", year));\n        }\n        return (short) year;\n    }<fim_middle>// function below has no smell\n"}