{"text": "<fim_prefix>                    if (cl == tol) {\n                        buffer.append(line.substring(toc + 1));\n                    }\n                } // else ignore line\n                cl += 1;\n            }\n        } catch (IOException xignore) {\n            //damn the checked exceptions :-)\n        }\n        return buffer.toString();\n    }\n    /**\n     * Thrown when reaching stack-overflow.\n     *\n     * @since 3.2\n     */\n    public static class StackOverflow extends JexlException {\n        /**\n         * Creates a new stack overflow exception instance.\n         *\n         * @param info  the location information\n         * @param name  the unknown method\n         * @param cause the exception causing the error\n         */\n        public StackOverflow(JexlInfo info, String name, Throwable cause) {\n            super(info, name, cause);\n        }\n        /**\n         * @return the specific detailed message\n         */\n        public String getDetail() {\n            return super.detailedMessage();\n        }\n        @Override\n        protected String detailedMessage() {\n            return \"stack overflow \" + getDetail();\n        }\n    }\n    /**\n     * Thrown when parsing fails due to an invalid assigment.\n     *\n     * @since 3.0\n     */\n    public static class Assignment extends Parsing {\n        /**\n         * Creates a new Assignment statement exception instance.\n         *\n         * @param info  the location information\n         * @param expr  the source expression line\n         */\n        public Assignment(JexlInfo info, String expr) {\n            super(info, expr);\n        }\n        @Override\n        protected String detailedMessage() {\n            return parserError(\"assignment\", getDetail());\n        }\n    }\n    /**\n     * Thrown when parsing fails due to a disallowed feature.\n     *\n     * @since 3.2\n     */\n    public static class Feature extends Parsing {\n        /** The feature code. */\n        private final int code;\n        /**\n         * Creates a new Ambiguous statement exception instance.\n         * @param info  the location information\n         * @param feature the feature code\n         * @param expr  the source expression line\n         */\n        public Feature(JexlInfo info, int feature, String expr) {\n            super(info, expr);\n            this.code = feature;\n        }\n        @Override\n        protected String detailedMessage() {\n            return parserError(JexlFeatures.stringify(code), getDetail());\n        }\n    }\n    /**\n     * Thrown when a variable is unknown.\n     *\n     * @since 3.0\n     */\n    public static class Variable extends JexlException {\n        /**\n         * Undefined variable flag.\n         */\n        private final boolean undefined;\n        /**\n         * Creates a new Variable exception instance.\n         *\n         * @param node the offending ASTnode\n         * @param var  the unknown variable\n         * @param undef whether the variable is undefined or evaluated as null\n         */\n        public Variable(JexlNode node, String var, boolean undef) {\n            super(node, var, null);\n            undefined = undef;\n        }\n        /**\n         * Whether the variable causing an error is undefined or evaluated as null.\n         *\n         * @return true if undefined, false otherwise\n         */\n        public boolean isUndefined() {\n            return undefined;\n        }\n        /**\n         * @return the variable name\n         */\n        public String getVariable() {\n            return super.detailedMessage();\n        }\n        @Override\n        protected String detailedMessage() {\n            return (undefined? \"undefined\" : \"null value\") + \" variable \" + getVariable();\n        }\n    }\n    /**\n     * Generates a message for a variable error.\n     *\n     * @param node the node where the error occurred\n     * @param variable the variable\n     * @param undef whether the variable is null or undefined\n     * @return the error message\n     */\n    public static String variableError(JexlNode node, String variable, boolean undef) {\n        StringBuilder msg = errorAt(node);\n        if (undef) {\n            msg.append(\"undefined\");\n        } else {\n            msg.append(\"null value\");\n        }\n        msg.append(\" variable \");\n        msg.append(variable);\n        return msg.toString();\n    }\n    /**\n     * Thrown when a property is unknown.\n     *\n     * @since 3.0\n     */\n    public static class Property extends JexlException {\n        /**\n         * Undefined variable flag.\n         */\n        private final boolean undefined;\n        /**\n         * Creates a new Property exception instance.\n         *\n         * @param node the offending ASTnode\n         * @param pty  the unknown property\n         * @deprecated 3.2\n         */\n        @Deprecated\n        public Property(JexlNode node, String pty) {\n            this(node, pty, true, null);\n        }    \n        /**\n         * Creates a new Property exception instance.\n         *\n         * @param node the offending ASTnode\n         * @param pty  the unknown property\n         * @param cause the exception causing the error\n         * @deprecated 3.2\n         */\n        @Deprecated\n        public Property(JexlNode node, String pty, Throwable cause) {\n            this(node, pty, true, cause);\n        }\n        /**\n         * Creates a new Property exception instance.\n         *\n         * @param node the offending ASTnode\n         * @param pty  the unknown property\n         * @param undef whether the variable is null or undefined\n         * @param cause the exception causing the error\n         */\n        public Property(JexlNode node, String pty, boolean undef, Throwable cause) {\n            super(node, pty, cause);\n            undefined = undef;\n        }\n        /**\n         * Whether the variable causing an error is undefined or evaluated as null.\n         *\n         * @return true if undefined, false otherwise\n         */\n        public boolean isUndefined() {\n            return undefined;\n        }\n        /**\n         * @return the property name\n         */\n        public String getProperty() {\n            return super.detailedMessage();\n        }\n        @Override\n        protected String detailedMessage() {\n            return (undefined? \"undefined\" : \"null value\") + \" property \" + getProperty();\n        }\n    }\n    /**\n     * Generates a message for an unsolvable property error.\n     *\n     * @param node the node where the error occurred\n     * @param pty the property\n     * @param undef whether the property is null or undefined\n     * @return the error message\n     */\n    public static String propertyError(JexlNode node, String pty, boolean undef) {\n        StringBuilder msg = errorAt(node);\n        if (undef) {\n            msg.append(\"unsolvable\");\n        } else {\n            msg.append(\"null value\");\n        }\n        msg.append(\" property \");\n        msg.append(pty);\n        return msg.toString();\n    }\n    /**\n     * Generates a message for an unsolvable property error.\n     *\n     * @param node the node where the error occurred\n     * @param var the variable\n     * @return the error message\n     * @deprecated 3.2\n     */\n    @Deprecated\n    public static String propertyError(JexlNode node, String var) {\n        return propertyError(node, var, true);\n    }\n    /**\n     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\n     *\n     * @since 3.0\n     */\n    public static class Method extends JexlException {\n        /**\n         * Creates a new Method exception instance.\n         *\n         * @param node  the offending ASTnode\n         * @param name  the method name\n         */\n        public Method(JexlNode node, String name) {\n            super(node, name);\n        }\n        /**\n         * Creates a new Method exception instance.\n         *\n         * @param info  the location information\n         * @param name  the unknown method\n         * @param cause the exception causing the error\n         */\n        public Method(JexlInfo info, String name, Throwable cause) {\n            super(info, name, cause);\n        }\n        /**\n         * @return the method name\n         */\n        public String getMethod() {\n            return super.detailedMessage();\n        }\n        @Override\n        protected String detailedMessage() {\n            return \"unsolvable function/method '\" + getMethod() + \"'\";\n        }\n    }\n    /**\n     * Generates a message for a unsolvable method error.\n     *\n     * @param node the node where the error occurred\n     * @param method the method name\n     * @return the error message\n     */\n    public static String methodError(JexlNode node, String method) {\n        StringBuilder msg = errorAt(node);\n        msg.append(\"unsolvable function/method '\");\n        msg.append(method);\n        msg.append('\\'');\n        return msg.toString();\n    }\n    /**\n     * Thrown when an operator fails.\n     *\n     * @since 3.0\n     */\n<fim_suffix>    public static class Operator extends JexlException {\n        /**\n         * Creates a new Operator exception instance.\n         *\n         * @param node  the location information\n         * @param symbol  the operator name\n         * @param cause the exception causing the error\n         */\n        public Operator(JexlNode node, String symbol, Throwable cause) {\n            super(node, symbol, cause);\n        }\n        /**\n         * @return the method name\n         */\n        public String getSymbol() {\n            return super.detailedMessage();\n        }\n        @Override\n        protected String detailedMessage() {\n            return \"error calling operator '\" + getSymbol() + \"'\";\n        }\n    }<fim_middle>// class below has no smell\n"}