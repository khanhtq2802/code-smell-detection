{"text": "<fim_prefix>        threadPool);\n    peerNames = new String[numBspTask];\n    for (int i = 0; i < numBspTask; i++) {\n      peerNames[i] = \"local:\" + i;\n      completionService.submit(new BSPRunner(new HamaConfiguration(conf), job,\n          i, splits));\n      globalCounters.incrCounter(JobInProgress.JobCounter.LAUNCHED_TASKS, 1L);\n    }\n    new Thread(new ThreadObserver(numBspTask, completionService)).start();\n    return currentJobStatus;\n  }\n  @Override\n  public ClusterStatus getClusterStatus(boolean detailed) throws IOException {\n    return new ClusterStatus(maxTasks, totalTasks, maxTasks, State.RUNNING);\n  }\n  @Override\n  public JobProfile getJobProfile(BSPJobID jobid) throws IOException {\n    return new JobProfile(System.getProperty(\"user.name\"), jobid, jobFile,\n        jobName);\n  }\n  @Override\n  public JobStatus getJobStatus(BSPJobID jobid) throws IOException {\n    currentJobStatus.setSuperstepCount(superStepCount);\n    currentJobStatus.setProgress(superStepCount);\n    return currentJobStatus;\n  }\n  @Override\n  public String getFilesystemName() throws IOException {\n    return fs.getUri().toString();\n  }\n  @Override\n  public JobStatus[] jobsToComplete() throws IOException {\n    return null;\n  }\n  @Override\n  public JobStatus[] getAllJobs() throws IOException {\n    return null;\n  }\n  @Override\n  public String getSystemDir() {\n    return WORKING_DIR;\n  }\n  @Override\n  public void killJob(BSPJobID jobid) throws IOException {\n  }\n  @Override\n  public boolean killTask(TaskAttemptID taskId, boolean shouldFail)\n      throws IOException {\n    return false;\n  }\n  // this class will spawn a new thread and executes the BSP\n  @SuppressWarnings({ \"rawtypes\" })\n  static class BSPRunner implements Callable<BSPPeerImpl> {\n    private final HamaConfiguration conf;\n    private final BSPJob job;\n    private final int id;\n    private final BSP bsp;\n    private final RawSplit[] splits;\n    private BSPPeerImpl peer;\n    public BSPRunner(HamaConfiguration conf, BSPJob job, int id,\n        RawSplit[] splits) {\n      super();\n      this.conf = conf;\n      this.job = job;\n      this.id = id;\n      this.splits = splits;\n      // set the peer port to the id, to prevent collision\n      conf.setInt(Constants.PEER_PORT, id);\n      conf.set(Constants.PEER_HOST, \"local\");\n      bsp = (BSP) ReflectionUtils.newInstance(\n          job.getConfiguration().getClass(\"bsp.work.class\", BSP.class),\n          job.getConfiguration());\n    }\n    @SuppressWarnings(\"unchecked\")\n    public void run() throws Exception {\n      String splitname = null;\n      BytesWritable realBytes = null;\n      if (splits != null && splits.length > id) {\n        splitname = splits[id].getClassName();\n        realBytes = splits[id].getBytes();\n      }\n      peer = new BSPPeerImpl(job, conf, new TaskAttemptID(new TaskID(\n          job.getJobID(), id), id), new LocalUmbilical(), id, splitname,\n          realBytes, new Counters());\n      // Throw the first exception and log all the other exception.\n      Exception firstException = null;\n      try {\n        bsp.setup(peer);\n        bsp.bsp(peer);\n      } catch (Exception e) {\n        LOG.error(\"Exception during BSP execution!\", e);\n        firstException = e;\n      } finally {\n        try {\n          bsp.cleanup(peer);\n        } catch (Exception e) {\n          LOG.error(\"Error cleaning up after bsp execution.\", e);\n          if (firstException == null)\n            firstException = e;\n        } finally {\n          try {\n            peer.clear();\n            peer.close();\n          } catch (Exception e) {\n            LOG.error(\"Exception closing BSP peer,\", e);\n            if (firstException == null)\n              firstException = e;\n          } finally {\n            if (firstException != null)\n              throw firstException;\n          }\n        }\n      }\n    }\n    @Override\n    public BSPPeerImpl call() throws Exception {\n      run();\n      return peer;\n    }\n  }\n  // this thread observes the status of the runners.\n  @SuppressWarnings(\"rawtypes\")\n  class ThreadObserver implements Runnable {\n    private final ExecutorCompletionService<BSPPeerImpl> completionService;\n    private final int numTasks;\n    public ThreadObserver(int numTasks,\n    ExecutorCompletionService<BSPPeerImpl> completionService) {\n      this.numTasks = numTasks;\n      this.completionService = completionService;\n    }\n    @Override\n    public void run() {\n      boolean success = true;\n      for (int i = 0; i < numTasks; i++) {\n        try {\n          Future<BSPPeerImpl> take = completionService.take();\n          if (take != null) {\n            currentJobStatus.getCounter().incrAllCounters(\n                take.get().getCounters());\n          }\n        } catch (Exception e) {\n          LOG.error(\"Exception during BSP execution!\", e);\n          success = false;\n          break;\n        }\n      }\n      if (success) {\n        currentJobStatus.setState(JobStatus.State.SUCCEEDED);\n        currentJobStatus.setRunState(JobStatus.SUCCEEDED);\n      } else {\n        currentJobStatus.setState(JobStatus.State.FAILED);\n        currentJobStatus.setRunState(JobStatus.FAILED);\n      }\n      threadPool.shutdownNow();\n    }\n  }\n  public static class LocalMessageManager<M extends Writable> extends\n      AbstractMessageManager<M> {\n    @SuppressWarnings(\"rawtypes\")\n    private static final ConcurrentHashMap<InetSocketAddress, LocalMessageManager> MANAGER_MAP = new ConcurrentHashMap<InetSocketAddress, LocalBSPRunner.LocalMessageManager>();\n    private InetSocketAddress selfAddress;\n    @Override\n    public void init(TaskAttemptID attemptId, BSPPeer<?, ?, ?, ?, M> peer,\n        HamaConfiguration conf, InetSocketAddress peerAddress) {\n      super.init(attemptId, peer, conf, peerAddress);\n      MANAGER_MAP.put(peerAddress, this);\n      selfAddress = peerAddress;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void transfer(InetSocketAddress addr, BSPMessageBundle<M> bundle)\n        throws IOException {\n      // peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGE_BYTES_TRANSFERED,\n      // bundle.getLength());\n      MANAGER_MAP.get(addr).localQueueForNextIteration.addBundle(bundle);\n      peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGES_RECEIVED,\n          bundle.size());\n    }\n    @Override\n    public InetSocketAddress getListenerAddress() {\n      return selfAddress;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void transfer(InetSocketAddress addr, M msg) throws IOException {\n      MANAGER_MAP.get(addr).localQueueForNextIteration.add(msg);\n      peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGES_RECEIVED, 1);\n    }\n  }\n  public static class LocalUmbilical implements BSPPeerProtocol {\n    @Override\n    public long getProtocolVersion(String protocol, long clientVersion)\n        throws IOException {\n      return 0;\n    }\n    @Override\n    public void close() throws IOException {\n    }\n    @Override\n    public Task getTask(TaskAttemptID taskid) throws IOException {\n      return null;\n    }\n    @Override\n    public boolean ping(TaskAttemptID taskid) throws IOException {\n      return false;\n    }\n    @Override\n    public void done(TaskAttemptID taskid) throws IOException {\n    }\n    @Override\n    public void fsError(TaskAttemptID taskId, String message)\n        throws IOException {\n    }\n    @Override\n    public void fatalError(TaskAttemptID taskId, String message)\n        throws IOException {\n    }\n    @Override\n    public boolean statusUpdate(TaskAttemptID taskId, TaskStatus taskStatus)\n        throws IOException, InterruptedException {\n      return true;\n    }\n    @Override\n    public int getAssignedPortNum(TaskAttemptID taskid) {\n      // TODO Auto-generated method stub\n      return 0;\n    }\n  }\n  public static class LocalSyncClient extends BSPPeerSyncClient {\n    // note that this is static, because we will have multiple peers\n    private static CyclicBarrier barrier;\n    private int tasks;\n    @Override\n    public void init(Configuration conf, BSPJobID jobId, TaskAttemptID taskId)\n        throws Exception {\n      tasks = conf.getInt(\"bsp.peers.num\", 1);\n      synchronized (LocalSyncClient.class) {\n        if (barrier == null) {\n          barrier = new CyclicBarrier(tasks);\n          LOG.info(\"Setting up a new barrier for \" + tasks + \" tasks!\");\n        }\n      }\n    }\n<fim_suffix>    @Override\n    public void enterBarrier(BSPJobID jobId, TaskAttemptID taskId,\n        long superstep) throws SyncException {\n      try {\n        barrier.await();\n      } catch (Exception e) {\n        throw new SyncException(e.toString());\n      }\n    }<fim_middle>// function below has no smell\n"}