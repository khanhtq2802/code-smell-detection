{"text": "<fim_prefix>   * (0,2,1) (1,c,y)\n   * (1,0,0) (2,a,x)\n   * (1,0,1) (2,a,y)\n   * (1,1,0) (2,b,x)\n   * (1,1,1) (2,b,y)\n   * (1,2,0) (2,c,x)\n   * (1,2,1) (2,c,y)\n   * ...\n   */\n  public static class DynamicMultiDimensionalCollection {\n    /**\n     * Find out complete skewed-element collection\n     * For example:\n     * 1. skewed column (list): C1, C2\n     * 2. skewed value (list of list): (1,a), (2,b), (1,c)\n     * It returns the complete collection\n     * (1,a) , (1,b) , (1,c) , (1,other), (2,a), (2,b) , (2,c), (2,other), (other,a), (other,b),\n     * (other,c), (other,other)\n     * @throws SemanticException\n     */\n    public static List<List<String>> generateCollection(List<List<String>> values)\n        throws SemanticException {\n      // Calculate unique skewed elements for each skewed column.\n      List<List<String>> uniqSkewedElements = DynamicMultiDimensionalCollection.uniqueElementsList(\n          values, ListBucketingPrunerUtils.HIVE_LIST_BUCKETING_DEFAULT_KEY);\n      // Calculate complete dynamic-multi-dimension collection.\n      return DynamicMultiDimensionalCollection.flat(uniqSkewedElements);\n    }\n    /**\n     * Convert value to unique element list. This is specific for skew value use case:\n     * For example:\n     * 1. skewed column (list): C1, C2, C3\n     * 2. skewed value (list of list): (1,a,x), (2,b,x), (1,c,x), (2,a,y)\n     * Input: skewed value (list of list): (1,a,x), (2,b,x), (1,c,x), (2,a,y)\n     * Output: Unique skewed elements for each skewed column (list of list):\n     * (1,2,other), (a,b,c,other), (x,y,other)\n     * Output matches order of skewed column. Output can be read as:\n     * C1 has unique element list (1,2,other)\n     * C2 has unique element list (a,b,c,other)\n     * C3 has unique element list (x,y,other)\n     * Other represents any value which is not part skewed-value combination.\n     * @param values\n     *          skewed value list\n     * @return a list of unique element lists\n     */\n    public static List<List<String>> uniqueElementsList(List<List<String>> values,\n        String defaultDirName) {\n      // Get unique skewed value list.\n      List<List<String>> result = uniqueSkewedValueList(values);\n      // Add default dir at the end of each list\n      for (List<String> list : result) {\n        list.add(defaultDirName);\n      }\n      return result;\n    }\n    /**\n     * Convert value to unique skewed value list. It is used in\n     * {@link ListBucketingPrunerUtils#evaluateExprOnCell}\n     *\n     * For example:\n     *\n     * 1. skewed column (list): C1, C2, C3\n     * 2. skewed value (list of list): (1,a,x), (2,b,x), (1,c,x), (2,a,y)\n     *\n     * Input: skewed value (list of list): (1,a,x), (2,b,x), (1,c,x), (2,a,y)\n     * Output: Unique skewed value for each skewed column (list of list):\n     * (1,2), (a,b,c), (x,y)\n     *\n     * Output matches order of skewed column. Output can be read as:\n     * C1 has unique skewed value list (1,2,)\n     * C2 has unique skewed value list (a,b,c)\n     * C3 has unique skewed value list (x,y)\n     *\n     * @param values\n     *          skewed value list\n     * @return a list of unique skewed value lists\n     */\n    public static List<List<String>> uniqueSkewedValueList(List<List<String>> values) {\n      if ((values == null) || (values.size() == 0)) {\n        return null;\n      }\n      // skewed value has the same length.\n      List<List<String>> result = new ArrayList<List<String>>();\n      for (int i = 0; i < values.get(0).size(); i++) {\n        result.add(new ArrayList<String>());\n      }\n      // add unique element to list per occurrence order in skewed value.\n      // occurrence order in skewed value doesn't matter.\n      // as long as we add them to a list, order is preserved from now on.\n      for (List<String> value : values) {\n        for (int i = 0; i < value.size(); i++) {\n          if (!result.get(i).contains(value.get(i))) {\n            result.get(i).add(value.get(i));\n          }\n        }\n      }\n      return result;\n    }\n    /**\n     * Flat a dynamic-multi-dimension collection.\n     *\n     * For example:\n     * 1. skewed column (list): C1, C2, C3\n     * 2. skewed value (list of list): (1,a,x), (2,b,x), (1,c,x), (2,a,y)\n     *\n     * Unique skewed elements for each skewed column (list of list):\n     * (1,2,other), (a,b,c,other)\n     * Index: (0,1,2) (0,1,2,3)\n     *\n     * Complete dynamic-multi-dimension collection\n     * (0,0) (1,a) * -&gt; T\n     * (0,1) (1,b) -&gt; T\n     * (0,2) (1,c) *-&gt; F\n     * (0,3) (1,other)-&gt; F\n     * (1,0) (2,a)-&gt; F\n     * (1,1) (2,b) * -&gt; T\n     * (1,2) (2,c)-&gt; F\n     * (1,3) (2,other)-&gt; F\n     * (2,0) (other,a) -&gt; T\n     * (2,1) (other,b) -&gt; T\n     * (2,2) (other,c) -&gt; T\n     * (2,3) (other,other) -&gt; T\n     * * is skewed value entry\n     *\n     * @param uniqSkewedElements\n     *\n     * @return\n     */\n    public static List<List<String>> flat(List<List<String>> uniqSkewedElements)\n        throws SemanticException {\n      if (uniqSkewedElements == null) {\n        return null;\n      }\n      List<List<String>> collection = new ArrayList<List<String>>();\n      walker(collection, uniqSkewedElements, new ArrayList<String>(), 0);\n      return collection;\n    }\n    /**\n     * Flat the collection recursively.\n     *\n     * @param finalResult\n     * @param input\n     * @param listSoFar\n     * @param level\n     * @throws SemanticException\n     */\n<fim_suffix>    private static void walker(List<List<String>> finalResult, final List<List<String>> input,\n        List<String> listSoFar, final int level) throws SemanticException {\n      // Base case.\n      if (level == (input.size() - 1)) {\n        assert (input.get(level) != null) : \"Unique skewed element list has null list in \" + level\n            + \"th position.\";\n        for (String v : input.get(level)) {\n          List<String> oneCompleteIndex = new ArrayList<String>(listSoFar);\n          oneCompleteIndex.add(v);\n          finalResult.add(oneCompleteIndex);\n        }\n        return;\n      }\n      // Recursive.\n      for (String v : input.get(level)) {\n        List<String> clonedListSoFar = new ArrayList<String>(listSoFar);\n        clonedListSoFar.add(v);\n        int nextLevel = level + 1;\n        walker(finalResult, input, clonedListSoFar, nextLevel);\n      }\n    }<fim_middle>// function below is long method\n"}