{"text": "<fim_prefix>/*\n   Copyright (c) 2012 LinkedIn Corp.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n */\n\npackage com.linkedin.restli.server;\n\nimport com.linkedin.data.DataMap;\nimport com.linkedin.restli.common.HttpStatus;\n\n/**\n * Represents an unexpected service failure.\n *\n * @author dellamag\n */\n<fim_suffix>public class RestLiServiceException extends RuntimeException\n{\n  private static final long serialVersionUID = 1L;\n\n  private final HttpStatus    _status;\n  private Integer             _serviceErrorCode;\n  private DataMap             _errorDetails;\n  private ErrorResponseFormat _errorResponseFormat;\n\n  public RestLiServiceException(final HttpStatus status)\n  {\n    this(status, null, null);\n  }\n\n  public RestLiServiceException(final HttpStatus status, final String message)\n  {\n    this(status, message, null);\n  }\n\n  public RestLiServiceException(final HttpStatus status,\n                                final Throwable cause)\n  {\n    super(cause);\n    _status = status;\n  }\n\n  public RestLiServiceException(final HttpStatus status,\n                                final String message,\n                                final Throwable cause)\n  {\n    super(message, cause);\n    _status = status;\n  }\n\n  /**\n   * Construct a new instance using the specified HTTP status, exception message, cause, and an option to disable\n   * stacktrace. Consider setting {@code writableStackTrace} to {@code false} to conserve computation cost if the\n   * stacktrace does not contribute meaningful insights.\n   *\n   * @param status the HTTP status to use along with the exception\n   * @param message the exception message for this exception.\n   * @param cause the cause of this exception.\n   * @param writableStackTrace the exception stacktrace is filled in if true; false otherwise.\n   */\n  public RestLiServiceException(final HttpStatus status,\n      final String message, final Throwable cause, boolean writableStackTrace)\n  {\n    super(message, cause, true, writableStackTrace);\n    _status = status;\n  }\n\n  public HttpStatus getStatus()\n  {\n    return _status;\n  }\n\n  public RestLiServiceException setServiceErrorCode(final Integer serviceErrorCode)\n  {\n    _serviceErrorCode = serviceErrorCode;\n    return this;\n  }\n\n  public boolean hasServiceErrorCode()\n  {\n    return _serviceErrorCode != null;\n  }\n\n  public Integer getServiceErrorCode()\n  {\n    return _serviceErrorCode;\n  }\n\n  public DataMap getErrorDetails()\n  {\n    return _errorDetails;\n  }\n\n  public boolean hasErrorDetails()\n  {\n    return _errorDetails != null;\n  }\n\n  public RestLiServiceException setErrorDetails(final DataMap errorDetails)\n  {\n    _errorDetails = errorDetails;\n    return this;\n  }\n\n  @Override\n  public String toString()\n  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(getClass().getName());\n    sb.append(\" [HTTP Status:\").append(_status.getCode());\n    if (_serviceErrorCode != null)\n    {\n      sb.append(\", serviceErrorCode:\").append(_serviceErrorCode);\n    }\n    sb.append(\"]\");\n    String message = getLocalizedMessage();\n    if (message != null)\n    {\n      sb.append(\": \").append(message);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Sets an error response format that will be used instead of the default server wide\n   * error response format.\n   *\n   * @param errorResponseFormat the overriding ErrorResponseFormat this service exception should be built with.\n   */\n  public void setOverridingFormat(ErrorResponseFormat errorResponseFormat)\n  {\n    _errorResponseFormat = errorResponseFormat;\n  }\n\n  /**\n   * Returns whether this exception has an overriding error format.\n   *\n   * @return true if this exception has an overriding error response format set.\n   */\n  public boolean hasOverridingErrorResponseFormat()\n  {\n    return _errorResponseFormat != null;\n  }\n\n  public ErrorResponseFormat getOverridingFormat()\n  {\n    return _errorResponseFormat;\n  }\n\n  public static RestLiServiceException fromThrowable(Throwable throwable)\n  {\n    RestLiServiceException restLiServiceException;\n    if (throwable instanceof RestLiServiceException)\n    {\n      restLiServiceException = (RestLiServiceException) throwable;\n    }\n    else if (throwable instanceof RoutingException)\n    {\n      RoutingException routingException = (RoutingException) throwable;\n\n      restLiServiceException = new RestLiServiceException(HttpStatus.fromCode(routingException.getStatus()),\n          routingException.getMessage(),\n          routingException);\n    }\n    else\n    {\n      restLiServiceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n          throwable.getMessage(),\n          throwable);\n    }\n\n    return restLiServiceException;\n  }\n\n}<fim_middle>// class below has no smell\n"}