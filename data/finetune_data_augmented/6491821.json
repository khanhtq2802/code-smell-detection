{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n *******************************************************************************/\npackage org.eclipse.rdf4j.rio.helpers;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.eclipse.rdf4j.model.Graph;\nimport org.eclipse.rdf4j.model.IRI;\nimport org.eclipse.rdf4j.model.Resource;\nimport org.eclipse.rdf4j.model.Statement;\nimport org.eclipse.rdf4j.model.impl.GraphImpl;\nimport org.eclipse.rdf4j.model.util.GraphUtil;\nimport org.eclipse.rdf4j.model.vocabulary.RDF;\nimport org.eclipse.rdf4j.rio.RDFHandler;\nimport org.eclipse.rdf4j.rio.RDFHandlerException;\n\n/**\n * An {@link RDFHandlerWrapper} that buffers statements internally and passes them to underlying handlers grouped by\n * context, then subject, then predicate.\n * \n * @author Jeen Broekstra\n */\npublic class BufferedGroupingRDFHandler extends RDFHandlerWrapper {\n\n\t/**\n\t * Default buffer size. Buffer size is expressed in number of RDF statements. The default is set to 1024.\n\t */\n\tpublic static final int DEFAULT_BUFFER_SIZE = 1024;\n\n\tprivate final int bufferSize;\n\n\tprivate final Graph bufferedStatements;\n\n\tprivate final Set<Resource> contexts;\n\n\tprivate final Object bufferLock = new Object();\n\n\t/**\n\t * Creates a new BufferedGroupedWriter that wraps the supplied handlers, using the default buffer size.\n\t * \n\t * @param handlers one or more wrapped RDFHandlers\n\t */\n<fim_suffix>\tpublic BufferedGroupingRDFHandler(RDFHandler... handlers) {\n\t\tthis(DEFAULT_BUFFER_SIZE, handlers);\n\t}\n\n\t/**\n\t * Creates a new BufferedGroupedWriter that wraps the supplied handlers, using the supplied buffer size.\n\t * \n\t * @param bufferSize size of the buffer expressed in number of RDF statements\n\t * @param handlers   one or more wrapped RDFHandlers\n\t */\n\tpublic BufferedGroupingRDFHandler(int bufferSize, RDFHandler... handlers) {\n\t\tsuper(handlers);\n\t\tthis.bufferSize = bufferSize;\n\t\tthis.bufferedStatements = new GraphImpl();\n\t\tthis.contexts = new HashSet<>();\n\t}\n\n\t@Override\n\tpublic void handleStatement(Statement st) throws RDFHandlerException {\n\t\tsynchronized (bufferLock) {\n\t\t\tbufferedStatements.add(st);\n\t\t\tcontexts.add(st.getContext());\n\n\t\t\tif (bufferedStatements.size() >= this.bufferSize) {\n\t\t\t\tprocessBuffer();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n\t */\n\tprivate void processBuffer() throws RDFHandlerException {\n\t\t// primary grouping per context.\n\t\tfor (Resource context : contexts) {\n\t\t\tSet<Resource> subjects = GraphUtil.getSubjects(bufferedStatements, null, null, context);\n\t\t\tfor (Resource subject : subjects) {\n\t\t\t\tSet<IRI> processedPredicates = new HashSet<>();\n\n\t\t\t\t// give rdf:type preference over other predicates.\n\t\t\t\tIterator<Statement> typeStatements = bufferedStatements.match(subject, RDF.TYPE, null, context);\n\t\t\t\twhile (typeStatements.hasNext()) {\n\t\t\t\t\tStatement typeStatement = typeStatements.next();\n\t\t\t\t\tsuper.handleStatement(typeStatement);\n\t\t\t\t}\n\n\t\t\t\tprocessedPredicates.add(RDF.TYPE);\n\n\t\t\t\t// retrieve other statement from this context with the same\n\t\t\t\t// subject, and output them grouped by predicate\n\t\t\t\tIterator<Statement> subjectStatements = bufferedStatements.match(subject, null, null, context);\n\t\t\t\twhile (subjectStatements.hasNext()) {\n\t\t\t\t\tStatement subjectStatement = subjectStatements.next();\n\t\t\t\t\tIRI predicate = subjectStatement.getPredicate();\n\t\t\t\t\tif (!processedPredicates.contains(predicate)) {\n\t\t\t\t\t\tIterator<Statement> toWrite = bufferedStatements.match(subject, predicate, null, context);\n\t\t\t\t\t\twhile (toWrite.hasNext()) {\n\t\t\t\t\t\t\tStatement toWriteSt = toWrite.next();\n\t\t\t\t\t\t\tsuper.handleStatement(toWriteSt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocessedPredicates.add(predicate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbufferedStatements.clear();\n\t\tcontexts.clear();\n\t}\n\n\t@Override\n\tpublic void endRDF() throws RDFHandlerException {\n\t\tsynchronized (bufferLock) {\n\t\t\tprocessBuffer();\n\t\t}\n\t\tsuper.endRDF();\n\t}\n}<fim_middle>// function below has no smell\n"}