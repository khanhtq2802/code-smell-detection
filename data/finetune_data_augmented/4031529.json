{"text": "<fim_prefix>          Combine.globally(\n              CountMinSketchFn.create(input.getCoder())\n                  .withAccuracy(relativeError(), confidence())));\n    }\n  }\n  /**\n   * Implementation of {@link #perKey()}.\n   *\n   * @param <K> type of the keys mapping the elements\n   * @param <V> type of the values being combined per key\n   */\n  @AutoValue\n  public abstract static class PerKeySketch<K, V>\n      extends PTransform<PCollection<KV<K, V>>, PCollection<KV<K, Sketch<V>>>> {\n    abstract double relativeError();\n    abstract double confidence();\n    abstract Builder<K, V> toBuilder();\n    static <K, V> Builder<K, V> builder() {\n      return new AutoValue_SketchFrequencies_PerKeySketch.Builder<K, V>()\n          .setRelativeError(0.01)\n          .setConfidence(0.999);\n    }\n    @AutoValue.Builder\n    abstract static class Builder<K, V> {\n      abstract Builder<K, V> setRelativeError(double eps);\n      abstract Builder<K, V> setConfidence(double conf);\n      abstract PerKeySketch<K, V> build();\n    }\n    /**\n     * Sets the relative error {@code epsilon}.\n     *\n     * <p>Keep in mind that the lower the {@code epsilon} value, the greater the width.\n     *\n     * @param eps the error relative to the total number of distinct elements\n     */\n    public PerKeySketch<K, V> withRelativeError(double eps) {\n      return toBuilder().setRelativeError(eps).build();\n    }\n    /**\n     * Sets the {@code confidence} value, i.e. the probability that the relative error is lower or\n     * equal to {@code epsilon}.\n     *\n     * <p>Keep in mind that the greater the confidence, the greater the depth.\n     *\n     * @param conf the confidence in the result to not exceed the relative error\n     */\n    public PerKeySketch<K, V> withConfidence(double conf) {\n      return toBuilder().setConfidence(conf).build();\n    }\n    @Override\n    public PCollection<KV<K, Sketch<V>>> expand(PCollection<KV<K, V>> input) {\n      KvCoder<K, V> inputCoder = (KvCoder<K, V>) input.getCoder();\n      return input.apply(\n          \"Compute Count-Min Sketch perKey\",\n          Combine.perKey(\n              CountMinSketchFn.create(inputCoder.getValueCoder())\n                  .withAccuracy(relativeError(), confidence())));\n    }\n  }\n  /**\n   * Implements the {@link CombineFn} of {@link SketchFrequencies} transforms.\n   *\n   * @param <InputT> the type of the elements in the input {@link PCollection}\n   */\n  public static class CountMinSketchFn<InputT>\n      extends CombineFn<InputT, Sketch<InputT>, Sketch<InputT>> {\n    private final Coder<InputT> inputCoder;\n    private final int depth;\n    private final int width;\n    private final double epsilon;\n    private final double confidence;\n    private CountMinSketchFn(final Coder<InputT> coder, double eps, double confidence) {\n      this.epsilon = eps;\n      this.confidence = confidence;\n      this.width = (int) Math.ceil(2 / eps);\n      this.depth = (int) Math.ceil(-Math.log(1 - confidence) / Math.log(2));\n      this.inputCoder = coder;\n    }\n    /**\n     * Returns a {@link CountMinSketchFn} combiner with the given input coder. <br>\n     * <b>Warning :</b> the coder must be deterministic.\n     *\n     * @param coder the coder that encodes the elements' type\n     */\n    public static <InputT> CountMinSketchFn<InputT> create(Coder<InputT> coder) {\n      try {\n        coder.verifyDeterministic();\n      } catch (Coder.NonDeterministicException e) {\n        throw new IllegalArgumentException(\n            \"Coder must be deterministic to perform this sketch.\" + e.getMessage(), e);\n      }\n      return new CountMinSketchFn<>(coder, 0.01, 0.999);\n    }\n    /**\n     * Returns a new {@link CountMinSketchFn} combiner with new precision accuracy parameters {@code\n     * epsilon} and {@code confidence}.\n     *\n     * <p>Keep in mind that the lower the {@code epsilon} value, the greater the width, and the\n     * greater the confidence, the greater the depth.\n     *\n     * @param epsilon the error relative to the total number of distinct elements\n     * @param confidence the confidence in the result to not exceed the relative error\n     */\n    public CountMinSketchFn<InputT> withAccuracy(double epsilon, double confidence) {\n      if (epsilon <= 0D) {\n        throw new IllegalArgumentException(\"The relative error must be positive\");\n      }\n      if (confidence <= 0D || confidence >= 1D) {\n        throw new IllegalArgumentException(\"The confidence must be between 0 and 1\");\n      }\n      return new CountMinSketchFn<>(inputCoder, epsilon, confidence);\n    }\n    @Override\n    public Sketch<InputT> createAccumulator() {\n      return Sketch.create(epsilon, confidence);\n    }\n    @Override\n    public Sketch<InputT> addInput(Sketch<InputT> accumulator, InputT element) {\n      accumulator.add(element, inputCoder);\n      return accumulator;\n    }\n    @Override\n    public Sketch<InputT> mergeAccumulators(Iterable<Sketch<InputT>> accumulators) {\n      Iterator<Sketch<InputT>> it = accumulators.iterator();\n      Sketch<InputT> first = it.next();\n      CountMinSketch mergedSketches = first.sketch();\n      try {\n        while (it.hasNext()) {\n          mergedSketches = CountMinSketch.merge(mergedSketches, it.next().sketch());\n        }\n      } catch (FrequencyMergeException e) {\n        // Should never happen because every instantiated accumulator are of the same type.\n        throw new IllegalStateException(\"The accumulators cannot be merged:\" + e.getMessage());\n      }\n      return Sketch.create(mergedSketches);\n    }\n    /** Output the whole structure so it can be queried, reused or stored easily. */\n    @Override\n    public Sketch<InputT> extractOutput(Sketch<InputT> accumulator) {\n      return accumulator;\n    }\n    @Override\n    public Coder<Sketch<InputT>> getAccumulatorCoder(CoderRegistry registry, Coder inputCoder) {\n      return new CountMinSketchCoder<>();\n    }\n    @Override\n    public void populateDisplayData(DisplayData.Builder builder) {\n      super.populateDisplayData(builder);\n      builder\n          .add(DisplayData.item(\"width\", width).withLabel(\"width of the Count-Min sketch array\"))\n          .add(DisplayData.item(\"depth\", depth).withLabel(\"depth of the Count-Min sketch array\"))\n          .add(\n              DisplayData.item(\"eps\", epsilon)\n                  .withLabel(\"relative error to the total number of elements\"))\n          .add(DisplayData.item(\"conf\", confidence).withLabel(\"confidence in the relative error\"));\n    }\n  }\n  /**\n   * Wrap StreamLib's Count-Min Sketch to support counting all user types by hashing the encoded\n   * user type using the supplied deterministic coder. This is required since objects in Apache Beam\n   * are considered equal if their encodings are equal.\n   */\n  @AutoValue\n  public abstract static class Sketch<T> implements Serializable {\n    static final int SEED = 123456;\n    static <T> Sketch<T> create(double eps, double conf) {\n      int width = (int) Math.ceil(2 / eps);\n      int depth = (int) Math.ceil(-Math.log(1 - conf) / Math.log(2));\n      return new AutoValue_SketchFrequencies_Sketch<>(\n          depth, width, new CountMinSketch(depth, width, SEED));\n    }\n<fim_suffix>    static <T> Sketch<T> create(CountMinSketch sketch) {\n      int width = (int) Math.ceil(2 / sketch.getRelativeError());\n      int depth = (int) Math.ceil(-Math.log(1 - sketch.getConfidence()) / Math.log(2));\n      return new AutoValue_SketchFrequencies_Sketch<>(depth, width, sketch);\n    }<fim_middle>// function below has no smell\n"}