{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.exec.planner.fragment;\n\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.drill.shaded.guava.com.google.common.collect.Maps;\n\npublic class PlanningSet implements Iterable<Wrapper> {\n  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(PlanningSet.class);\n\n  private final Map<Fragment, Wrapper> fragmentMap = Maps.newHashMap();\n  private int majorFragmentIdIndex = 0;\n\n  private Wrapper rootWrapper = null;\n\n<fim_suffix>  public Wrapper get(Fragment node) {\n    Wrapper wrapper = fragmentMap.get(node);\n    if (wrapper == null) {\n\n      int majorFragmentId = 0;\n\n      // If there is a sending exchange, we need to number other than zero.\n      if (node.getSendingExchange() != null) {\n\n        // assign the upper 16 bits as the major fragment id.\n        majorFragmentId = node.getSendingExchange().getChild().getOperatorId() >> 16;\n\n        // if they are not assigned, that means we mostly likely have an externally generated plan.  in this case, come up with a major fragmentid.\n        if (majorFragmentId == 0) {\n          majorFragmentId = majorFragmentIdIndex;\n        }\n      }\n      wrapper = new Wrapper(node, majorFragmentId);\n      fragmentMap.put(node, wrapper);\n      majorFragmentIdIndex++;\n    }\n    return wrapper;\n  }\n\n  @Override\n  public Iterator<Wrapper> iterator() {\n    return this.fragmentMap.values().iterator();\n  }\n\n  @Override\n  public String toString() {\n    return \"FragmentPlanningSet:\\n\" + fragmentMap.values() + \"]\";\n  }\n\n  /**\n   * find the root Wrapper which contains the root Fragment and\n   * hold the root wrapper\n   * @param rootFragment\n   * @return root wrapper\n   */\n  public Wrapper findRootWrapper(Fragment rootFragment){\n    for (Wrapper wrapper : this) {\n      Fragment fragment = wrapper.getNode();\n      if (fragment == rootFragment) {\n        rootWrapper = wrapper;\n        break;\n      }\n    }\n    return rootWrapper;\n  }\n\n  public Wrapper getRootWrapper(){\n    return rootWrapper;\n  }\n\n}<fim_middle>// function below has no smell\n"}