{"text": "<fim_prefix>// Copyright (c) 2007-Present Pivotal Software, Inc.  All rights reserved.\n//\n// This software, the RabbitMQ Java client library, is triple-licensed under the\n// Mozilla Public License 1.1 (\"MPL\"), the GNU General Public License version 2\n// (\"GPL\") and the Apache License version 2 (\"ASL\"). For the MPL, please see\n// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,\n// please see LICENSE-APACHE2.\n//\n// This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY KIND,\n// either express or implied. See the LICENSE file for specific language governing\n// rights and limitations of this software.\n//\n// If you have any questions regarding licensing, please contact us at\n// info@rabbitmq.com.\npackage com.rabbitmq.tools.jsonrpc;\nimport com.rabbitmq.client.AMQP;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.StringRpcServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * JSON-RPC Server class.\n * <p>\n * Given a Java {@link Class}, representing an interface, and an\n * implementation of that interface, JsonRpcServer will reflect on the\n * class to construct the {@link ServiceDescription}, and will route\n * incoming requests for methods on the interface to the\n * implementation object while the mainloop() is running.\n * <p>\n * {@link JsonRpcServer} delegates JSON parsing and generating to\n * a {@link JsonRpcMapper}.\n *\n * @see com.rabbitmq.client.RpcServer\n * @see JsonRpcClient\n * @see JsonRpcMapper\n * @see JacksonJsonRpcMapper\n */\npublic class JsonRpcServer extends StringRpcServer {\n    private static final Logger LOGGER = LoggerFactory.getLogger(JsonRpcServer.class);\n    private final JsonRpcMapper mapper;\n    /**\n     * Holds the JSON-RPC service description for this client.\n     */\n    private ServiceDescription serviceDescription;\n    /**\n     * The instance backing this server.\n     */\n    private Object interfaceInstance;\n    public JsonRpcServer(Channel channel,\n        Class<?> interfaceClass,\n        Object interfaceInstance, JsonRpcMapper mapper)\n        throws IOException {\n        super(channel);\n        this.mapper = mapper;\n        init(interfaceClass, interfaceInstance);\n    }\n    /**\n     * Construct a server that talks to the outside world using the\n     * given channel, and constructs a fresh temporary\n     * queue. Use getQueueName() to discover the created queue name.\n     *\n     * @param channel           AMQP channel to use\n     * @param interfaceClass    Java interface that this server is exposing to the world\n     * @param interfaceInstance Java instance (of interfaceClass) that is being exposed\n     * @throws IOException if something goes wrong during an AMQP operation\n     */\n    public JsonRpcServer(Channel channel,\n        Class<?> interfaceClass,\n        Object interfaceInstance)\n        throws IOException {\n        this(channel, interfaceClass, interfaceInstance, new JacksonJsonRpcMapper());\n    }\n    public JsonRpcServer(Channel channel,\n        String queueName,\n        Class<?> interfaceClass,\n        Object interfaceInstance, JsonRpcMapper mapper)\n        throws IOException {\n        super(channel, queueName);\n        this.mapper = mapper;\n        init(interfaceClass, interfaceInstance);\n    }\n    /**\n     * Construct a server that talks to the outside world using the\n     * given channel and queue name. Our superclass,\n     * RpcServer, expects the queue to exist at the time of\n     * construction.\n     *\n     * @param channel           AMQP channel to use\n     * @param queueName         AMQP queue name to listen for requests on\n     * @param interfaceClass    Java interface that this server is exposing to the world\n     * @param interfaceInstance Java instance (of interfaceClass) that is being exposed\n     * @throws IOException if something goes wrong during an AMQP operation\n     */\n    public JsonRpcServer(Channel channel,\n        String queueName,\n        Class<?> interfaceClass,\n        Object interfaceInstance)\n        throws IOException {\n        this(channel, queueName, interfaceClass, interfaceInstance, new JacksonJsonRpcMapper());\n    }\n<fim_suffix>    private void init(Class<?> interfaceClass, Object interfaceInstance) {\n        /**\n         * The interface this server implements.\n         */\n        this.interfaceInstance = interfaceInstance;\n        this.serviceDescription = new ServiceDescription(interfaceClass);\n    }\n    /**\n     * Override our superclass' method, dispatching to doCall.\n     */\n    @Override\n    public String handleStringCall(String requestBody, AMQP.BasicProperties replyProperties) {\n        String replyBody = doCall(requestBody);\n        return replyBody;\n    }\n    /**\n     * Runs a single JSON-RPC request.\n     *\n     * @param requestBody the JSON-RPC request string (a JSON encoded value)\n     * @return a JSON-RPC response string (a JSON encoded value)\n     */\n    public String doCall(String requestBody) {\n        Object id;\n        String method;\n        Object[] params;\n        String response;\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Request: {}\", requestBody);\n        }\n        try {\n            JsonRpcMapper.JsonRpcRequest request = mapper.parse(requestBody, serviceDescription);\n            if (request == null) {\n                response = errorResponse(null, 400, \"Bad Request\", null);\n            } else if (!ServiceDescription.JSON_RPC_VERSION.equals(request.getVersion())) {\n                response = errorResponse(null, 505, \"JSONRPC version not supported\", null);\n            } else {\n                id = request.getId();\n                method = request.getMethod();\n                params = request.getParameters();\n                if (request.isSystemDescribe()) {\n                    response = resultResponse(id, serviceDescription);\n                } else if (request.isSystem()) {\n                    response = errorResponse(id, 403, \"System methods forbidden\", null);\n                } else {\n                    Object result;\n                    try {\n                        Method matchingMethod = matchingMethod(method, params);\n                        if (LOGGER.isDebugEnabled()) {\n                            Collection<String> parametersValuesAndTypes = new ArrayList<String>();\n                            if (params != null) {\n                                for (Object param : params) {\n                                    parametersValuesAndTypes.add(\n                                        String.format(\"%s (%s)\", param, param == null ? \"?\" : param.getClass())\n                                    );\n                                }\n                            }\n                            LOGGER.debug(\"About to invoke {} method with parameters {}\", matchingMethod, parametersValuesAndTypes);\n                        }\n                        result = matchingMethod.invoke(interfaceInstance, params);\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Invocation returned {} ({})\", result, result == null ? \"?\" : result.getClass());\n                        }\n                        response = resultResponse(id, result);\n                    } catch (Throwable t) {\n                        LOGGER.info(\"Error while processing JSON RPC request\", t);\n                        response = errorResponse(id, 500, \"Internal Server Error\", t);\n                    }\n                }\n            }\n        } catch (ClassCastException cce) {\n            // Bogus request!\n            response = errorResponse(null, 400, \"Bad Request\", null);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Response: {}\", response);\n        }\n        return response;\n    }\n    /**\n     * Retrieves the best matching method for the given method name and parameters.\n     * <p>\n     * Subclasses may override this if they have specialised\n     * dispatching requirements, so long as they continue to honour\n     * their ServiceDescription.\n     */\n    public Method matchingMethod(String methodName, Object[] params) {\n        ProcedureDescription proc = serviceDescription.getProcedure(methodName, params.length);\n        return proc.internal_getMethod();\n    }\n    /**\n     * Construct and encode a JSON-RPC error response for the request\n     * ID given, using the code, message, and possible\n     * (JSON-encodable) argument passed in.\n     */\n    private String errorResponse(Object id, int code, String message, Object errorArg) {\n        Map<String, Object> err = new HashMap<String, Object>();\n        err.put(\"name\", \"JSONRPCError\");\n        err.put(\"code\", code);\n        err.put(\"message\", message);\n        err.put(\"error\", errorArg);\n        return response(id, \"error\", err);\n    }\n    /**\n     * Construct and encode a JSON-RPC success response for the\n     * request ID given, using the result value passed in.\n     */\n    private String resultResponse(Object id, Object result) {\n        return response(id, \"result\", result);\n    }\n    /**\n     * Private API - used by errorResponse and resultResponse.\n     */\n    private String response(Object id, String label, Object value) {\n        Map<String, Object> resp = new HashMap<String, Object>();\n        resp.put(\"version\", ServiceDescription.JSON_RPC_VERSION);\n        if (id != null) {\n            resp.put(\"id\", id);\n        }\n        resp.put(label, value);\n        String respStr = mapper.write(resp);\n        return respStr;\n    }\n    /**<fim_middle>// function below has no smell\n"}