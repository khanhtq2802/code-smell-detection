{"text": "<fim_prefix>    Iterable<Entry<String,String>> tableProps;\n    if (namespaces) {\n      try {\n        tableProps = shellState.getAccumuloClient().namespaceOperations()\n            .getProperties(OptUtil.getNamespaceOpt(cl, shellState));\n      } catch (NamespaceNotFoundException e) {\n        throw new IllegalArgumentException(e);\n      }\n    } else if (tables) {\n      tableProps = shellState.getAccumuloClient().tableOperations()\n          .getProperties(OptUtil.getTableOpt(cl, shellState));\n    } else {\n      throw new IllegalArgumentException(\"No table or namespace specified\");\n    }\n    for (Entry<String,String> entry : tableProps) {\n      if (entry.getKey().equals(Property.TABLE_CLASSPATH.getKey())) {\n        classpath = entry.getValue();\n      }\n    }\n    ClassLoader classloader;\n    if (classpath != null && !classpath.equals(\"\")) {\n      shellState.getAccumuloClient().instanceOperations().getSystemConfiguration()\n          .get(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey() + classpath);\n      try {\n        final Map<String,String> systemConfig = shellState.getAccumuloClient().instanceOperations()\n            .getSystemConfiguration();\n        AccumuloVFSClassLoader.getContextManager()\n            .setContextConfig(new ContextManager.DefaultContextsConfig() {\n              @Override\n              public Map<String,String> getVfsContextClasspathProperties() {\n                Map<String,String> filteredMap = new HashMap<>();\n                for (Entry<String,String> entry : systemConfig.entrySet()) {\n                  if (entry.getKey().startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey())) {\n                    filteredMap.put(entry.getKey(), entry.getValue());\n                  }\n                }\n                return filteredMap;\n              }\n            });\n      } catch (IllegalStateException ise) {}\n      classloader = AccumuloVFSClassLoader.getContextManager().getClassLoader(classpath);\n    } else {\n      classloader = AccumuloVFSClassLoader.getClassLoader();\n    }\n    return classloader;\n  }\n  @Override\n  public String keyword() {\n    return \"shell\";\n  }\n  @Override\n  public UsageGroup usageGroup() {\n    return UsageGroup.CORE;\n  }\n  @Override\n  public String description() {\n    return \"Runs Accumulo shell\";\n  }\n  @SuppressFBWarnings(value = \"DM_EXIT\", justification = \"System.exit() from a main class is okay\")\n  @Override\n  public void execute(final String[] args) throws IOException {\n    try {\n      if (!config(args)) {\n        System.exit(getExitCode());\n      }\n      System.exit(start());\n    } finally {\n      shutdown();\n      TraceUtil.disable();\n    }\n  }\n  public static void main(String[] args) throws IOException {\n    new Shell(new ConsoleReader()).execute(args);\n  }\n  public int start() throws IOException {\n    String input;\n    if (isVerbose())\n      printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n      home = System.getenv(\"HOME\");\n    String configDir = home + \"/\" + HISTORY_DIR_NAME;\n    String historyPath = configDir + \"/\" + HISTORY_FILE_NAME;\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n      log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n      final FileHistory history = new FileHistory(new File(historyPath));\n      reader.setHistory(history);\n      // Add shutdown hook to flush file history, per jline javadocs\n      Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n        try {\n          history.flush();\n        } catch (IOException e) {\n          log.warn(\"Could not flush history to file.\");\n        }\n      }));\n    } catch (IOException e) {\n      log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    // Turn Ctrl+C into Exception instead of JVM exit\n    reader.setHandleUserInterrupt(true);\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n      try (java.util.Scanner scanner = new java.util.Scanner(execFile, UTF_8.name())) {\n        while (scanner.hasNextLine() && !hasExited()) {\n          execCommand(scanner.nextLine(), true, isVerbose());\n        }\n      }\n    } else if (execCommand != null) {\n      for (String command : execCommand.split(\"\\n\")) {\n        execCommand(command, true, isVerbose());\n      }\n      return exitCode;\n    }\n    while (true) {\n      try {\n        if (hasExited())\n          return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n          if (userCompletor != null)\n            reader.removeCompleter(userCompletor);\n          userCompletor = setupCompletion();\n          reader.addCompleter(userCompletor);\n        }\n        reader.setPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n          reader.println();\n          return exitCode;\n        } // User Canceled (Ctrl+D)\n        execCommand(input, disableAuthTimeout, false);\n      } catch (UserInterruptException uie) {\n        // User Cancelled (Ctrl+C)\n        reader.println();\n        String partialLine = uie.getPartialLine();\n        if (partialLine == null || \"\".equals(uie.getPartialLine().trim())) {\n          // No content, actually exit\n          return exitCode;\n        }\n      } finally {\n        reader.flush();\n      }\n    }\n  }\n  public void shutdown() {\n    if (reader != null) {\n      reader.shutdown();\n    }\n    if (accumuloClient != null) {\n      accumuloClient.close();\n    }\n  }\n  public void printInfo() throws IOException {\n    ClientInfo info = ClientInfo.from(accumuloClient.properties());\n    reader.print(\"\\n\" + SHELL_DESCRIPTION + \"\\n\" + \"- \\n\" + \"- version: \" + Constants.VERSION + \"\\n\"\n        + \"- instance name: \" + info.getInstanceName() + \"\\n\" + \"- instance id: \"\n        + accumuloClient.instanceOperations().getInstanceID() + \"\\n\" + \"- \\n\"\n        + \"- type 'help' for a list of available commands\\n\" + \"- \\n\");\n    reader.flush();\n  }\n  public void printVerboseInfo() throws IOException {\n    StringBuilder sb = new StringBuilder(\"-\\n\");\n    sb.append(\"- Current user: \").append(accumuloClient.whoami()).append(\"\\n\");\n    if (execFile != null)\n      sb.append(\"- Executing commands from: \").append(execFile).append(\"\\n\");\n    if (disableAuthTimeout)\n      sb.append(\"- Authorization timeout: disabled\\n\");\n    else\n      sb.append(\"- Authorization timeout: \")\n          .append(String.format(\"%ds%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n    sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n    if (!scanIteratorOptions.isEmpty()) {\n      for (Entry<String,List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n        sb.append(\"- Session scan iterators for table \").append(entry.getKey()).append(\":\\n\");\n        for (IteratorSetting setting : entry.getValue()) {\n          sb.append(\"-    Iterator \").append(setting.getName()).append(\" options:\\n\");\n          sb.append(\"-        \").append(\"iteratorPriority\").append(\" = \")\n              .append(setting.getPriority()).append(\"\\n\");\n          sb.append(\"-        \").append(\"iteratorClassName\").append(\" = \")\n              .append(setting.getIteratorClass()).append(\"\\n\");\n          for (Entry<String,String> optEntry : setting.getOptions().entrySet()) {\n            sb.append(\"-        \").append(optEntry.getKey()).append(\" = \")\n                .append(optEntry.getValue()).append(\"\\n\");\n          }\n        }\n      }\n    }\n    sb.append(\"-\\n\");\n    reader.print(sb.toString());\n  }\n<fim_suffix>  public String getDefaultPrompt() {\n    Objects.requireNonNull(accumuloClient);\n    ClientInfo info = ClientInfo.from(accumuloClient.properties());\n    return accumuloClient.whoami() + \"@\" + info.getInstanceName()\n        + (getTableName().isEmpty() ? \"\" : \" \") + getTableName() + \"> \";\n  }<fim_middle>// function below has no smell\n"}