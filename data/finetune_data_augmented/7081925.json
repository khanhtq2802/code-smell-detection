{"text": "<fim_prefix>                }\n            }\n        } else {\n            for (int i = to - 1; i >= from; i--) {\n                if (o.equals(data[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    static int indexOf(Object o, Object[] data, int from, int to) {\n        if (o == null) {\n            for (int i = from; i < to; i++) {\n                if (data[i] == null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i = from; i < to; i++) {\n                if (o.equals(data[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    final Object[] getArray() {\n        // CopyOnWriteArraySet needs this.\n        return elements;\n    }\n    /**\n     * The sub list is thread safe and supports non-blocking reads. Doing so is\n     * more difficult than in the full list, because each read needs to examine\n     * four fields worth of state:\n     *  - the elements array of the full list\n     *  - two integers for the bounds of this sub list\n     *  - the expected elements array (to detect concurrent modification)\n     *\n     * This is accomplished by aggregating the sub list's three fields into a\n     * single snapshot object representing the current slice. This permits reads\n     * to be internally consistent without synchronization. This takes advantage\n     * of Java's concurrency semantics for final fields.\n     */\n<fim_suffix>    class CowSubList extends AbstractList<E> {\n        /*\n         * An immutable snapshot of a sub list's state. By gathering all three\n         * of the sub list's fields in an immutable object,\n         */\n        private volatile Slice slice;\n        public CowSubList(Object[] expectedElements, int from, int to) {\n            this.slice = new Slice(expectedElements, from, to);\n        }\n        @Override public int size() {\n            Slice slice = this.slice;\n            return slice.to - slice.from;\n        }\n        @Override public boolean isEmpty() {\n            Slice slice = this.slice;\n            return slice.from == slice.to;\n        }\n        @SuppressWarnings(\"unchecked\")\n        @Override public E get(int index) {\n            Slice slice = this.slice;\n            Object[] snapshot = elements;\n            slice.checkElementIndex(index);\n            slice.checkConcurrentModification(snapshot);\n            return (E) snapshot[index + slice.from];\n        }\n        @Override public Iterator<E> iterator() {\n            return listIterator(0);\n        }\n        @Override public ListIterator<E> listIterator() {\n            return listIterator(0);\n        }\n        @Override public ListIterator<E> listIterator(int index) {\n            Slice slice = this.slice;\n            Object[] snapshot = elements;\n            slice.checkPositionIndex(index);\n            slice.checkConcurrentModification(snapshot);\n            CowIterator<E> result = new CowIterator<E>(snapshot, slice.from, slice.to);\n            result.index = slice.from + index;\n            return result;\n        }\n        @Override public int indexOf(Object object) {\n            Slice slice = this.slice;\n            Object[] snapshot = elements;\n            slice.checkConcurrentModification(snapshot);\n            int result = CopyOnWriteArrayList.indexOf(object, snapshot, slice.from, slice.to);\n            return (result != -1) ? (result - slice.from) : -1;\n        }\n        @Override public int lastIndexOf(Object object) {\n            Slice slice = this.slice;\n            Object[] snapshot = elements;\n            slice.checkConcurrentModification(snapshot);\n            int result = CopyOnWriteArrayList.lastIndexOf(object, snapshot, slice.from, slice.to);\n            return (result != -1) ? (result - slice.from) : -1;\n        }\n        @Override public boolean contains(Object object) {\n            return indexOf(object) != -1;\n        }\n        @Override public boolean containsAll(Collection<?> collection) {\n            Slice slice = this.slice;\n            Object[] snapshot = elements;\n            slice.checkConcurrentModification(snapshot);\n            return CopyOnWriteArrayList.containsAll(collection, snapshot, slice.from, slice.to);\n        }\n        @Override public List<E> subList(int from, int to) {\n            Slice slice = this.slice;\n            if (from < 0 || from > to || to > size()) {\n                throw new IndexOutOfBoundsException(\"from=\" + from + \", to=\" + to +\n                        \", list size=\" + size());\n            }\n            return new CowSubList(slice.expectedElements, slice.from + from, slice.from + to);\n        }\n        @Override public E remove(int index) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkElementIndex(index);\n                slice.checkConcurrentModification(elements);\n                E removed = CopyOnWriteArrayList.this.remove(slice.from + index);\n                slice = new Slice(elements, slice.from, slice.to - 1);\n                return removed;\n            }\n        }\n        @Override public void clear() {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkConcurrentModification(elements);\n                CopyOnWriteArrayList.this.removeRange(slice.from, slice.to);\n                slice = new Slice(elements, slice.from, slice.from);\n            }\n        }\n        @Override public void add(int index, E object) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkPositionIndex(index);\n                slice.checkConcurrentModification(elements);\n                CopyOnWriteArrayList.this.add(index + slice.from, object);\n                slice = new Slice(elements, slice.from, slice.to + 1);\n            }\n        }\n        @Override public boolean add(E object) {\n            synchronized (CopyOnWriteArrayList.this) {\n                add(slice.to - slice.from, object);\n                return true;\n            }\n        }\n        @Override public boolean addAll(int index, Collection<? extends E> collection) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkPositionIndex(index);\n                slice.checkConcurrentModification(elements);\n                int oldSize = elements.length;\n                boolean result = CopyOnWriteArrayList.this.addAll(index + slice.from, collection);\n                slice = new Slice(elements, slice.from, slice.to + (elements.length - oldSize));\n                return result;\n            }\n        }\n        @Override public boolean addAll(Collection<? extends E> collection) {\n            synchronized (CopyOnWriteArrayList.this) {\n                return addAll(size(), collection);\n            }\n        }\n        @Override public E set(int index, E object) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkElementIndex(index);\n                slice.checkConcurrentModification(elements);\n                E result = CopyOnWriteArrayList.this.set(index + slice.from, object);\n                slice = new Slice(elements, slice.from, slice.to);\n                return result;\n            }\n        }\n        @Override public boolean remove(Object object) {\n            synchronized (CopyOnWriteArrayList.this) {\n                int index = indexOf(object);\n                if (index == -1) {\n                    return false;\n                }\n                remove(index);\n                return true;\n            }\n        }\n        @Override public boolean removeAll(Collection<?> collection) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkConcurrentModification(elements);\n                int removed = removeOrRetain(collection, false, slice.from, slice.to);\n                slice = new Slice(elements, slice.from, slice.to - removed);\n                return removed != 0;\n            }\n        }\n        @Override public boolean retainAll(Collection<?> collection) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkConcurrentModification(elements);\n                int removed = removeOrRetain(collection, true, slice.from, slice.to);\n                slice = new Slice(elements, slice.from, slice.to - removed);\n                return removed != 0;\n            }\n        }\n        @Override\n        public void forEach(Consumer<? super E> action) {\n            CopyOnWriteArrayList.this.forInRange(slice.from, slice.to, action);\n        }\n        @Override\n        public void replaceAll(UnaryOperator<E> operator) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkConcurrentModification(elements);\n                CopyOnWriteArrayList.this.replaceInRange(slice.from, slice.to, operator);\n                slice = new Slice(elements, slice.from, slice.to);\n            }\n        }\n        @Override\n        public synchronized void sort(Comparator<? super E> c) {\n            synchronized (CopyOnWriteArrayList.this) {\n                slice.checkConcurrentModification(elements);\n                CopyOnWriteArrayList.this.sortInRange(slice.from, slice.to, c);\n                slice = new Slice(elements, slice.from, slice.to);\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}