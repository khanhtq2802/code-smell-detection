{"text": "<fim_prefix>      return this;\n    }\n    /**\n     * Builds the {@link BM25FQuery}.\n     */\n    public BM25FQuery build() {\n      int size = fieldAndWeights.size() * termsSet.size();\n      if (size > BooleanQuery.getMaxClauseCount()) {\n        throw new BooleanQuery.TooManyClauses();\n      }\n      BytesRef[] terms = termsSet.toArray(new BytesRef[0]);\n      return new BM25FQuery(similarity, new TreeMap<>(fieldAndWeights), terms);\n    }\n  }\n  static class FieldAndWeight {\n    final String field;\n    final float weight;\n    FieldAndWeight(String field, float weight) {\n      this.field = field;\n      this.weight = weight;\n    }\n  }\n  // the similarity to use for scoring.\n  private final BM25Similarity similarity;\n  // sorted map for fields.\n  private final TreeMap<String, FieldAndWeight> fieldAndWeights;\n  // array of terms, sorted.\n  private final BytesRef terms[];\n  // array of terms per field, sorted\n  private final Term fieldTerms[];\n  private BM25FQuery(BM25Similarity similarity, TreeMap<String, FieldAndWeight> fieldAndWeights, BytesRef[] terms) {\n    this.similarity = similarity;\n    this.fieldAndWeights = fieldAndWeights;\n    this.terms = terms;\n    int numFieldTerms = fieldAndWeights.size() * terms.length;\n    if (numFieldTerms > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    this.fieldTerms = new Term[numFieldTerms];\n    Arrays.sort(terms);\n    int pos = 0;\n    for (String field : fieldAndWeights.keySet()) {\n      for (BytesRef term : terms) {\n        fieldTerms[pos++] = new Term(field, term);\n      }\n    }\n  }\n  public List<Term> getTerms() {\n    return Collections.unmodifiableList(Arrays.asList(fieldTerms));\n  }\n  @Override\n  public String toString(String field) {\n    StringBuilder builder = new StringBuilder(\"BM25F((\");\n    int pos = 0;\n    for (FieldAndWeight fieldWeight : fieldAndWeights.values()) {\n      if (pos++ != 0) {\n        builder.append(\" \");\n      }\n      builder.append(fieldWeight.field);\n      if (fieldWeight.weight != 1f) {\n        builder.append(\"^\");\n        builder.append(fieldWeight.weight);\n      }\n    }\n    builder.append(\")(\");\n    pos = 0;\n    for (BytesRef term : terms) {\n      if (pos++ != 0) {\n        builder.append(\" \");\n      }\n      builder.append(term.utf8ToString());\n    }\n    builder.append(\"))\");\n    return builder.toString();\n  }\n  @Override\n  public int hashCode() {\n    return 31 * classHash() + Arrays.hashCode(terms);\n  }\n  @Override\n  public boolean equals(Object other) {\n    return sameClassAs(other) &&\n        Arrays.equals(terms, ((BM25FQuery) other).terms);\n  }\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    // optimize zero and single field cases\n    if (terms.length == 0) {\n      return new BooleanQuery.Builder().build();\n    }\n    // single field and one term\n    if (fieldTerms.length == 1) {\n      return new TermQuery(fieldTerms[0]);\n    }\n    // single field and multiple terms\n    if (fieldAndWeights.size() == 1) {\n      SynonymQuery.Builder builder = new SynonymQuery.Builder(fieldTerms[0].field());\n      for (Term term : fieldTerms) {\n        builder.addTerm(term);\n      }\n      return builder.build();\n    }\n    return this;\n  }\n  @Override\n  public void visit(QueryVisitor visitor) {\n    Term[] selectedTerms = Arrays.stream(fieldTerms).filter(t -> visitor.acceptField(t.field())).toArray(Term[]::new);\n    if (selectedTerms.length > 0) {\n      QueryVisitor v = visitor.getSubVisitor(BooleanClause.Occur.SHOULD, this);\n      v.consumeTerms(this, selectedTerms);\n    }\n  }\n  private BooleanQuery rewriteToBoolean() {\n    // rewrite to a simple disjunction if the score is not needed.\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Term term : fieldTerms) {\n      bq.add(new TermQuery(term), BooleanClause.Occur.SHOULD);\n    }\n    return bq.build();\n  }\n  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    if (scoreMode.needsScores()) {\n      return new BM25FWeight(this, searcher, scoreMode, boost);\n    } else {\n      // rewrite to a simple disjunction if the score is not needed.\n      Query bq = rewriteToBoolean();\n      return searcher.rewrite(bq).createWeight(searcher, ScoreMode.COMPLETE_NO_SCORES, boost);\n    }\n  }\n  class BM25FWeight extends Weight {\n    private final IndexSearcher searcher;\n    private final TermStates termStates[];\n    private final Similarity.SimScorer simWeight;\n    BM25FWeight(Query query, IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n      super(query);\n      assert scoreMode.needsScores();\n      this.searcher = searcher;\n      long docFreq = 0;\n      long totalTermFreq = 0;\n      termStates = new TermStates[fieldTerms.length];\n      for (int i = 0; i < termStates.length; i++) {\n        FieldAndWeight field = fieldAndWeights.get(fieldTerms[i].field());\n        termStates[i] = TermStates.build(searcher.getTopReaderContext(), fieldTerms[i], true);\n        TermStatistics termStats = searcher.termStatistics(fieldTerms[i], termStates[i]);\n        if (termStats != null) {\n          docFreq = Math.max(termStats.docFreq(), docFreq);\n          totalTermFreq += (double) field.weight * termStats.totalTermFreq();\n        }\n      }\n      if (docFreq > 0) {\n        CollectionStatistics pseudoCollectionStats = mergeCollectionStatistics(searcher);\n        TermStatistics pseudoTermStatistics = new TermStatistics(new BytesRef(\"pseudo_term\"), docFreq, Math.max(1, totalTermFreq));\n        this.simWeight = similarity.scorer(boost, pseudoCollectionStats, pseudoTermStatistics);\n      } else {\n        this.simWeight = null;\n      }\n    }\n    private CollectionStatistics mergeCollectionStatistics(IndexSearcher searcher) throws IOException {\n      long maxDoc = searcher.getIndexReader().maxDoc();\n      long docCount = 0;\n      long sumTotalTermFreq = 0;\n      long sumDocFreq = 0;\n      for (FieldAndWeight fieldWeight : fieldAndWeights.values()) {\n        CollectionStatistics collectionStats = searcher.collectionStatistics(fieldWeight.field);\n        if (collectionStats != null) {\n          docCount = Math.max(collectionStats.docCount(), docCount);\n          sumDocFreq = Math.max(collectionStats.sumDocFreq(), sumDocFreq);\n          sumTotalTermFreq += (double) fieldWeight.weight * collectionStats.sumTotalTermFreq();\n        }\n      }\n      return new CollectionStatistics(\"pseudo_field\", maxDoc, docCount, sumTotalTermFreq, sumDocFreq);\n    }\n    @Override\n    public Matches matches(LeafReaderContext context, int doc) throws IOException {\n      Weight weight = searcher.rewrite(rewriteToBoolean()).createWeight(searcher, ScoreMode.COMPLETE, 1f);\n      return weight.matches(context, doc);\n    }\n<fim_suffix>    @Override\n    public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n      Scorer scorer = scorer(context);\n      if (scorer != null) {\n        int newDoc = scorer.iterator().advance(doc);\n        if (newDoc == doc) {\n          final float freq;\n          if (scorer instanceof BM25FScorer) {\n            freq = ((BM25FScorer) scorer).freq();\n          } else {\n            assert scorer instanceof TermScorer;\n            freq = ((TermScorer) scorer).freq();\n          }\n          final MultiNormsLeafSimScorer docScorer =\n              new MultiNormsLeafSimScorer(simWeight, context.reader(), fieldAndWeights.values(), true);\n          Explanation freqExplanation = Explanation.match(freq, \"termFreq=\" + freq);\n          Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);\n          return Explanation.match(\n              scoreExplanation.getValue(),\n              \"weight(\" + getQuery() + \" in \" + doc + \") [\"\n                  + similarity.getClass().getSimpleName() + \"], result of:\",\n              scoreExplanation);\n        }\n      }\n      return Explanation.noMatch(\"no matching term\");\n    }<fim_middle>// function below is long method\n"}