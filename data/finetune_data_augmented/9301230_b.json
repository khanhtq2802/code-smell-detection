{"text": "<fim_prefix>            fetchValues();\n            return params;\n        }\n        public String toString() {\n            fetchValues();\n            return super.toString() +  \"\\n  y: \" + y + \"\\n  p: \" + params.getP()\n                + \"\\n  g: \" + params.getG();\n        }\n        public int hashCode() {\n            if (token.isValid() == false) {\n                return 0;\n            }\n            fetchValues();\n            return Objects.hash(y, params.getP(), params.getG());\n        }\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            // equals() should never throw exceptions\n            if (token.isValid() == false) {\n                return false;\n            }\n            if (!(obj instanceof DHPublicKey)) {\n                return false;\n            }\n            fetchValues();\n            DHPublicKey other = (DHPublicKey) obj;\n            DHParameterSpec otherParams = other.getParams();\n            return ((this.y.compareTo(other.getY()) == 0) &&\n                    (this.params.getP().compareTo(otherParams.getP()) == 0) &&\n                    (this.params.getG().compareTo(otherParams.getG()) == 0));\n        }\n    }\n    private static final class P11ECPrivateKey extends P11Key\n                                                implements ECPrivateKey {\n        private static final long serialVersionUID = -7786054399510515515L;\n        private BigInteger s;\n        private ECParameterSpec params;\n        private byte[] encoded;\n        P11ECPrivateKey(Session session, long keyID, String algorithm,\n                int keyLength, CK_ATTRIBUTE[] attributes) {\n            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n        }\n        private synchronized void fetchValues() {\n            token.ensureValid();\n            if (s != null) {\n                return;\n            }\n            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n                new CK_ATTRIBUTE(CKA_VALUE),\n                new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n            };\n            fetchAttributes(attributes);\n            s = attributes[0].getBigInteger();\n            try {\n                params = P11ECKeyFactory.decodeParameters\n                            (attributes[1].getByteArray());\n            } catch (Exception e) {\n                throw new RuntimeException(\"Could not parse key values\", e);\n            }\n        }\n        public String getFormat() {\n            token.ensureValid();\n            return \"PKCS#8\";\n        }\n        synchronized byte[] getEncodedInternal() {\n            token.ensureValid();\n            if (encoded == null) {\n                fetchValues();\n                try {\n                    Key key = ECUtil.generateECPrivateKey(s, params);\n                    encoded = key.getEncoded();\n                } catch (InvalidKeySpecException e) {\n                    throw new ProviderException(e);\n                }\n            }\n            return encoded;\n        }\n        public BigInteger getS() {\n            fetchValues();\n            return s;\n        }\n        public ECParameterSpec getParams() {\n            fetchValues();\n            return params;\n        }\n    }\n    private static final class P11ECPublicKey extends P11Key\n                                                implements ECPublicKey {\n        private static final long serialVersionUID = -6371481375154806089L;\n        private ECPoint w;\n        private ECParameterSpec params;\n        private byte[] encoded;\n        P11ECPublicKey(Session session, long keyID, String algorithm,\n                int keyLength, CK_ATTRIBUTE[] attributes) {\n            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n        }\n        private synchronized void fetchValues() {\n            token.ensureValid();\n            if (w != null) {\n                return;\n            }\n            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n                new CK_ATTRIBUTE(CKA_EC_POINT),\n                new CK_ATTRIBUTE(CKA_EC_PARAMS),\n            };\n            fetchAttributes(attributes);\n            try {\n                params = P11ECKeyFactory.decodeParameters\n                            (attributes[1].getByteArray());\n                byte[] ecKey = attributes[0].getByteArray();\n                // Check whether the X9.63 encoding of an EC point is wrapped\n                // in an ASN.1 OCTET STRING\n                if (!token.config.getUseEcX963Encoding()) {\n                    DerValue wECPoint = new DerValue(ecKey);\n                    if (wECPoint.getTag() != DerValue.tag_OctetString) {\n                        throw new IOException(\"Could not DER decode EC point.\" +\n                            \" Unexpected tag: \" + wECPoint.getTag());\n                    }\n                    w = P11ECKeyFactory.decodePoint\n                        (wECPoint.getDataBytes(), params.getCurve());\n                } else {\n                    w = P11ECKeyFactory.decodePoint(ecKey, params.getCurve());\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(\"Could not parse key values\", e);\n            }\n        }\n        public String getFormat() {\n            token.ensureValid();\n            return \"X.509\";\n        }\n        synchronized byte[] getEncodedInternal() {\n            token.ensureValid();\n            if (encoded == null) {\n                fetchValues();\n                try {\n                    return ECUtil.x509EncodeECPublicKey(w, params);\n                } catch (InvalidKeySpecException e) {\n                    throw new ProviderException(e);\n                }\n            }\n            return encoded;\n        }\n        public ECPoint getW() {\n            fetchValues();\n            return w;\n        }\n        public ECParameterSpec getParams() {\n            fetchValues();\n            return params;\n        }\n        public String toString() {\n            fetchValues();\n            return super.toString()\n                + \"\\n  public x coord: \" + w.getAffineX()\n                + \"\\n  public y coord: \" + w.getAffineY()\n                + \"\\n  parameters: \" + params;\n        }\n    }\n}\nfinal class NativeKeyHolder {\n    private static long nativeKeyWrapperKeyID = 0;\n    private static CK_MECHANISM nativeKeyWrapperMechanism = null;\n    private final P11Key p11Key;\n    private final byte[] nativeKeyInfo;\n    // destroyed and recreated when refCount toggles to 1\n    private long keyID;\n    private boolean isTokenObject;\n    // phantom reference notification clean up for session keys\n    private SessionKeyRef ref;\n    private int refCount;\n<fim_suffix>    NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,\n            boolean extractKeyInfo, boolean isTokenObject) {\n        this.p11Key = p11Key;\n        this.keyID = keyID;\n        this.refCount = -1;\n        byte[] ki = null;\n        if (isTokenObject) {\n            this.ref = null;\n        } else {\n            this.ref = new SessionKeyRef(p11Key, keyID, keySession);\n            // Try extracting key info, if any error, disable it\n            Token token = p11Key.token;\n            if (extractKeyInfo) {\n                try {\n                    if (p11Key.sensitive && nativeKeyWrapperKeyID == 0) {\n                        synchronized(NativeKeyHolder.class) {\n                            // Create a global wrapping/unwrapping key\n                            CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes\n                                (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {\n                                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n                                    new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 >> 3),\n                                });\n                            Session wrappingSession = null;\n                            try {\n                                wrappingSession = token.getObjSession();\n                                nativeKeyWrapperKeyID = token.p11.C_GenerateKey\n                                    (wrappingSession.id(),\n                                    new CK_MECHANISM(CKM_AES_KEY_GEN),\n                                    wrappingAttributes);\n                                byte[] iv = new byte[16];\n                                JCAUtil.getSecureRandom().nextBytes(iv);\n                                nativeKeyWrapperMechanism = new CK_MECHANISM\n                                    (CKM_AES_CBC_PAD, iv);\n                            } catch (PKCS11Exception e) {\n                                // best effort\n                            } finally {\n                                token.releaseSession(wrappingSession);\n                            }\n                        }\n                    }\n                    Session opSession = null;\n                    try {\n                        opSession = token.getOpSession();\n                        ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),\n                            keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);\n                    } catch (PKCS11Exception e) {\n                        // best effort\n                    } finally {\n                        token.releaseSession(opSession);\n                    }\n                } catch (PKCS11Exception e) {\n                    // best effort\n                }\n            }\n        }\n        this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);\n    }<fim_middle>// function below is long method and feature envy\n"}