{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.webdav.version.report;\n\nimport org.apache.jackrabbit.webdav.DavException;\nimport org.apache.jackrabbit.webdav.DavServletResponse;\nimport org.apache.jackrabbit.webdav.version.DeltaVConstants;\nimport org.apache.jackrabbit.webdav.version.DeltaVResource;\nimport org.apache.jackrabbit.webdav.xml.DomUtil;\nimport org.apache.jackrabbit.webdav.xml.Namespace;\nimport org.apache.jackrabbit.webdav.xml.XmlSerializable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\nimport java.util.HashMap;\n\n/**\n * <code>ReportType</code>...\n */\n<fim_suffix>public class ReportType implements DeltaVConstants, XmlSerializable {\n\n    private static Logger log = LoggerFactory.getLogger(ReportType.class);\n\n    private static final HashMap<String, ReportType> types = new HashMap<String, ReportType>();\n\n    public static final ReportType VERSION_TREE = register(XML_VERSION_TREE, NAMESPACE, VersionTreeReport.class);\n    public static final ReportType EXPAND_PROPERTY = register(XML_EXPAND_PROPERTY, NAMESPACE, ExpandPropertyReport.class);\n    public static final ReportType LOCATE_BY_HISTORY = register(XML_LOCATE_BY_HISTORY, NAMESPACE, LocateByHistoryReport.class);\n\n    private final String key;\n    private final String localName;\n    private final Namespace namespace;\n    private final Class<? extends Report> reportClass;\n\n    /**\n     * Private constructor\n     *\n     * @see ReportType#register(String, org.apache.jackrabbit.webdav.xml.Namespace, Class)\n     */\n    private ReportType(String localName, Namespace namespace, String key, Class<? extends Report> reportClass) {\n        this.localName = localName;\n        this.namespace = namespace;\n        this.key = key;\n        this.reportClass = reportClass;\n    }\n\n    /**\n     * Creates a new {@link Report} with this type.\n     *\n     * @return\n     * @throws DavException\n     */\n    public Report createReport(DeltaVResource resource, ReportInfo info) throws DavException {\n        try {\n            Report report = reportClass.newInstance();\n            report.init(resource, info);\n            return report;\n        } catch (IllegalAccessException e) {\n            // should never occur\n            throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to create new report (\" + reportClass.getName() + \") from class: \" + e.getMessage());\n        } catch (InstantiationException e) {\n            // should never occur\n            throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to create new report (\" + reportClass.getName() + \") from class: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns an Xml element representing this report type. It may be used to\n     * build the body for a REPORT request.\n     *\n     * @param document\n     * @return Xml representation\n     * @see XmlSerializable#toXml(org.w3c.dom.Document)\n     */\n    public Element toXml(Document document) {\n        return DomUtil.createElement(document, localName, namespace);\n    }\n\n    /**\n     * Returns true if this <code>ReportType</code> is requested by the given\n     * <code>ReportInfo</code>\n     *\n     * @param reqInfo\n     * @return\n     */\n    public boolean isRequestedReportType(ReportInfo reqInfo) {\n        if (reqInfo != null) {\n            return getReportName().equals(reqInfo.getReportName());\n        }\n        return false;\n    }\n\n    /**\n     * Return the qualified name of this <code>ReportType</code>.\n     *\n     * @return qualified name\n     */\n    public String getReportName() {\n        return key;\n    }\n\n    /**\n     *\n     * @return\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     *\n     * @return\n     */\n    public Namespace getNamespace() {\n        return namespace;\n    }\n\n    /**\n     * Register the report type with the given name, namespace and class, that can\n     * run that report.\n     *\n     * @param localName\n     * @param namespace\n     * @param reportClass\n     * @return\n     * @throws IllegalArgumentException if either parameter is <code>null</code> or\n     * if the given class does not implement the {@link Report} interface or if\n     * it does not provide an empty constructor.\n     */\n    public static ReportType register(String localName, Namespace namespace, Class<? extends Report> reportClass) {\n        if (localName == null || namespace == null || reportClass == null) {\n            throw new IllegalArgumentException(\"A ReportType cannot be registered with a null name, namespace or report class\");\n        }\n        String key = DomUtil.getExpandedName(localName, namespace);\n        if (types.containsKey(key)) {\n            return types.get(key);\n        } else {\n            try {\n                Object report =  reportClass.newInstance();\n                if (!(report instanceof Report)) {\n                    throw new IllegalArgumentException(\"Unable to register Report class: \" + reportClass + \" does not implement the Report interface.\");\n                }\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Error while validating Report class: \" + e.getMessage());\n            } catch (InstantiationException e) {\n                throw new IllegalArgumentException(\"Error while validating Report class.: \" + e.getMessage());\n            }\n\n            ReportType type = new ReportType(localName, namespace, key, reportClass);\n            types.put(key, type);\n            return type;\n        }\n    }\n\n    /**\n     * Return the <code>ReportType</code> requested by the given report info object.\n     *\n     * @param reportInfo\n     * @return the requested <code>ReportType</code>\n     * @throws IllegalArgumentException if the reportInfo is <code>null</code> or\n     * if the requested report type has not been registered yet.\n     */\n    public static ReportType getType(ReportInfo reportInfo) {\n        if (reportInfo == null) {\n            throw new IllegalArgumentException(\"ReportInfo must not be null.\");\n        }\n        String key = reportInfo.getReportName();\n        if (types.containsKey(key)) {\n            return types.get(key);\n        } else {\n            throw new IllegalArgumentException(\"The request report '\"+key+\"' has not been registered yet.\");\n        }\n    }\n}<fim_middle>// class below has no smell\n"}