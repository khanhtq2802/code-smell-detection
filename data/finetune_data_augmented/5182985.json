{"text": "<fim_prefix>                    boolean existing = existsImpl(resPath);\n                    if (existing) {\n                        pstat = connection.prepareStatement(sqls.getReplaceSql());\n                        pstat.setLong(1, ts);\n                        pstat.setBlob(2, new BufferedInputStream(new ByteArrayInputStream(bytes)));\n                        pstat.setString(3, resPath);\n                    } else {\n                        pstat = connection.prepareStatement(sqls.getInsertSql());\n                        pstat.setString(1, resPath);\n                        pstat.setLong(2, ts);\n                        pstat.setBlob(3, new BufferedInputStream(new ByteArrayInputStream(bytes)));\n                    }\n                    if (isContentOverflow(bytes, resPath)) {\n                        logger.debug(\"Overflow! resource path: {}, content size: {}, timeStamp: {}\", resPath,\n                                bytes.length, ts);\n                        if (existing) {\n                            pstat.setNull(2, Types.BLOB);\n                        } else {\n                            pstat.setNull(3, Types.BLOB);\n                        }\n                        RollbackablePushdown pushdown = writePushdown(resPath, ContentWriter.create(bytes));\n                        try {\n                            int result = pstat.executeUpdate();\n                            if (result != 1)\n                                throw new SQLException();\n                        } catch (Exception e) {\n                            pushdown.rollback();\n                            throw e;\n                        } finally {\n                            pushdown.close();\n                        }\n                    } else {\n                        pstat.executeUpdate();\n                    }\n                }\n            }\n        });\n    }\n    private boolean isContentOverflow(byte[] content, String resPath) throws SQLException {\n        if (kylinConfig.isJsonAlwaysSmallCell() && isJsonMetadata(resPath)) {\n            int smallCellMetadataWarningThreshold = kylinConfig.getSmallCellMetadataWarningThreshold();\n            int smallCellMetadataErrorThreshold = kylinConfig.getSmallCellMetadataErrorThreshold();\n            if (content.length > smallCellMetadataWarningThreshold) {\n                logger.warn(\n                        \"A JSON metadata entry's size is not supposed to exceed kap.metadata.jdbc.small-cell-meta-size-warning-threshold({}), resPath: {}, actual size: {}\",\n                        smallCellMetadataWarningThreshold, resPath, content.length);\n            }\n            if (content.length > smallCellMetadataErrorThreshold) {\n                throw new SQLException(new IllegalArgumentException(\n                        \"A JSON metadata entry's size is not supposed to exceed kap.metadata.jdbc.small-cell-meta-size-error-threshold(\"\n                                + smallCellMetadataErrorThreshold + \"), resPath: \" + resPath + \", actual size: \"\n                                + content.length));\n            }\n            return false;\n        }\n        int maxSize = kylinConfig.getJdbcResourceStoreMaxCellSize();\n        if (content.length > maxSize)\n            return true;\n        else\n            return false;\n    }\n    @Override\n    protected long checkAndPutResourceImpl(String resPath, byte[] content, long oldTS, long newTS)\n            throws IOException, WriteConflictException {\n        try {\n            checkAndPutResourceInternal(resPath, content, oldTS, newTS);\n            return newTS;\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n    }\n    void checkAndPutResourceInternal(final String resPath, final byte[] content, final long oldTS, final long newTS)\n            throws SQLException, IOException, WriteConflictException {\n        logger.trace(\n                \"execute checkAndPutResource method. resPath : {} , oldTs : {} , newTs : {} , content null ? : {} \",\n                resPath, oldTS, newTS, content == null);\n        executeSql(new SqlOperation() {\n            @Override\n            public void execute(Connection connection) throws SQLException, IOException {\n                synchronized (resPath.intern()) {\n                    JDBCResourceSQL sqls = getJDBCResourceSQL(getMetaTableName(resPath));\n                    if (!existsImpl(resPath)) {\n                        if (oldTS != 0) {\n                            throw new IllegalStateException(\n                                    \"For not exist file. OldTS have to be 0. but Actual oldTS is : \" + oldTS);\n                        }\n                        if (isContentOverflow(content, resPath)) {\n                            logger.debug(\"Overflow! resource path: {}, content size: {}\", resPath, content.length);\n                            pstat = connection.prepareStatement(sqls.getInsertSqlWithoutContent());\n                            pstat.setString(1, resPath);\n                            pstat.setLong(2, newTS);\n                            RollbackablePushdown pushdown = writePushdown(resPath, ContentWriter.create(content));\n                            try {\n                                int result = pstat.executeUpdate();\n                                if (result != 1)\n                                    throw new SQLException();\n                            } catch (Exception e) {\n                                pushdown.rollback();\n                                throw e;\n                            } finally {\n                                pushdown.close();\n                            }\n                        } else {\n                            pstat = connection.prepareStatement(sqls.getInsertSql());\n                            pstat.setString(1, resPath);\n                            pstat.setLong(2, newTS);\n                            pstat.setBlob(3, new BufferedInputStream(new ByteArrayInputStream(content)));\n                            pstat.executeUpdate();\n                        }\n                    } else {\n                        // Note the checkAndPut trick:\n                        // update {0} set {1}=? where {2}=? and {3}=?\n                        pstat = connection.prepareStatement(sqls.getUpdateSqlWithoutContent());\n                        pstat.setLong(1, newTS);\n                        pstat.setString(2, resPath);\n                        pstat.setLong(3, oldTS);\n                        int result = pstat.executeUpdate();\n                        if (result != 1) {\n                            long realTime = getResourceTimestamp(resPath);\n                            throw new WriteConflictException(\"Overwriting conflict \" + resPath + \", expect old TS \"\n                                    + oldTS + \", but it is \" + realTime);\n                        }\n                        PreparedStatement pstat2 = null;\n                        try {\n                            // \"update {0} set {1}=? where {3}=?\"\n                            pstat2 = connection.prepareStatement(sqls.getUpdateContentSql());\n                            if (isContentOverflow(content, resPath)) {\n                                logger.debug(\"Overflow! resource path: {}, content size: {}\", resPath, content.length);\n                                pstat2.setNull(1, Types.BLOB);\n                                pstat2.setString(2, resPath);\n                                RollbackablePushdown pushdown = writePushdown(resPath, ContentWriter.create(content));\n                                try {\n                                    int result2 = pstat2.executeUpdate();\n                                    if (result2 != 1)\n                                        throw new SQLException();\n                                } catch (Exception e) {\n                                    pushdown.rollback();\n                                    throw e;\n                                } finally {\n                                    pushdown.close();\n                                }\n                            } else {\n                                pstat2.setBinaryStream(1,\n                                        new BufferedInputStream(new ByteArrayInputStream(content)));\n                                pstat2.setString(2, resPath);\n                                pstat2.executeUpdate();\n                            }\n                        } finally {\n                            JDBCConnectionManager.closeQuietly(pstat2);\n                        }\n                    }\n                }\n            }\n        });\n    }\n    @Override\n    protected void deleteResourceImpl(final String resPath) throws IOException {\n        try {\n            boolean skipHdfs = isJsonMetadata(resPath);\n            JDBCResourceSQL sqls = getJDBCResourceSQL(getMetaTableName(resPath));\n            executeSql(new SqlOperation() {\n                @Override\n                public void execute(Connection connection) throws SQLException {\n                    pstat = connection.prepareStatement(sqls.getDeletePstatSql());\n                    pstat.setString(1, resPath);\n                    pstat.executeUpdate();\n                }\n            });\n            if (!skipHdfs) {\n                try {\n                    deletePushdown(resPath);\n                } catch (Exception e) {\n                    throw new SQLException(e);\n                }\n            }\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n    }\n    @Override\n    protected String getReadableResourcePathImpl(String resPath) {\n        return metadataIdentifier + \"(key='\" + resPath + \"')@\" + kylinConfig.getMetadataUrl();\n    }\n    @Override\n    protected String pushdownRootPath() {\n        String metastoreBigCellHdfsDirectory = kylinConfig.getMetastoreBigCellHdfsDirectory();\n        if (metastoreBigCellHdfsDirectory.endsWith(\"/\"))\n            return metastoreBigCellHdfsDirectory + \"resources-jdbc\";\n        else\n            return metastoreBigCellHdfsDirectory + \"/\" + \"resources-jdbc\";\n    }\n    // visible for test\n    @Override\n    protected FileSystem pushdownFS() {\n        return super.pushdownFS();\n    }\n<fim_suffix>    @Override\n    protected boolean isUnreachableException(Throwable ex) {\n        if (super.isUnreachableException(ex)) {\n            return true;\n        }\n        if (ex instanceof SocketTimeoutException)\n            return true;\n        List<String> exceptionList = new ArrayList<>();\n        exceptionList.add(ex.getClass().getName());\n        Throwable t = ex.getCause();\n        int depth = 0;\n        while (t != null && depth < 5) {\n            exceptionList.add(t.getClass().getName());\n            depth++;\n            if (t instanceof ConnectException) {\n                return true;\n            }\n            t = t.getCause();\n        }\n        logger.trace(\"Not an unreachable exception with causes {}\", exceptionList);\n        return false;\n    }<fim_middle>// function below is long method\n"}