{"text": "<fim_prefix>  private static boolean isRemovalToken(final Object value) {\n    return value == Token.REMOVED_PHASE1 || value == Token.REMOVED_PHASE2\n        || value == Token.DESTROYED || value == Token.TOMBSTONE;\n  }\n  public static void appendNewRegisterInterestResponseChunkFromLocal(LocalRegion region,\n      VersionedObjectList values, Object riKeys, Set keySet, ServerConnection servConn)\n      throws IOException {\n    ClientProxyMembershipID requestingClient = servConn == null ? null : servConn.getProxyID();\n    for (Object key : keySet) {\n      VersionTagHolder versionHolder = createVersionTagHolder();\n      Object value = region.get(key, null, true, true, true, requestingClient, versionHolder, true);\n      updateValues(values, key, value, versionHolder.getVersionTag());\n      if (values.size() == MAXIMUM_CHUNK_SIZE) {\n        // Send the chunk and clear the list\n        // values.setKeys(null); // Now we need to send keys too.\n        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : \"ALL_KEYS\", values,\n            false, servConn);\n        values.clear();\n      }\n    } // for\n  }\n  public static void appendNewRegisterInterestResponseChunk(LocalRegion region,\n      VersionedObjectList values, Object riKeys, Set<Map.Entry> set, ServerConnection servConn)\n      throws IOException {\n    for (Entry entry : set) {\n      if (entry instanceof Region.Entry) { // local entries\n        VersionTag vt;\n        Object key;\n        Object value;\n        if (entry instanceof EntrySnapshot) {\n          vt = ((EntrySnapshot) entry).getVersionTag();\n          key = ((EntrySnapshot) entry).getRegionEntry().getKey();\n          value = ((EntrySnapshot) entry).getRegionEntry().getValue(null);\n          updateValues(values, key, value, vt);\n        } else {\n          VersionStamp vs = ((NonTXEntry) entry).getRegionEntry().getVersionStamp();\n          vt = vs == null ? null : vs.asVersionTag();\n          key = entry.getKey();\n          value = ((NonTXEntry) entry).getRegionEntry().getValueRetain(region, true);\n          try {\n            updateValues(values, key, value, vt);\n          } finally {\n            OffHeapHelper.release(value);\n          }\n        }\n      } else { // Map.Entry (remote entries)\n        List list = (List) entry.getValue();\n        Object value = list.get(0);\n        VersionTag tag = (VersionTag) list.get(1);\n        updateValues(values, entry.getKey(), value, tag);\n      }\n      if (values.size() == MAXIMUM_CHUNK_SIZE) {\n        // Send the chunk and clear the list\n        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : \"ALL_KEYS\", values,\n            false, servConn);\n        values.clear();\n      }\n    } // for\n  }\n  public static void sendNewRegisterInterestResponseChunk(LocalRegion region, Object riKey,\n      VersionedObjectList list, boolean lastChunk, ServerConnection servConn) throws IOException {\n    ChunkedMessage chunkedResponseMsg = servConn.getRegisterInterestResponseMessage();\n    chunkedResponseMsg.setNumberOfParts(1);\n    chunkedResponseMsg.setLastChunk(lastChunk);\n    chunkedResponseMsg.addObjPart(list, false);\n    String regionName = region == null ? \" null \" : region.getFullPath();\n    if (logger.isDebugEnabled()) {\n      logger.debug(\n          \"{}: Sending{}register interest response chunk for region: {} for keys: {} chunk=<{}>\",\n          servConn.getName(), lastChunk ? \" last \" : \" \", regionName, riKey, chunkedResponseMsg);\n    }\n    chunkedResponseMsg.sendChunk(servConn);\n  }\n  /**\n   * Process an interest request of type {@link InterestType#REGULAR_EXPRESSION}\n   */\n  private static void handleRegEx(LocalRegion region, String regex, InterestResultPolicy policy,\n      ServerConnection servConn) throws IOException {\n    if (region instanceof PartitionedRegion) {\n      // too bad java doesn't provide another way to do this...\n      handleRegExPR((PartitionedRegion) region, regex, policy, servConn);\n      return;\n    }\n    List keyList = new ArrayList(MAXIMUM_CHUNK_SIZE);\n    // Handle the regex pattern\n    if (region != null) {\n      Pattern keyPattern = Pattern.compile(regex);\n      for (Object entryKey : region.keySet(sendTombstonesInRIResults(servConn, policy))) {\n        if (!(entryKey instanceof String)) {\n          // key is not a String, cannot apply regex to this entry\n          continue;\n        }\n        if (!keyPattern.matcher((String) entryKey).matches()) {\n          // key does not match the regex, this entry should not be returned.\n          continue;\n        }\n        appendInterestResponseKey(region, regex, entryKey, keyList, servConn);\n      }\n    }\n    // Send the last chunk (the only chunk for individual and list keys)\n    // always send it back, even if the list is of zero size.\n    sendRegisterInterestResponseChunk(region, regex, keyList, true, servConn);\n  }\n  /**\n   * Process an interest request of type {@link InterestType#REGULAR_EXPRESSION}\n   */\n  private static void handleRegExPR(final PartitionedRegion region, final String regex,\n      final InterestResultPolicy policy, final ServerConnection servConn) throws IOException {\n    final List keyList = new ArrayList(MAXIMUM_CHUNK_SIZE);\n    region.getKeysWithRegEx(regex, sendTombstonesInRIResults(servConn, policy),\n        new PartitionedRegion.SetCollector() {\n          @Override\n          public void receiveSet(Set theSet) throws IOException {\n            appendInterestResponseKeys(region, regex, theSet, keyList, servConn);\n          }\n        });\n    // Send the last chunk (the only chunk for individual and list keys)\n    // always send it back, even if the list is of zero size.\n    sendRegisterInterestResponseChunk(region, regex, keyList, true, servConn);\n  }\n  /**\n   * Process an interest request involving a list of keys\n   */\n  private static void handleListPR(final PartitionedRegion region, final List keyList,\n      final InterestResultPolicy policy, final ServerConnection servConn) throws IOException {\n    final List newKeyList = new ArrayList(MAXIMUM_CHUNK_SIZE);\n    region.getKeysWithList(keyList, sendTombstonesInRIResults(servConn, policy),\n        new PartitionedRegion.SetCollector() {\n          @Override\n          public void receiveSet(Set theSet) throws IOException {\n            appendInterestResponseKeys(region, keyList, theSet, newKeyList, servConn);\n          }\n        });\n    // Send the last chunk (the only chunk for individual and list keys)\n    // always send it back, even if the list is of zero size.\n    sendRegisterInterestResponseChunk(region, keyList, newKeyList, true, servConn);\n  }\n  private static void handleKVList(final LocalRegion region, final List keyList,\n      boolean serializeValues, final ServerConnection servConn) throws IOException {\n    if (region instanceof PartitionedRegion) {\n      handleKVKeysPR((PartitionedRegion) region, keyList, serializeValues, servConn);\n      return;\n    }\n    VersionedObjectList values = new VersionedObjectList(MAXIMUM_CHUNK_SIZE, true,\n        region == null || region.getAttributes().getConcurrencyChecksEnabled(), serializeValues);\n    // Handle list of keys\n    if (region != null) {\n      for (Object key : keyList) {\n        if (region.containsKey(key) || region.containsTombstone(key)) {\n          VersionTagHolder versionHolder = createVersionTagHolder();\n          ClientProxyMembershipID id = servConn == null ? null : servConn.getProxyID();\n          Object data = region.get(key, null, true, true, true, id, versionHolder, true);\n          VersionTag versionTag = versionHolder.getVersionTag();\n          updateValues(values, key, data, versionTag);\n          if (values.size() == MAXIMUM_CHUNK_SIZE) {\n            // Send the chunk and clear the list\n            // values.setKeys(null); // Now we need to send keys too.\n            sendNewRegisterInterestResponseChunk(region, keyList, values, false, servConn);\n            values.clear();\n          }\n        }\n      }\n    }\n    // Send the last chunk (the only chunk for individual and list keys)\n    // always send it back, even if the list is of zero size.\n    sendNewRegisterInterestResponseChunk(region, keyList, values, true, servConn);\n  }\n<fim_suffix>  private static VersionTagHolder createVersionTagHolder() {\n    VersionTagHolder versionHolder = new VersionTagHolder();\n    versionHolder.setOperation(Operation.GET_FOR_REGISTER_INTEREST);\n    return versionHolder;\n  }<fim_middle>// function below has no smell\n"}