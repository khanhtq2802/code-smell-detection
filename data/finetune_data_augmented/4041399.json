{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam.sdk.extensions.euphoria.core.translate;\n\nimport javax.annotation.Nullable;\nimport org.apache.beam.sdk.extensions.euphoria.core.client.functional.UnaryFunction;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.values.KV;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.apache.beam.sdk.values.TypeDescriptors;\n\n/**\n * A transform for extracting stamp and applying a user-defined transform on the extracted\n * collection.\n *\n * @param <InputT> input type\n * @param <OutputT> output type\n */\npublic class TimestampExtractTransform<InputT, OutputT>\n    extends PTransform<PCollection<InputT>, PCollection<OutputT>> {\n\n  /**\n   * Create transformation working on KVs with timestamps as key.\n   *\n   * @param <InputT> type of input elements\n   * @param <OutputT> type of output elements\n   * @param transform the transform applied on elements with timestamp\n   * @return the transform\n   */\n  public static <InputT, OutputT> TimestampExtractTransform<InputT, OutputT> of(\n      PCollectionTransform<InputT, OutputT> transform) {\n\n    return new TimestampExtractTransform<>(null, transform);\n  }\n\n  /**\n   * Create transformation working on KVs with timestamps as key.\n   *\n   * @param <InputT> type of input elements\n   * @param <OutputT> type of output elements\n   * @param name name of the transform\n   * @param transform the transform applied on elements with timestamp\n   * @return the transform\n   */\n  public static <InputT, OutputT> TimestampExtractTransform<InputT, OutputT> of(\n      String name, PCollectionTransform<InputT, OutputT> transform) {\n\n    return new TimestampExtractTransform<>(name, transform);\n  }\n\n  /**\n   * Apply user defined transform(s) to input {@link PCollection} and return output one.\n   *\n   * @param <InputT> input type\n   * @param <OutputT> output type\n   */\n  @FunctionalInterface\n  public interface PCollectionTransform<InputT, OutputT>\n      extends UnaryFunction<PCollection<KV<Long, InputT>>, PCollection<OutputT>> {}\n\n  private static class Wrap<T> extends DoFn<T, KV<Long, T>> {\n\n    @ProcessElement\n    public void processElement(ProcessContext ctx) {\n      ctx.output(KV.of(ctx.timestamp().getMillis(), ctx.element()));\n    }\n  }\n\n  private static class Unwrap<T> extends DoFn<KV<Long, T>, T> {\n\n    @ProcessElement\n    public void processElement(ProcessContext ctx) {\n      ctx.output(ctx.element().getValue());\n    }\n  }\n\n  private final PCollectionTransform<InputT, OutputT> timestampedTransform;\n\n  private TimestampExtractTransform(\n      @Nullable String name, PCollectionTransform<InputT, OutputT> timestampedTransform) {\n\n    super(name);\n    this.timestampedTransform = timestampedTransform;\n  }\n\n<fim_suffix>  @Override\n  public PCollection<OutputT> expand(PCollection<InputT> input) {\n    PCollection<KV<Long, InputT>> in;\n    in = input.apply(getName(\"wrap\"), ParDo.of(new Wrap<>()));\n    if (input.getTypeDescriptor() != null) {\n      in =\n          in.setTypeDescriptor(\n              TypeDescriptors.kvs(TypeDescriptors.longs(), input.getTypeDescriptor()));\n    }\n    return timestampedTransform.apply(in);\n  }\n\n  private String getName(String suffix) {\n    return name != null ? name + \"::\" + suffix : suffix;\n  }\n}<fim_middle>// function below has no smell\n"}