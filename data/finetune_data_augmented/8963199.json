{"text": "<fim_prefix>      byteVars = Arrays.copyOfRange(byteVars, end, size);\n      nulls = nulls.get(end, size);\n      size = byteVars.length;\n      return subset;\n    }\n    if (type == Type.SMALLINT_TYPE) {\n      ColumnBuffer subset =\n          new ColumnBuffer(type, subNulls, Arrays.copyOfRange(shortVars, 0, end));\n      shortVars = Arrays.copyOfRange(shortVars, end, size);\n      nulls = nulls.get(end, size);\n      size = shortVars.length;\n      return subset;\n    }\n    if (type == Type.INT_TYPE) {\n      ColumnBuffer subset =\n          new ColumnBuffer(type, subNulls, Arrays.copyOfRange(intVars, 0, end));\n      intVars = Arrays.copyOfRange(intVars, end, size);\n      nulls = nulls.get(end, size);\n      size = intVars.length;\n      return subset;\n    }\n    if (type == Type.BIGINT_TYPE) {\n      ColumnBuffer subset =\n          new ColumnBuffer(type, subNulls, Arrays.copyOfRange(longVars, 0, end));\n      longVars = Arrays.copyOfRange(longVars, end, size);\n      nulls = nulls.get(end, size);\n      size = longVars.length;\n      return subset;\n    }\n    if (type == Type.DOUBLE_TYPE || type == Type.FLOAT_TYPE) {\n      ColumnBuffer subset =\n          new ColumnBuffer(type, subNulls, Arrays.copyOfRange(doubleVars, 0, end));\n      doubleVars = Arrays.copyOfRange(doubleVars, end, size);\n      nulls = nulls.get(end, size);\n      size = doubleVars.length;\n      return subset;\n    }\n    if (type == Type.BINARY_TYPE) {\n      ColumnBuffer subset = new ColumnBuffer(type, subNulls, binaryVars.subList(0, end));\n      binaryVars = binaryVars.subList(end, binaryVars.size());\n      nulls = nulls.get(end, size);\n      size = binaryVars.size();\n      return subset;\n    }\n    if (type == Type.STRING_TYPE) {\n      ColumnBuffer subset = new ColumnBuffer(type, subNulls, stringVars.subList(0, end));\n      stringVars = stringVars.subList(end, stringVars.size());\n      nulls = nulls.get(end, size);\n      size = stringVars.size();\n      return subset;\n    }\n    throw new IllegalStateException(\"invalid union object\");\n  }\n  @VisibleForTesting\n  BitSet getNulls() {\n    return nulls;\n  }\n  private static final byte[] MASKS = new byte[] {\n      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, (byte)0x80\n  };\n  private static BitSet toBitset(byte[] nulls) {\n    BitSet bitset = new BitSet();\n    int bits = nulls.length * 8;\n    for (int i = 0; i < bits; i++) {\n      bitset.set(i, (nulls[i / 8] & MASKS[i % 8]) != 0);\n    }\n    return bitset;\n  }\n  private static byte[] toBinary(BitSet bitset) {\n    byte[] nulls = new byte[1 + (bitset.length() / 8)];\n    for (int i = 0; i < bitset.length(); i++) {\n      nulls[i / 8] |= bitset.get(i) ? MASKS[i % 8] : 0;\n    }\n    return nulls;\n  }\n  public Type getType() {\n    return type;\n  }\n  @Override\n  public Object get(int index) {\n    if (nulls.get(index)) {\n      return null;\n    }\n    switch (type) {\n      case BOOLEAN_TYPE:\n        return boolVars[index];\n      case TINYINT_TYPE:\n        return byteVars[index];\n      case SMALLINT_TYPE:\n        return shortVars[index];\n      case INT_TYPE:\n        return intVars[index];\n      case BIGINT_TYPE:\n        return longVars[index];\n      case FLOAT_TYPE:\n      case DOUBLE_TYPE:\n        return doubleVars[index];\n      case STRING_TYPE:\n        return stringVars.get(index);\n      case BINARY_TYPE:\n        return binaryVars.get(index).array();\n    }\n    return null;\n  }\n  @Override\n  public int size() {\n    return size;\n  }\n  public TColumn toTColumn() {\n    TColumn value = new TColumn();\n    ByteBuffer nullMasks = ByteBuffer.wrap(toBinary(nulls));\n    switch (type) {\n    case BOOLEAN_TYPE:\n      value.setBoolVal(new TBoolColumn(Booleans.asList(Arrays.copyOfRange(boolVars, 0, size)),\n          nullMasks));\n      break;\n    case TINYINT_TYPE:\n      value.setByteVal(new TByteColumn(Bytes.asList(Arrays.copyOfRange(byteVars, 0, size)),\n          nullMasks));\n      break;\n    case SMALLINT_TYPE:\n      value.setI16Val(new TI16Column(Shorts.asList(Arrays.copyOfRange(shortVars, 0, size)),\n          nullMasks));\n      break;\n    case INT_TYPE:\n      value.setI32Val(new TI32Column(Ints.asList(Arrays.copyOfRange(intVars, 0, size)), nullMasks));\n      break;\n    case BIGINT_TYPE:\n      value\n          .setI64Val(new TI64Column(Longs.asList(Arrays.copyOfRange(longVars, 0, size)), nullMasks));\n      break;\n    case FLOAT_TYPE:\n    case DOUBLE_TYPE:\n      value.setDoubleVal(new TDoubleColumn(Doubles.asList(Arrays.copyOfRange(doubleVars, 0, size)),\n          nullMasks));\n      break;\n    case STRING_TYPE:\n      value.setStringVal(new TStringColumn(stringVars, nullMasks));\n      break;\n    case BINARY_TYPE:\n      value.setBinaryVal(new TBinaryColumn(binaryVars, nullMasks));\n      break;\n    }\n    return value;\n  }\n  private static final ByteBuffer EMPTY_BINARY = ByteBuffer.allocate(0);\n  private static final String EMPTY_STRING = \"\";\n  public void addValue(Object field) {\n    addValue(this.type, field);\n  }\n  public void addValue(Type type, Object field) {\n    switch (type) {\n    case BOOLEAN_TYPE:\n      nulls.set(size, field == null);\n      boolVars()[size] = field == null ? true : (Boolean) field;\n      break;\n    case TINYINT_TYPE:\n      nulls.set(size, field == null);\n      byteVars()[size] = field == null ? 0 : (Byte) field;\n      break;\n    case SMALLINT_TYPE:\n      nulls.set(size, field == null);\n      shortVars()[size] = field == null ? 0 : (Short) field;\n      break;\n    case INT_TYPE:\n      nulls.set(size, field == null);\n      intVars()[size] = field == null ? 0 : (Integer) field;\n      break;\n    case BIGINT_TYPE:\n      nulls.set(size, field == null);\n      longVars()[size] = field == null ? 0 : (Long) field;\n      break;\n    case FLOAT_TYPE:\n      nulls.set(size, field == null);\n      doubleVars()[size] = field == null ? 0.0 : Double.parseDouble(field.toString());\n      break;\n    case DOUBLE_TYPE:\n      nulls.set(size, field == null);\n      doubleVars()[size] = field == null ? 0 : (Double) field;\n      break;\n    case BINARY_TYPE:\n      nulls.set(binaryVars.size(), field == null);\n      binaryVars.add(field == null ? EMPTY_BINARY : ByteBuffer.wrap((byte[]) field));\n      break;\n    default:\n      nulls.set(stringVars.size(), field == null);\n      stringVars.add(field == null ? EMPTY_STRING : String.valueOf(field));\n      break;\n    }\n    size++;\n  }\n  private boolean[] boolVars() {\n    if (boolVars.length == size) {\n      boolean[] newVars = new boolean[size << 1];\n      System.arraycopy(boolVars, 0, newVars, 0, size);\n      return boolVars = newVars;\n    }\n    return boolVars;\n  }\n<fim_suffix>  private byte[] byteVars() {\n    if (byteVars.length == size) {\n      byte[] newVars = new byte[size << 1];\n      System.arraycopy(byteVars, 0, newVars, 0, size);\n      return byteVars = newVars;\n    }\n    return byteVars;\n  }<fim_middle>// function below has no smell\n"}