{"text": "<fim_prefix>   *\n   * @return {@code true} if element has at least one child or {@code false} if doesn't\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public boolean hasChildren() {\n    checkNotRemoved();\n    final NodeList childNodes = delegate.getChildNodes();\n    for (int i = 0; i < childNodes.getLength(); i++) {\n      if (childNodes.item(i).getNodeType() == ELEMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Sets new text content to element\n   *\n   * @param newText new text content\n   * @throws XMLTreeException when this element has been removed from xml tree\n   * @throws NullPointerException when newText parameter is {@code null}\n   */\n  public Element setText(String newText) {\n    checkNotRemoved();\n    requireNonNull(newText, \"Required not null new text\");\n    if (!newText.equals(getText())) {\n      removeTextNodes();\n      delegate.appendChild(document().createTextNode(newText));\n      // let tree do dirty job\n      xmlTree.updateText(this);\n    }\n    return this;\n  }\n  /**\n   * Returns text content of child with given name.\n   *\n   * @param childName child name to fetch text content\n   * @return child text or {@code null} if child doesn't exist or element has more then only child\n   *     with given name\n   */\n  public String getChildText(String childName) {\n    return getChildTextOrDefault(childName, null);\n  }\n  /**\n   * Returns text content of child with given name or default value if child doesn't exist or it has\n   * sibling with same name\n   *\n   * @param childName name of child\n   * @param defaultValue value which will be returned if child doesn't exist or it has sibling with\n   *     same name\n   * @return child text\n   * @throws XMLTreeException when this element has been removed from xml tree\n   * @throws NullPointerException when childName parameter is {@code null}\n   */\n  public String getChildTextOrDefault(String childName, String defaultValue) {\n    checkNotRemoved();\n    requireNonNull(childName, \"Required not null child name\");\n    return hasSingleChild(childName) ? getSingleChild(childName).getText() : defaultValue;\n  }\n  /**\n   * Returns {@code true} if element has only sibling with given name or {@code false} if element\n   * has more then 1 or 0 siblings with given name\n   *\n   * @param childName name of sibling\n   * @return {@code true} if element has only sibling with given name otherwise {@code false}\n   * @throws XMLTreeException when this element has been removed from xml tree\n   * @throws NullPointerException when childName parameter is {@code null}\n   */\n  public boolean hasSingleChild(String childName) {\n    checkNotRemoved();\n    requireNonNull(childName, \"Required not null child name\");\n    for (Element child : asElements(delegate.getChildNodes())) {\n      if (childName.equals(child.getName())) {\n        return !child.hasSibling(childName);\n      }\n    }\n    return false;\n  }\n  /**\n   * Removes single element child. If child does not exist nothing will be done\n   *\n   * @param name child name to removeElement\n   * @return this element instance\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public Element removeChild(String name) {\n    checkNotRemoved();\n    final Element child = getSingleChild(name);\n    if (child != null) {\n      child.remove();\n    }\n    return this;\n  }\n  /**\n   * Removes current element and related children from xml\n   *\n   * @throws XMLTreeException when this element has been removed from xml tree or this element is\n   *     root element\n   */\n  public void remove() {\n    checkNotRemoved();\n    notPermittedOnRootElement();\n    if (hasChildren()) {\n      for (Element element : getChildren()) {\n        element.remove();\n      }\n    }\n    // let tree do dirty job\n    xmlTree.removeElement(this);\n    // remove self from document\n    delegate.getParentNode().removeChild(delegate);\n    // if references to 'this' element exist\n    // we should disallow ability to use delegate\n    delegate = null;\n  }\n  /**\n   * Removes children which names equal to given name\n   *\n   * @param name name to remove children\n   * @return this element instance\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public Element removeChildren(String name) {\n    checkNotRemoved();\n    final List<Node> matched = new LinkedList<>();\n    final NodeList nodes = delegate.getChildNodes();\n    for (int i = 0; i < nodes.getLength(); i++) {\n      if (name.equals(nodes.item(i).getNodeName())) {\n        matched.add(nodes.item(i));\n      }\n    }\n    for (Node node : matched) {\n      asElement(node).remove();\n    }\n    return this;\n  }\n  /**\n   * Sets new attribute to element. If element has attribute with given name attribute value will be\n   * replaced with new value\n   *\n   * @param name attribute name\n   * @param value attribute value\n   * @return this element instance\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public Element setAttribute(String name, String value) {\n    return setAttribute(new NewAttribute(name, value));\n  }\n  /**\n   * Sets new attribute to element. If element has attribute with {@code newAttribute#name} then\n   * existing attribute value will be replaced with {@code newAttribute#value}.\n   *\n   * @param newAttribute attribute that should be added to element\n   * @return this element instance\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public Element setAttribute(NewAttribute newAttribute) {\n    checkNotRemoved();\n    requireNonNull(newAttribute, \"Required not null new attribute\");\n    // if tree already contains element replace value\n    if (hasAttribute(newAttribute.getName())) {\n      final Attribute attr = getAttribute(newAttribute.getName());\n      attr.setValue(newAttribute.getValue());\n      return this;\n    }\n    //\n    if (newAttribute.hasPrefix()) {\n      delegate.setAttributeNodeNS(createAttrNSNode(newAttribute));\n    } else {\n      delegate.setAttributeNode(createAttrNode(newAttribute));\n    }\n    // let tree do dirty job\n    xmlTree.insertAttribute(newAttribute, this);\n    return this;\n  }\n  /**\n   * Removes attribute with given name. If element doesn't have attribute with given name nothing\n   * will be done.\n   *\n   * @param name name of attribute which should be removed from element\n   * @return this element instance\n   * @throws XMLTreeException when this element has been removed from xml tree\n   * @throws NullPointerException when name parameter is {@code null}\n   */\n  public Element removeAttribute(String name) {\n    checkNotRemoved();\n    final Attribute attribute = getAttribute(name);\n    if (attribute != null) {\n      xmlTree.removeAttribute(attribute);\n      delegate.getAttributes().removeNamedItem(name);\n    }\n    return this;\n  }\n  /**\n   * Returns {@code true} if element has attribute with given name\n   *\n   * @param name name of attribute to check\n   * @return {@code true} if element has attribute with {@code name} otherwise {@code false}\n   * @throws XMLTreeException when this element has been removed from xml tree\n   */\n  public boolean hasAttribute(String name) {\n    checkNotRemoved();\n    return delegate.hasAttribute(name);\n  }\n  /**\n   * Returns {@code true} if element doesn't have closing tag i.e {@literal <element\n   * attr=\"value\"/>}, otherwise {@code false}\n   */\n  public boolean isVoid() {\n    return start.equals(end);\n  }\n  /**\n   * Returns attribute with given name or {@code null} if element doesn't have such attribute\n   *\n   * @param name name to search attribute\n   * @return attribute with {@code name} or {@code null} if nothing found\n   * @throws XMLTreeException when this element has been removed from xml tree\n   * @throws NullPointerException when name parameter is {@code null}\n   */\n  public Attribute getAttribute(String name) {\n    checkNotRemoved();\n    requireNonNull(name, \"Required not null attribute name\");\n    if (delegate.hasAttributes()) {\n      return asAttribute(getAttributeNode(name));\n    }\n    return null;\n  }\n  /**\n   * Replaces this element with new one.\n   *\n   * @param newElement new element which is replacement for current element\n   * @return newly created element\n   * @throws XMLTreeException when this element has been removed from xml tree or this element is\n   *     root element\n   * @throws NullPointerException when newElement parameter is {@code null}\n   */\n<fim_suffix>  public Element replaceWith(NewElement newElement) {\n    checkNotRemoved();\n    notPermittedOnRootElement();\n    requireNonNull(newElement, \"Required not null new element\");\n    insertAfter(newElement);\n    final Element inserted = getNextSibling();\n    remove();\n    return inserted;\n  }<fim_middle>// function below has no smell\n"}