{"text": "<fim_prefix>/*\n * Copyright 2018-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.cassandra.core;\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport org.springframework.data.cassandra.core.cql.CqlIdentifier;\nimport org.springframework.data.cassandra.core.query.Query;\nimport org.springframework.util.Assert;\n\n/**\n * The {@link ReactiveSelectOperation} interface allows creation and execution of Cassandra {@code SELECT} operations\n * in a fluent API style.\n * <p>\n * The starting {@literal domainType} is used for mapping the {@link Query} provided via {@code matching} int the\n * Cassandra specific representation. By default, the originating {@literal domainType} is also used for mapping back\n * the result from the {@link com.datastax.driver.core.Row}. However, it is possible to define an different\n * {@literal returnType} via {@code as} to mapping the result.\n * <p>\n * By default, the table to operate on is derived from the initial {@literal domainType} and can be defined there via\n * the {@link org.springframework.data.cassandra.core.mapping.Table} annotation. Using {@code inTable} allows\n * a developer to override the table name for the execution.\n *\n * <pre>\n *     <code>\n *         query(Human.class)\n *             .inTable(\"star_wars\")\n *             .as(Jedi.class)\n *             .matching(query(where(\"firstname\").is(\"luke\")))\n *             .all();\n *     </code>\n * </pre>\n *\n * @author Mark Paluch\n * @author John Blum\n * @see org.springframework.data.cassandra.core.query.Query\n * @since 2.1\n */\npublic interface ReactiveSelectOperation {\n\n\t/**\n\t * Begin creating a {@code SELECT} operation for the given {@link Class domainType}.\n\t *\n\t * @param <T> {@link Class type} of the application domain object.\n\t * @param domainType {@link Class type} of the domain object to query; must not be {@literal null}.\n\t * @return new instance of {@link ReactiveSelect}.\n\t * @throws IllegalArgumentException if {@link Class domainType} is {@literal null}.\n\t * @see ReactiveSelect\n\t */\n\t<T> ReactiveSelect<T> query(Class<T> domainType);\n\n\t/**\n\t * Table override (optional).\n\t */\n<fim_suffix>\tinterface SelectWithTable<T> extends SelectWithQuery<T> {\n\n\t\t/**\n\t\t * Explicitly set the {@link String name} of the table on which to perform the query.\n\t\t * <p>\n\t\t * Skip this step to use the default table derived from the {@link Class domain type}.\n\t\t *\n\t\t * @param table {@link String name} of the table; must not be {@literal null} or empty.\n\t\t * @return new instance of {@link SelectWithProjection}.\n\t\t * @throws IllegalArgumentException if {@link String table} is {@literal null} or empty.\n\t\t * @see #inTable(CqlIdentifier)\n\t\t * @see SelectWithProjection\n\t\t */\n\t\tdefault SelectWithProjection<T> inTable(String table) {\n\n\t\t\tAssert.hasText(table, \"Table name must not be null or empty\");\n\n\t\t\treturn inTable(CqlIdentifier.of(table));\n\t\t}\n\n\t\t/**\n\t\t * Explicitly set the {@link CqlIdentifier name} of the table on which to perform the query.\n\t\t * <p>\n\t\t * Skip this step to use the default table derived from the {@link Class domain type}.\n\t\t *\n\t\t * @param table {@link CqlIdentifier name} of the table; must not be {@literal null}.\n\t\t * @return new instance of {@link SelectWithProjection}.\n\t\t * @throws IllegalArgumentException if {@link CqlIdentifier table} is {@literal null}.\n\t\t * @see org.springframework.data.cassandra.core.cql.CqlIdentifier\n\t\t * @see SelectWithProjection\n\t\t */\n\t\tSelectWithProjection<T> inTable(CqlIdentifier table);\n\n\t}\n\n\t/**\n\t * Result type override (optional).\n\t */\n\tinterface SelectWithProjection<T> extends SelectWithQuery<T> {\n\n\t\t/**\n\t\t * Define the {@link Class result target type} that the fields should be mapped to.\n\t\t * <p>\n\t\t * Skip this step if you are only interested in the original {@link Class domain type}.\n\t\t *\n\t\t * @param <R> {@link Class type} of the result.\n\t\t * @param resultType desired {@link Class type} of the result; must not be {@literal null}.\n\t\t * @return new instance of {@link SelectWithQuery}.\n\t\t * @throws IllegalArgumentException if {@link Class resultType} is {@literal null}.\n\t\t * @see SelectWithQuery\n\t\t */\n\t\t<R> SelectWithQuery<R> as(Class<R> resultType);\n\n\t}\n\n\t/**\n\t * Define a {@link Query} used as the filter for the {@code SELECT}.\n\t */\n\tinterface SelectWithQuery<T> extends TerminatingSelect<T> {\n\n\t\t/**\n\t\t * Set the {@link Query} used as a filter in the {@code SELECT} statement.\n\t\t *\n\t\t * @param query {@link Query} used as a filter; must not be {@literal null}.\n\t\t * @return new instance of {@link TerminatingSelect}.\n\t\t * @throws IllegalArgumentException if {@link Query} is {@literal null}.\n\t\t * @see org.springframework.data.cassandra.core.query.Query\n\t\t * @see TerminatingSelect\n\t\t */\n\t\tTerminatingSelect<T> matching(Query query);\n\n\t}\n\n\t/**\n\t * Trigger {@code SELECT} execution by calling one of the terminating methods.\n\t */\n\tinterface TerminatingSelect<T> {\n\n\t\t/**\n\t\t * Get the number of matching elements.\n\t\t *\n\t\t * @return a {@link Mono} emitting the total number of matching elements; never {@literal null}.\n\t\t * @see reactor.core.publisher.Mono\n\t\t */\n\t\tMono<Long> count();\n\n\t\t/**\n\t\t * Check for the presence of matching elements.\n\t\t *\n\t\t * @return a {@link Mono} emitting {@literal true} if at least one matching element exists;\n\t\t * never {@literal null}.\n\t\t * @see reactor.core.publisher.Mono\n\t\t */\n\t\tMono<Boolean> exists();\n\n\t\t/**\n\t\t * Get the first result or no result.\n\t\t *\n\t\t * @return the first result or {@link Mono#empty()} if no match found; never {@literal null}.\n\t\t * @see reactor.core.publisher.Mono\n\t\t */\n\t\tMono<T> first();\n\n\t\t/**\n\t\t * Get exactly zero or one result.\n\t\t *\n\t\t * @return exactly one result or {@link Mono#empty()} if no match found; never {@literal null}.\n\t\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException if more than one match found.\n\t\t * @see reactor.core.publisher.Mono\n\t\t */\n\t\tMono<T> one();\n\n\t\t/**\n\t\t * Get all matching elements.\n\t\t *\n\t\t * @return all matching elements; never {@literal null}.\n\t\t * @see reactor.core.publisher.Flux\n\t\t */\n\t\tFlux<T> all();\n\n\t}\n\n\t/**\n\t * The {@link ReactiveSelect} interface provides methods for constructing {@code SELECT} operations\n\t * in a fluent way.\n\t */\n\tinterface ReactiveSelect<T> extends SelectWithTable<T>, SelectWithProjection<T> {}\n\n}<fim_middle>// class below has no smell\n"}