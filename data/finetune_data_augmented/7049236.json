{"text": "<fim_prefix>    _excludeRecentlyDemotedBrokers = config.getBoolean(KafkaCruiseControlConfig.GOAL_VIOLATION_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n    _excludeRecentlyRemovedBrokers = config.getBoolean(KafkaCruiseControlConfig.GOAL_VIOLATION_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n    _kafkaCruiseControl = kafkaCruiseControl;\n  }\n  private SortedMap<Integer, Goal> getDetectorGoalsMap(KafkaCruiseControlConfig config) {\n    List<String> allGoals = config.getList(KafkaCruiseControlConfig.GOALS_CONFIG);\n    Map<String, Integer> priorityMap = new HashMap<>();\n    int i = 0;\n    for (String goalClass : allGoals) {\n      priorityMap.put(goalClass, i++);\n    }\n    List<Goal> goals = config.getConfiguredInstances(KafkaCruiseControlConfig.ANOMALY_DETECTION_GOALS_CONFIG, Goal.class);\n    SortedMap<Integer, Goal> orderedGoals = new TreeMap<>();\n    for (Goal goal: goals) {\n      Integer priority = priorityMap.get(goal.getClass().getName());\n      if (priority == null) {\n        throw new IllegalArgumentException(goal.getClass().getName() + \" is defined in \" + KafkaCruiseControlConfig.ANOMALY_DETECTION_GOALS_CONFIG\n                                               + \" but not found in \" + KafkaCruiseControlConfig.GOALS_CONFIG);\n      }\n      orderedGoals.put(priorityMap.get(goal.getClass().getName()), goal);\n    }\n    return orderedGoals;\n  }\n  /**\n   * Skip goal violation detection if any of the following is true:\n   * <ul>\n   * <li>Cluster model generation has not changed since the last goal violation check.</li>\n   * <li>Load monitor is not ready.</li>\n   * <li>There is an ongoing execution.</li>\n   * </ul>\n   *\n   * @return True to skip goal violation detection based on the current state, false otherwise.\n   */\n  private boolean shouldSkipGoalViolationDetection() {\n    if (_loadMonitor.clusterModelGeneration().equals(_lastCheckedModelGeneration)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skipping goal violation detection because the model generation hasn't changed. Current model generation {}\",\n                  _loadMonitor.clusterModelGeneration());\n      }\n      return true;\n    }\n    LoadMonitorTaskRunner.LoadMonitorTaskRunnerState loadMonitorTaskRunnerState = _loadMonitor.taskRunnerState();\n    if (!ViolationUtils.isLoadMonitorReady(loadMonitorTaskRunnerState)) {\n      LOG.info(\"Skipping goal violation detection because load monitor is in {} state.\", loadMonitorTaskRunnerState);\n      return true;\n    }\n    ExecutorState.State executorState = _kafkaCruiseControl.state(\n        new OperationProgress(), Collections.singleton(EXECUTOR)).executorState().state();\n    if (executorState != ExecutorState.State.NO_TASK_IN_PROGRESS) {\n      LOG.info(\"Skipping goal violation detection because the executor is in {} state.\", executorState);\n      return true;\n    }\n    return false;\n  }\n  @Override\n  public void run() {\n    if (shouldSkipGoalViolationDetection()) {\n      return;\n    }\n    AutoCloseable clusterModelSemaphore = null;\n    try {\n      GoalViolations goalViolations = new GoalViolations(_kafkaCruiseControl, _allowCapacityEstimation,\n                                                         _excludeRecentlyDemotedBrokers, _excludeRecentlyRemovedBrokers);\n      long now = _time.milliseconds();\n      boolean newModelNeeded = true;\n      ClusterModel clusterModel = null;\n      // Retrieve excluded brokers for leadership and replica move.\n      ExecutorState executorState = null;\n      if (_excludeRecentlyDemotedBrokers || _excludeRecentlyRemovedBrokers) {\n        executorState = _kafkaCruiseControl.state(new OperationProgress(), Collections.singleton(EXECUTOR)).executorState();\n      }\n      Set<Integer> excludedBrokersForLeadership = _excludeRecentlyDemotedBrokers ? executorState.recentlyDemotedBrokers()\n                                                                                 : Collections.emptySet();\n      Set<Integer> excludedBrokersForReplicaMove = _excludeRecentlyRemovedBrokers ? executorState.recentlyRemovedBrokers()\n                                                                                  : Collections.emptySet();\n      for (Map.Entry<Integer, Goal> entry : _goals.entrySet()) {\n        Goal goal = entry.getValue();\n        if (_loadMonitor.meetCompletenessRequirements(goal.clusterModelCompletenessRequirements())) {\n          LOG.debug(\"Detecting if {} is violated.\", entry.getValue().name());\n          // Because the model generation could be slow, We only get new cluster model if needed.\n          if (newModelNeeded) {\n            if (clusterModelSemaphore != null) {\n              clusterModelSemaphore.close();\n            }\n            clusterModelSemaphore = _loadMonitor.acquireForModelGeneration(new OperationProgress());\n            // Make cluster model null before generating a new cluster model so the current one can be GCed.\n            clusterModel = null;\n            clusterModel = _loadMonitor.clusterModel(now,\n                                                     goal.clusterModelCompletenessRequirements(),\n                                                     new OperationProgress());\n            // If the clusterModel contains dead brokers, goal violation detector will ignore any goal violations.\n            // Detection and fix for dead brokers is the responsibility of broker failure detector and its self-healer.\n            if (!clusterModel.deadBrokers().isEmpty()) {\n              LOG.info(\"Skipping goal violation detection due to dead brokers {}, which are reported by broker failure \"\n                       + \"detector, and fixed if its self healing configuration is enabled.\", clusterModel.deadBrokers());\n              return;\n            }\n            KafkaCruiseControl.sanityCheckCapacityEstimation(_allowCapacityEstimation,\n                                                             clusterModel.capacityEstimationInfoByBrokerId());\n            _lastCheckedModelGeneration = clusterModel.generation();\n          }\n          newModelNeeded = optimizeForGoal(clusterModel, goal, goalViolations, excludedBrokersForLeadership, excludedBrokersForReplicaMove);\n        } else {\n          LOG.warn(\"Skipping goal violation detection for {} because load completeness requirement is not met.\", goal);\n        }\n      }\n      if (!goalViolations.violatedGoalsByFixability().isEmpty()) {\n        _anomalies.add(goalViolations);\n      }\n    } catch (NotEnoughValidWindowsException nevwe) {\n      LOG.debug(\"Skipping goal violation detection because there are not enough valid windows.\");\n    } catch (KafkaCruiseControlException kcce) {\n      LOG.warn(\"Goal violation detector received exception\", kcce);\n    } catch (Exception e) {\n      LOG.error(\"Unexpected exception\", e);\n    } finally {\n      if (clusterModelSemaphore != null) {\n        try {\n          clusterModelSemaphore.close();\n        } catch (Exception e) {\n          LOG.error(\"Received exception when closing auto closable semaphore\", e);\n        }\n      }\n      LOG.debug(\"Goal violation detection finished.\");\n    }\n  }\n  private Set<String> excludedTopics(ClusterModel clusterModel) {\n    return clusterModel.topics()\n        .stream()\n        .filter(topic -> _excludedTopics.matcher(topic).matches())\n        .collect(Collectors.toSet());\n  }\n<fim_suffix>  private boolean optimizeForGoal(ClusterModel clusterModel,\n                                  Goal goal,\n                                  GoalViolations goalViolations,\n                                  Set<Integer> excludedBrokersForLeadership,\n                                  Set<Integer> excludedBrokersForReplicaMove)\n      throws KafkaCruiseControlException {\n    if (clusterModel.topics().isEmpty()) {\n      LOG.info(\"Skipping goal violation detection because the cluster model does not have any topic.\");\n      return false;\n    }\n    Map<TopicPartition, List<Integer>> initReplicaDistribution = clusterModel.getReplicaDistribution();\n    Map<TopicPartition, Integer> initLeaderDistribution = clusterModel.getLeaderDistribution();\n    try {\n      goal.optimize(clusterModel, new HashSet<>(), new OptimizationOptions(excludedTopics(clusterModel),\n                                                                           excludedBrokersForLeadership,\n                                                                           excludedBrokersForReplicaMove));\n    } catch (OptimizationFailureException ofe) {\n      // An OptimizationFailureException indicates (1) a hard goal violation that cannot be fixed typically due to\n      // lack of physical hardware (e.g. insufficient number of racks to satisfy rack awareness, insufficient number\n      // of brokers to satisfy Replica Capacity Goal, or insufficient number of resources to satisfy resource\n      // capacity goals), or (2) a failure to move offline replicas away from dead brokers/disks.\n      goalViolations.addViolation(goal.name(), false);\n      return true;\n    }\n    Set<ExecutionProposal> proposals = AnalyzerUtils.getDiff(initReplicaDistribution, initLeaderDistribution, clusterModel);\n    LOG.trace(\"{} generated {} proposals\", goal.name(), proposals.size());\n    if (!proposals.isEmpty()) {\n      // A goal violation that can be optimized by applying the generated proposals.\n      goalViolations.addViolation(goal.name(), true);\n      return true;\n    } else {\n      // The goal is already satisfied.\n      return false;\n    }\n  }<fim_middle>// function below is long method\n"}