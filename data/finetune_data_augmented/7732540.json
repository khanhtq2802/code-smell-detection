{"text": "<fim_prefix>            if (!inConstruction && getManagementSupport().isDeployed()) {\n                // previously we threw, then warned, but it is still quite common;\n                // so long as callers don't expect miracles, it should be fine.\n                // i (Alex) think the way to be stricter about this (if that becomes needed) \n                // would be to introduce a 'mutable' field on config keys\n                LOG.debug(\"configuration being made to {} after deployment: {} = {}; change may not be visible in other contexts\", \n                        new Object[] { AbstractEntity.this, key, val });\n            }\n            T result = (T) configsInternal.setConfig(key, val);\n            getManagementSupport().getEntityChangeListener().onConfigChanged(key);\n            return result;\n        }\n        @Override\n        protected ExecutionContext getContext() {\n            return AbstractEntity.this.getExecutionContext();\n        }\n    }\n    @Override\n    public <T> T getConfig(ConfigKey<T> key) {\n        return config().get(key);\n    }\n    @Override\n    public <T> T getConfig(HasConfigKey<T> key) {\n        return config().get(key);\n    }\n    @Override\n    @Deprecated\n    public <T> T getConfig(HasConfigKey<T> key, T defaultValue) {\n        return configsInternal.getConfig(key, defaultValue);\n    }\n    //don't use groovy defaults for defaultValue as that doesn't implement the contract; we need the above\n    @Override\n    @Deprecated\n    public <T> T getConfig(ConfigKey<T> key, T defaultValue) {\n        return configsInternal.getConfig(key, defaultValue);\n    }\n    @Override\n    @Deprecated\n    public Maybe<Object> getConfigRaw(ConfigKey<?> key, boolean includeInherited) {\n        return (includeInherited) ? config().getRaw(key) : config().getLocalRaw(key);\n    }\n    @Override\n    @Deprecated\n    public Maybe<Object> getConfigRaw(HasConfigKey<?> key, boolean includeInherited) {\n        return (includeInherited) ? config().getRaw(key) : config().getLocalRaw(key);\n    }\n    @Override\n    @Deprecated\n    public <T> T setConfig(ConfigKey<T> key, T val) {\n        return config().set(key, val);\n    }\n    @Override\n    @Deprecated\n    public <T> T setConfig(ConfigKey<T> key, Task<T> val) {\n        return config().set(key, val);\n    }\n    /**\n     * @deprecated since 0.7.0; use {@code config().set(key, task)}, with {@link Task} instead of {@link DeferredSupplier}\n     */\n    @Deprecated\n    public <T> T setConfig(ConfigKey<T> key, DeferredSupplier val) {\n        return config.setConfigInternal(key, val);\n    }\n    @Override\n    @Deprecated\n    public <T> T setConfig(HasConfigKey<T> key, T val) {\n        return config().set(key, val);\n    }\n    @Override\n    @Deprecated\n    public <T> T setConfig(HasConfigKey<T> key, Task<T> val) {\n        return (T) config().set(key, val);\n    }\n    /**\n     * @deprecated since 0.7.0; use {@code config().set(key, task)}, with {@link Task} instead of {@link DeferredSupplier}\n     */\n    @Deprecated\n    public <T> T setConfig(HasConfigKey<T> key, DeferredSupplier val) {\n        return setConfig(key.getConfigKey(), val);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public <T> T setConfigEvenIfOwned(ConfigKey<T> key, T val) {\n        return (T) configsInternal.setConfig(key, val);\n    }\n    public <T> T setConfigEvenIfOwned(HasConfigKey<T> key, T val) {\n        return setConfigEvenIfOwned(key.getConfigKey(), val);\n    }\n    /**\n     * @deprecated since 0.7.0; use {@code if (val != null) config().set(key, val)}\n     */\n    @Deprecated\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    protected void setConfigIfValNonNull(ConfigKey key, Object val) {\n        if (val != null) config().set(key, val);\n    }\n    /**\n     * @deprecated since 0.7.0; use {@code if (val != null) config().set(key, val)}\n     */\n    @Deprecated\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    protected void setConfigIfValNonNull(HasConfigKey key, Object val) {\n        if (val != null) config().set(key, val);\n    }\n    /**\n     * @deprecated since 0.7.0; see {@code config().refreshInheritedConfig()}\n     */\n    @Override\n    @Deprecated\n    public void refreshInheritedConfig() {\n        config().refreshInheritedConfig();\n    }\n    /**\n     * @deprecated since 0.7.0; see {@code config().refreshInheritedConfigOfChildren()}\n     */\n    @Deprecated\n    void refreshInheritedConfigOfChildren() {\n        config().refreshInheritedConfigOfChildren();\n    }\n    @Override\n    @Deprecated\n    public EntityConfigMap getConfigMap() {\n        return configsInternal;\n    }\n    @Override\n    @Deprecated\n    public Map<ConfigKey<?>,Object> getAllConfig() {\n        return configsInternal.getAllConfig();\n    }\n    @Beta\n    @Override\n    @Deprecated\n    public ConfigBag getAllConfigBag() {\n        return config().getBag();\n    }\n    @Beta\n    @Override\n    @Deprecated\n    public ConfigBag getLocalConfigBag() {\n        return config().getLocalBag();\n    }\n    // -------- SUBSCRIPTIONS --------------\n    @Override \n    @Beta\n    // the concrete type rather than an interface is returned because Groovy subclasses\n    // complain (incorrectly) if we return SubscriptionSupportInternal\n    // TODO revert to SubscriptionSupportInternal when groovy subclasses work without this (eg new groovy version)\n    public BasicSubscriptionSupport subscriptions() {\n        return subscriptions;\n    }\n    /**\n     * Direct use of this class is strongly discouraged. It will become private in a future release,\n     * once {@link #subscriptions()} is reverted to return {@link SubscriptionSupportInternal} instead of\n     * {@link BasicSubscriptionSupport}.\n     */\n    @Beta\n    // TODO revert to private when config() is reverted to return SensorSupportInternal\n    public class BasicSubscriptionSupport implements SubscriptionSupportInternal {\n        @Override\n        public <T> SubscriptionHandle subscribe(Entity producer, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n            return getSubscriptionTracker().subscribe(producer, sensor, listener);\n        }\n        @Override\n        public <T> SubscriptionHandle subscribe(Map<String, ?> flags, Entity producer, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n            return getSubscriptionTracker().subscribe(flags, producer, sensor, listener);\n        }\n        @Override\n        public <T> SubscriptionHandle subscribeToChildren(Entity parent, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n            return getSubscriptionTracker().subscribeToChildren(parent, sensor, listener);\n        }\n        @Override\n        public <T> SubscriptionHandle subscribeToMembers(Group group, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n            return getSubscriptionTracker().subscribeToMembers(group, sensor, listener);\n        }\n        /**\n         * Unsubscribes the given producer.\n         *\n         * @see SubscriptionContext#unsubscribe(SubscriptionHandle)\n         */\n        @Override\n        public boolean unsubscribe(Entity producer) {\n            return getSubscriptionTracker().unsubscribe(producer);\n        }\n        /**\n         * Unsubscribes the given handle.\n         *\n         * @see SubscriptionContext#unsubscribe(SubscriptionHandle)\n         */\n        @Override\n        public boolean unsubscribe(Entity producer, SubscriptionHandle handle) {\n            return getSubscriptionTracker().unsubscribe(producer, handle);\n        }\n        /**\n         * Unsubscribes the given handle.\n         * \n         * It is (currently) more efficient to also pass in the producer -\n         * see {@link BasicSubscriptionSupport#unsubscribe(Entity, SubscriptionHandle)} \n         */\n        @Override\n        public boolean unsubscribe(SubscriptionHandle handle) {\n            return getSubscriptionTracker().unsubscribe(handle);\n        }\n        @Override\n        public void unsubscribeAll() {\n            getSubscriptionTracker().unsubscribeAll();\n        }\n        protected SubscriptionContext getSubscriptionContext() {\n            synchronized (AbstractEntity.this) {\n                return getManagementSupport().getSubscriptionContext();\n            }\n        }\n        protected SubscriptionTracker getSubscriptionTracker() {\n            synchronized (AbstractEntity.this) {\n                if (_subscriptionTracker == null) {\n                    _subscriptionTracker = new SubscriptionTracker(getSubscriptionContext());\n                }\n                return _subscriptionTracker;\n            }\n        }\n    }\n    /**\n     * @deprecated since 0.9.0; see {@code subscriptions().subscribe(producer, sensor, listener)}\n     */\n    @Override\n    @Deprecated\n    public <T> SubscriptionHandle subscribe(Entity producer, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n        return subscriptions().subscribe(producer, sensor, listener);\n    }\n    /**\n     * @deprecated since 0.9.0; see {@code subscriptions().subscribeToChildren(parent, sensor, listener)}\n     */\n<fim_suffix>    @Override\n    @Deprecated\n    public <T> SubscriptionHandle subscribeToChildren(Entity parent, Sensor<T> sensor, SensorEventListener<? super T> listener) {\n        return subscriptions().subscribeToChildren(parent, sensor, listener);\n    }<fim_middle>// function below has no smell\n"}