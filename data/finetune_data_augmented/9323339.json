{"text": "<fim_prefix>      dumpStack();\n    }\n  }\n  public X86Frame(Address raw_sp, Address raw_fp) {\n    initFrame(raw_sp, raw_fp, null, null, null);\n    if (DEBUG) {\n      System.out.println(\"X86Frame(sp, fp): \" + this);\n      dumpStack();\n    }\n  }\n  public X86Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {\n    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, null);\n    if (DEBUG) {\n      System.out.println(\"X86Frame(sp, unextendedSP, fp, pc): \" + this);\n      dumpStack();\n    }\n  }\n  public X86Frame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {\n    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, live_bcp);\n    if (DEBUG) {\n      System.out.println(\"X86Frame(sp, fp, pc, unextendedSP, live_bcp): \" + this);\n      dumpStack();\n    }\n  }\n  public Object clone() {\n    X86Frame frame = new X86Frame();\n    frame.raw_sp = raw_sp;\n    frame.raw_unextendedSP = raw_unextendedSP;\n    frame.raw_fp = raw_fp;\n    frame.pc = pc;\n    frame.deoptimized = deoptimized;\n    frame.live_bcp = live_bcp;\n    return frame;\n  }\n  public boolean equals(Object arg) {\n    if (arg == null) {\n      return false;\n    }\n    if (!(arg instanceof X86Frame)) {\n      return false;\n    }\n    X86Frame other = (X86Frame) arg;\n    return (AddressOps.equal(getSP(), other.getSP()) &&\n            AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &&\n            AddressOps.equal(getFP(), other.getFP()) &&\n            AddressOps.equal(getPC(), other.getPC()));\n  }\n  public int hashCode() {\n    if (raw_sp == null) {\n      return 0;\n    }\n    return raw_sp.hashCode();\n  }\n  public String toString() {\n    return \"sp: \" + (getSP() == null? \"null\" : getSP().toString()) +\n         \", unextendedSP: \" + (getUnextendedSP() == null? \"null\" : getUnextendedSP().toString()) +\n         \", fp: \" + (getFP() == null? \"null\" : getFP().toString()) +\n         \", pc: \" + (pc == null? \"null\" : pc.toString());\n  }\n  // accessors for the instance variables\n  public Address getFP() { return raw_fp; }\n  public Address getSP() { return raw_sp; }\n  public Address getID() { return raw_sp; }\n  // FIXME: not implemented yet (should be done for Solaris/X86)\n  public boolean isSignalHandlerFrameDbg() { return false; }\n  public int     getSignalNumberDbg()      { return 0;     }\n  public String  getSignalNameDbg()        { return null;  }\n  public boolean isInterpretedFrameValid() {\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(isInterpretedFrame(), \"Not an interpreted frame\");\n    }\n    // These are reasonable sanity checks\n    if (getFP() == null || getFP().andWithMask(0x3) != null) {\n      return false;\n    }\n    if (getSP() == null || getSP().andWithMask(0x3) != null) {\n      return false;\n    }\n    if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {\n      return false;\n    }\n    // These are hacks to keep us out of trouble.\n    // The problem with these is that they mask other problems\n    if (getFP().lessThanOrEqual(getSP())) {\n      // this attempts to deal with unsigned comparison above\n      return false;\n    }\n    if (getFP().minus(getSP()) > 4096 * VM.getVM().getAddressSize()) {\n      // stack frames shouldn't be large.\n      return false;\n    }\n    return true;\n  }\n  // FIXME: not applicable in current system\n  //  void    patch_pc(Thread* thread, address pc);\n  public Frame sender(RegisterMap regMap, CodeBlob cb) {\n    X86RegisterMap map = (X86RegisterMap) regMap;\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(map != null, \"map must be set\");\n    }\n    // Default is we done have to follow them. The sender_for_xxx will\n    // update it accordingly\n    map.setIncludeArgumentOops(false);\n    if (isEntryFrame())       return senderForEntryFrame(map);\n    if (isInterpretedFrame()) return senderForInterpreterFrame(map);\n    if(cb == null) {\n      cb = VM.getVM().getCodeCache().findBlob(getPC());\n    } else {\n      if (Assert.ASSERTS_ENABLED) {\n        Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), \"Must be the same\");\n      }\n    }\n    if (cb != null) {\n      return senderForCompiledFrame(map, cb);\n    }\n    // Must be native-compiled frame, i.e. the marshaling code for native\n    // methods that exists in the core system.\n    return new X86Frame(getSenderSP(), getLink(), getSenderPC());\n  }\n  private Frame senderForEntryFrame(X86RegisterMap map) {\n    if (DEBUG) {\n      System.out.println(\"senderForEntryFrame\");\n    }\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(map != null, \"map must be set\");\n    }\n    // Java frame called from C; skip all C frames and return top C\n    // frame of that chunk as the sender\n    X86JavaCallWrapper jcw = (X86JavaCallWrapper) getEntryFrameCallWrapper();\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(!entryFrameIsFirst(), \"next Java fp must be non zero\");\n      Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), \"must be above this frame on stack\");\n    }\n    X86Frame fr;\n    if (jcw.getLastJavaPC() != null) {\n      fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());\n    } else {\n      fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());\n    }\n    map.clear();\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n    }\n    return fr;\n  }\n  //------------------------------------------------------------------------------\n  // frame::adjust_unextended_sp\n  private void adjustUnextendedSP() {\n    // On x86, sites calling method handle intrinsics and lambda forms are treated\n    // as any other call site. Therefore, no special action is needed when we are\n    // returning to any of these call sites.\n    CodeBlob cb = cb();\n    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n    if (senderNm != null) {\n      // If the sender PC is a deoptimization point, get the original PC.\n      if (senderNm.isDeoptEntry(getPC()) ||\n          senderNm.isDeoptMhEntry(getPC())) {\n        // DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n      }\n    }\n  }\n<fim_suffix>  private Frame senderForInterpreterFrame(X86RegisterMap map) {\n    if (DEBUG) {\n      System.out.println(\"senderForInterpreterFrame\");\n    }\n    Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);\n    Address sp = addressOfStackSlot(SENDER_SP_OFFSET);\n    // We do not need to update the callee-save register mapping because above\n    // us is either another interpreter frame or a converter-frame, but never\n    // directly a compiled frame.\n    // 11/24/04 SFG. With the removal of adapter frames this is no longer true.\n    // However c2 no longer uses callee save register for java calls so there\n    // are no callee register to find.\n    if (map.getUpdateMap())\n      updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));\n    return new X86Frame(sp, unextendedSP, getLink(), getSenderPC());\n  }<fim_middle>// function below has no smell\n"}