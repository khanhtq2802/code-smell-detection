{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.gpu;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.util.StringUtils;\nimport org.apache.hadoop.yarn.api.records.ContainerId;\nimport org.apache.hadoop.yarn.exceptions.YarnException;\nimport org.apache.hadoop.yarn.server.nodemanager.Context;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.container.Container;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.privileged.PrivilegedOperation;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.privileged.PrivilegedOperationException;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.privileged.PrivilegedOperationExecutor;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.CGroupsHandler;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.ResourceHandler;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.ResourceHandlerException;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.runtime.DockerLinuxContainerRuntime;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.gpu.GpuDevice;\nimport org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.gpu.GpuDiscoverer;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n<fim_suffix>public class GpuResourceHandlerImpl implements ResourceHandler {\n  final static Logger LOG = LoggerFactory\n      .getLogger(GpuResourceHandlerImpl.class);\n\n  // This will be used by container-executor to add necessary clis\n  public static final String EXCLUDED_GPUS_CLI_OPTION = \"--excluded_gpus\";\n  public static final String CONTAINER_ID_CLI_OPTION = \"--container_id\";\n\n  private final Context nmContext;\n  private final GpuResourceAllocator gpuAllocator;\n  private final CGroupsHandler cGroupsHandler;\n  private final PrivilegedOperationExecutor privilegedOperationExecutor;\n  private final GpuDiscoverer gpuDiscoverer;\n\n  public GpuResourceHandlerImpl(Context nmContext,\n      CGroupsHandler cGroupsHandler,\n      PrivilegedOperationExecutor privilegedOperationExecutor,\n      GpuDiscoverer gpuDiscoverer) {\n    this.nmContext = nmContext;\n    this.cGroupsHandler = cGroupsHandler;\n    this.privilegedOperationExecutor = privilegedOperationExecutor;\n    this.gpuAllocator = new GpuResourceAllocator(nmContext);\n    this.gpuDiscoverer = gpuDiscoverer;\n  }\n\n  @Override\n  public List<PrivilegedOperation> bootstrap(Configuration configuration)\n      throws ResourceHandlerException {\n    List<GpuDevice> usableGpus;\n    try {\n      usableGpus = gpuDiscoverer.getGpusUsableByYarn();\n      if (usableGpus == null || usableGpus.isEmpty()) {\n        String message = \"GPU is enabled on the NodeManager, but couldn't find \"\n            + \"any usable GPU devices, please double check configuration!\";\n        LOG.error(message);\n        throw new ResourceHandlerException(message);\n      }\n    } catch (YarnException e) {\n      LOG.error(\"Exception when trying to get usable GPU device\", e);\n      throw new ResourceHandlerException(e);\n    }\n\n    for (GpuDevice gpu : usableGpus) {\n      gpuAllocator.addGpu(gpu);\n    }\n\n    // And initialize cgroups\n    this.cGroupsHandler.initializeCGroupController(\n        CGroupsHandler.CGroupController.DEVICES);\n\n    return null;\n  }\n\n  @Override\n  public synchronized List<PrivilegedOperation> preStart(Container container)\n      throws ResourceHandlerException {\n    String containerIdStr = container.getContainerId().toString();\n\n    // Assign Gpus to container if requested some.\n    GpuResourceAllocator.GpuAllocation allocation = gpuAllocator.assignGpus(\n        container);\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerIdStr);\n    if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n        nmContext.getConf(),\n        container.getLaunchContext().getEnvironment())) {\n      // Write to devices cgroup only for non-docker container. The reason is\n      // docker engine runtime runc do the devices cgroups initialize in the\n      // pre-hook, see:\n      //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n      //\n      // YARN by default runs docker container inside cgroup, if we setup cgroups\n      // devices.deny for the parent cgroup for launched container, we can see\n      // errors like: failed to write c *:* m to devices.allow:\n      // write path-to-parent-cgroup/<container-id>/devices.allow:\n      // operation not permitted.\n      //\n      // To avoid this happen, if docker is requested when container being\n      // launched, we will not setup devices.deny for the container. Instead YARN\n      // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n      try {\n        // Execute c-e to setup GPU isolation before launch the container\n        PrivilegedOperation privilegedOperation = new PrivilegedOperation(\n            PrivilegedOperation.OperationType.GPU,\n            Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n        if (!allocation.getDeniedGPUs().isEmpty()) {\n          List<Integer> minorNumbers = new ArrayList<>();\n          for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n            minorNumbers.add(deniedGpu.getMinorNumber());\n          }\n          privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n              StringUtils.join(\",\", minorNumbers)));\n        }\n\n        privilegedOperationExecutor.executePrivilegedOperation(\n            privilegedOperation, true);\n      } catch (PrivilegedOperationException e) {\n        cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n            containerIdStr);\n        LOG.warn(\"Could not update cgroup for container\", e);\n        throw new ResourceHandlerException(e);\n      }\n\n      List<PrivilegedOperation> ret = new ArrayList<>();\n      ret.add(new PrivilegedOperation(\n          PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n          PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n              .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                  containerIdStr)));\n\n      return ret;\n    }\n    return null;\n  }\n\n  public GpuResourceAllocator getGpuAllocator() {\n    return gpuAllocator;\n  }\n\n  @Override\n  public List<PrivilegedOperation> reacquireContainer(ContainerId containerId)\n      throws ResourceHandlerException {\n    gpuAllocator.recoverAssignedGpus(containerId);\n    return null;\n  }\n\n  @Override\n  public List<PrivilegedOperation> updateContainer(Container container)\n      throws ResourceHandlerException {\n    return null;\n  }\n\n  @Override\n  public synchronized List<PrivilegedOperation> postComplete(\n      ContainerId containerId) throws ResourceHandlerException {\n    gpuAllocator.cleanupAssignGpus(containerId);\n    cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerId.toString());\n    return null;\n  }\n\n  @Override\n  public List<PrivilegedOperation> teardown() throws ResourceHandlerException {\n    return null;\n  }\n\n  @Override\n  public String toString() {\n    return GpuResourceHandlerImpl.class.getName() + \"{\" +\n        \"gpuAllocator=\" + gpuAllocator +\n        '}';\n  }\n}<fim_middle>// class below has no smell\n"}