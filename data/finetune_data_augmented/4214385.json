{"text": "<fim_prefix>     * we could do something more type-safe than Object, and so we could\n     * return primitive types without having to enclose them in their\n     * object wrappers. BSF does not currently support that concept.\n     */\n    public Object eval (String source, int lineNo, int columnNo,\n                    Object script)\n    throws BSFException\n    {\n        return execEvalShared(source, lineNo, columnNo, script,true);\n    }\n    /**\n     * Override impl of execute. In NetRexx, methods which do not wish\n     * to return a value should be invoked via exec, which will cause them\n     * to be generated without the \"returns\" clause.\n     * Those which wish to return a value should call eval instead.\n     * which will add \"returns java.lang.Object\" to the header.\n     */\n    public void exec (String source, int lineNo, int columnNo,\n                  Object script)\n    throws BSFException\n    {\n         execEvalShared(source, lineNo, columnNo, script,false);\n    }\n    /**\n     * This is shared code for the exec() and eval() operations. It will\n     * evaluate a string containing a NetRexx method body -- which may be\n     * as simple as a single return statement.\n     * It should store the \"bsf\" handle where the\n     * script can get to it, for callback purposes.\n     * <p>\n     * Note that NetRexx compilation imposes serious overhead -- 11 seconds for\n     * the first compile, about 3 thereafter -- but in exchange you get\n     * Java-like speeds once the classes have been created (minus the cache\n     * lookup cost).\n     * <p>\n     * Nobody knows whether javac is threadsafe.\n     * I'm going to serialize access to the compilers to protect it.\n     */\n    public Object execEvalShared (String source, int lineNo, int columnNo,\n                              Object oscript,boolean returnsObject)\n    throws BSFException\n    {\n        Object retval=null;\n        String classname=null;\n        GeneratedFile gf=null;\n        // Moved into the exec process; see comment above.\n        Class rexxclass=null;\n        String basescript=oscript.toString();\n        String script=basescript; // May be altered by $$CLASSNAME$$ expansion\n        try {\n                    // Do we already have a class exactly matching this code?\n                    rexxclass=(Class)codeToClass.get(basescript);\n                    if(rexxclass!=null)\n            {\n                            logger.debug(\"NetRexxEngine: Found pre-compiled class\" +\n                                                   \" for script '\" + basescript + \"'\");\n                            classname=rexxclass.getName();\n            }\n                    else\n            {\n                            gf=openUniqueFile(tempDir,\"BSFNetRexx\",\".nrx\");\n                            if(gf==null)\n                                throw new BSFException(\"couldn't create NetRexx scratchfile\");\n                            // Obtain classname\n                            classname=gf.className;\n                            // Decide whether to declare a return type\n                            String returnsDecl=\"\";\n                            if(returnsObject)\n                                returnsDecl=\"returns java.lang.Object\";\n                            // Write the kluge header to the file.\n                            // ***** By doing so we give up the ability to use Property blocks.\n                            gf.fos.write((\"class \"+classname+\";\\n\")\n                                         .getBytes());\n                            gf.fos.write(\n                                         (\"method BSFNetRexxEngineEntry(bsf=org.apache.bsf.util.BSFFunctions) \"+\n                                          \" public static \"+returnsDecl+\";\\n\")\n                                 .getBytes());\n                            // Edit the script to replace placeholder with the generated\n                            // classname. Note that this occurs _after_ the cache was\n                            // checked!\n                            int startpoint,endpoint;\n                            if((startpoint=script.indexOf(placeholder))>=0)\n                {\n                                    StringBuffer changed=new StringBuffer();\n                                    for(;\n                                        startpoint>=0;\n                                        startpoint=script.indexOf(placeholder,startpoint))\n                    {\n                                            changed.setLength(0);   // Reset for 2nd pass or later\n                                            if(startpoint>0)\n                                                changed.append(script.substring(0,startpoint));\n                                            changed.append(classname);\n                                            endpoint=startpoint+placeholder.length();\n                                            if(endpoint<script.length())\n                                                changed.append(script.substring(endpoint));\n                                            script=changed.toString();\n                    }\n                }\n                            BSFDeclaredBean tempBean;\n                            String          className;\n                            for (int i = 0; i < declaredBeans.size (); i++)\n                {\n                                    tempBean  = (BSFDeclaredBean) declaredBeans.elementAt (i);\n                                    className = StringUtils.getClassName (tempBean.type);\n                                    gf.fos.write ((tempBean.name + \" =\" + className + \"   bsf.lookupBean(\\\"\" +\n                                                   tempBean.name + \"\\\");\").getBytes());\n                }\n                            if(returnsObject)\n                                gf.fos.write(\"return \".getBytes());\n                            // Copy the input to the file.\n                            // Assumes all available -- probably mistake, but same as\n                            // other engines.\n                            gf.fos.write(script.getBytes());\n                            gf.fos.close();\n                            logger.debug(\"NetRexxEngine: wrote temp file \" +\n                                                   gf.file.getPath () + \", now compiling\");\n                            // Compile through Java to .class file\n                    String command=gf.file.getPath(); //classname;\n                    if (logger.isDebugEnabled()) {\n                        command += \" -verbose4\";\n                    } else {\n                        command += \" -noverbose\";\n                        command += \" -noconsole\";\n                    }\n                    netrexx.lang.Rexx cmdline= new netrexx.lang.Rexx(command);\n                    int retValue;\n                    // May not be threadsafe. Serialize access on static object:\n                    synchronized(serializeCompilation)\n                        {\n                            // compile to a .java file\n                            retValue =\n                                COM.ibm.netrexx.process.NetRexxC.main(cmdline,\n                                                                      new PrintWriter(System.err));\n                        }\n                // Check if there were errors while compiling the Rexx code.\n                if (retValue == 2)\n                {\n                  throw new BSFException(BSFException.REASON_EXECUTION_ERROR,\n                                         \"There were NetRexx errors.\");\n                }\n                // Load class.\n                logger.debug(\"NetRexxEngine: loading class \"+classname);\n                rexxclass=EngineUtils.loadClass (mgr, classname);\n                // Stash class for reuse\n                codeToClass.put(basescript,rexxclass);\n                        }\n            Object[] args={mgrfuncs};\n            retval=callStatic(rexxclass, \"BSFNetRexxEngineEntry\",args);\n                }\n                catch (BSFException e)\n                    {\n                        // Just forward the exception on.\n                        throw e;\n                    }\n                catch(Exception e)\n                    {\n            e.printStackTrace ();\n            if (e instanceof InvocationTargetException)\n            {\n                Throwable t = ((InvocationTargetException)e).getTargetException ();\n                t.printStackTrace ();\n            }\n            throw new BSFException (BSFException.REASON_IO_ERROR,\n                                    e.getMessage (), e);\n        }\n        finally\n        {\n            // Cleanup: delete the .nrx and .class files\n            // (if any) generated by NetRexx Trace requests.\n            if(gf!=null && gf.file!=null && gf.file.exists())\n                gf.file.delete();  // .nrx file\n            if(classname!=null)\n            {\n                // Generated src\n                File file=new File(tempDir+File.separatorChar+classname+\".java\");\n                if(file.exists())\n                    file.delete();\n                // Generated class\n                file=new File(classname+\".class\");\n                if(file.exists())\n                    file.delete();\n                // Can this be done without disrupting trace?\n                file=new File(tempDir+File.separatorChar+classname+\".crossref\");\n                if(file.exists())\n                    file.delete();\n                // Search for and clean up minor classes, classname$xxx.class\n                file=new File(tempDir);\n                minorPrefix=classname+\"$\"; // Indirect arg to filter\n                String[] minor_classfiles=\n                    file.list(\n                        // ANONYMOUS CLASS for filter:\n                        new FilenameFilter()\n                        {\n                            // Starts with classname$ and ends with .class\n                            public boolean accept(File dir,String name)\n                            {\n                                return\n                                    (0==name.indexOf(minorPrefix))\n                                    &&\n                                    (name.lastIndexOf(\".class\")==name.length()-6)\n                                    ;\n                            }\n                        }\n                        );\n                if(minor_classfiles!=null)\n                    for(int i=minor_classfiles.length;i>0;)\n                    {\n                        file=new File(minor_classfiles[--i]);\n                        file.delete();\n                    }\n            }\n        }\n        return retval;\n    }\n<fim_suffix>    public void initialize(BSFManager mgr, String lang,Vector declaredBeans)\n    throws BSFException\n    {\n        super.initialize(mgr, lang, declaredBeans);\n        mgrfuncs = new BSFFunctions (mgr, this);\n    }<fim_middle>// function below has no smell\n"}