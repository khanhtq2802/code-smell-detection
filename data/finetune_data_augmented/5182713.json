{"text": "<fim_prefix>\n<fim_suffix>public class ModelDataGenerator {\n    private static final Logger logger = LoggerFactory.getLogger(ModelDataGenerator.class);\n    final private DataModelDesc model;\n    final private int targetRows;\n    final private ResourceStore outputStore;\n    final private String outputPath;\n    boolean outprint = false; // for debug\n    public ModelDataGenerator(DataModelDesc model, int nRows) {\n        this(model, nRows, ResourceStore.getStore(model.getConfig()));\n    }\n    private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore) {\n        this(model, nRows, outputStore, \"/data\");\n    }\n    private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore, String outputPath) {\n        this.model = model;\n        this.targetRows = nRows;\n        this.outputStore = outputStore;\n        this.outputPath = outputPath;\n    }\n    public void generate() throws IOException {\n        Set<TableDesc> generated = new HashSet<>();\n        Set<TableDesc> allTableDesc = new LinkedHashSet<>();\n        JoinTableDesc[] allTables = model.getJoinTables();\n        for (int i = allTables.length - 1; i >= -1; i--) { // reverse order needed for FK generation\n            TableDesc table = (i == -1) ? model.getRootFactTable().getTableDesc()\n                    : allTables[i].getTableRef().getTableDesc();\n            allTableDesc.add(table);\n            if (generated.contains(table))\n                continue;\n            logger.info(String.format(Locale.ROOT, \"generating data for %s\", table));\n            boolean gen = generateTable(table);\n            if (gen)\n                generated.add(table);\n        }\n        generateDDL(allTableDesc);\n    }\n    private boolean generateTable(TableDesc table) throws IOException {\n        TableGenConfig config = new TableGenConfig(table, this);\n        if (!config.needGen)\n            return false;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));\n        generateTableInternal(table, config, pout);\n        pout.close();\n        bout.close();\n        saveResource(bout.toByteArray(), path(table));\n        return true;\n    }\n    private void generateTableInternal(TableDesc table, TableGenConfig config, PrintWriter out) throws IOException {\n        ColumnDesc[] columns = table.getColumns();\n        ColumnGenerator[] colGens = new ColumnGenerator[columns.length];\n        Iterator<String>[] colIters = new Iterator[columns.length];\n        // config.rows is either a multiplier (0,1] or an absolute row number\n        int tableRows = (int) ((config.rows > 1) ? config.rows : targetRows * config.rows);\n        tableRows = Math.max(1, tableRows);\n        // same seed for all columns, to ensure composite FK columns generate correct pairs\n        long seed = System.currentTimeMillis();\n        for (int i = 0; i < columns.length; i++) {\n            colGens[i] = new ColumnGenerator(columns[i], tableRows, this);\n            colIters[i] = colGens[i].generate(seed);\n        }\n        for (int i = 0; i < tableRows; i++) {\n            for (int c = 0; c < columns.length; c++) {\n                if (c > 0)\n                    out.print(\",\");\n                String v = colIters[c].next();\n                Preconditions.checkState(v == null || !v.contains(\",\"));\n                out.print(v);\n            }\n            out.print(\"\\n\");\n        }\n    }\n    private void generateDDL(Set<TableDesc> tables) throws IOException {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));\n        generateDatabaseDDL(tables, pout);\n        generateCreateTableDDL(tables, pout);\n        generateLoadDataDDL(tables, pout);\n        pout.close();\n        bout.close();\n        saveResource(bout.toByteArray(), path(model));\n    }\n    private void generateDatabaseDDL(Set<TableDesc> tables, PrintWriter out) {\n        Set<String> dbs = new HashSet<>();\n        for (TableDesc t : tables) {\n            String db = t.getDatabase();\n            if (StringUtils.isBlank(db) == false && \"DEFAULT\".equals(db) == false)\n                dbs.add(db);\n        }\n        for (String db : dbs) {\n            out.print(\"CREATE DATABASE IF NOT EXISTS \" + normHiveIdentifier(db) + \";\\n\");\n        }\n        out.print(\"\\n\");\n    }\n    private void generateCreateTableDDL(Set<TableDesc> tables, PrintWriter out) {\n        for (TableDesc t : tables) {\n            if (t.isView())\n                continue;\n            out.print(\"DROP TABLE IF EXISTS \" + normHiveIdentifier(t.getIdentity()) + \";\\n\");\n            out.print(\"CREATE TABLE \" + normHiveIdentifier(t.getIdentity()) + \"(\" + \"\\n\");\n            for (int i = 0; i < t.getColumns().length; i++) {\n                ColumnDesc col = t.getColumns()[i];\n                out.print(\"    \");\n                if (i > 0) {\n                    out.print(\",\");\n                }\n                out.print(normHiveIdentifier(col.getName()) + \" \" + hiveType(col.getType()) + \"\\n\");\n            }\n            out.print(\")\" + \"\\n\");\n            out.print(\"ROW FORMAT DELIMITED FIELDS TERMINATED BY ','\" + \"\\n\");\n            out.print(\"STORED AS TEXTFILE\" + \";\\n\");\n            out.print(\"\\n\");\n        }\n    }\n    private String normHiveIdentifier(String orig) {\n        return \"`\" + orig + \"`\";\n    }\n    private String hiveType(DataType type) {\n        String t = type.toString();\n        if (t.startsWith(\"varchar\"))\n            return \"string\";\n        else if (t.startsWith(\"integer\"))\n            return \"int\";\n        else\n            return t;\n    }\n    private void generateLoadDataDDL(Set<TableDesc> tables, PrintWriter out) {\n        for (TableDesc t : tables) {\n            if (t.isView()) {\n                out.print(\"-- \" + t.getIdentity() + \" is view \\n\");\n                continue;\n            }\n            out.print(\"LOAD DATA LOCAL INPATH '\" + t.getIdentity() + \".csv' OVERWRITE INTO TABLE \"\n                    + normHiveIdentifier(t.getIdentity()) + \";\\n\");\n        }\n    }\n    public boolean existsInStore(TableDesc table) throws IOException {\n        return outputStore.exists(path(table));\n    }\n    public boolean isPK(ColumnDesc col) {\n        for (JoinTableDesc joinTable : model.getJoinTables()) {\n            JoinDesc join = joinTable.getJoin();\n            for (TblColRef pk : join.getPrimaryKeyColumns()) {\n                if (pk.getColumnDesc().equals(col))\n                    return true;\n            }\n        }\n        return false;\n    }\n    public List<String> getPkValuesIfIsFk(ColumnDesc fk) throws IOException {\n        JoinTableDesc[] joinTables = model.getJoinTables();\n        for (int i = 0; i < joinTables.length; i++) {\n            JoinTableDesc joinTable = joinTables[i];\n            ColumnDesc pk = findPk(joinTable, fk);\n            if (pk == null)\n                continue;\n            List<String> pkValues = getPkValues(pk);\n            if (pkValues != null)\n                return pkValues;\n        }\n        return null;\n    }\n    private ColumnDesc findPk(JoinTableDesc joinTable, ColumnDesc fk) {\n        TblColRef[] fkCols = joinTable.getJoin().getForeignKeyColumns();\n        for (int i = 0; i < fkCols.length; i++) {\n            if (fkCols[i].getColumnDesc().equals(fk))\n                return joinTable.getJoin().getPrimaryKeyColumns()[i].getColumnDesc();\n        }\n        return null;\n    }\n    public List<String> getPkValues(ColumnDesc pk) throws IOException {\n        if (existsInStore(pk.getTable()) == false)\n            return null;\n        List<String> r = new ArrayList<>();\n        BufferedReader in = new BufferedReader(\n                new InputStreamReader(outputStore.getResource(path(pk.getTable())).content(), \"UTF-8\"));\n        try {\n            String line;\n            while ((line = in.readLine()) != null) {\n                r.add(line.split(\",\")[pk.getZeroBasedIndex()]);\n            }\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return r;\n    }\n    private void saveResource(byte[] content, String path) throws IOException {\n        System.out.println(\"Generated \" + outputStore.getReadableResourcePath(path));\n        if (outprint) {\n            System.out.println(Bytes.toString(content));\n        }\n        outputStore.putResource(path, new ByteArrayInputStream(content), System.currentTimeMillis());\n    }<fim_middle>// class below is blob\n"}