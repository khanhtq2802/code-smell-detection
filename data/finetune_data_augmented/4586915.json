{"text": "<fim_prefix>            }\n            public boolean isCollapseOuter() {\n                return false;\n            }\n            public Color getColor() {\n                throw new UnsupportedOperationException();\n            }\n            public int getStyle() {\n                throw new UnsupportedOperationException();\n            }\n            public boolean isSpecified() {\n                return false;\n            }\n        }\n    }\n    private double[] getCornerBorderJoinMetrics(double ellipseCenterX, double ellipseCenterY, double xWidth,\n            double yWidth) {\n        if (xWidth > 0) {\n            return getCornerBorderJoinMetrics(ellipseCenterX, ellipseCenterY, yWidth / xWidth);\n        } else {\n            return new double[]{0, ellipseCenterY, 0};\n        }\n    }\n    private double[] getCornerBorderJoinMetrics(double ellipseCenterX, double ellipseCenterY,\n            double borderWidthRatio) {\n        double x = ellipseCenterY * ellipseCenterX * (\n                ellipseCenterY + ellipseCenterX * borderWidthRatio\n                - Math.sqrt(2d * ellipseCenterX * ellipseCenterY * borderWidthRatio)\n                ) / (ellipseCenterY * ellipseCenterY\n                        + ellipseCenterX * ellipseCenterX * borderWidthRatio * borderWidthRatio);\n        double y = borderWidthRatio * x;\n        return new double[]{x, y, Math.atan((ellipseCenterY - y) / (ellipseCenterX - x))};\n    }\n    /**\n     * Clip the background to the inner border\n     * @param rect clipping rectangle\n     * @param bpsBefore before border\n     * @param bpsAfter after border\n     * @param bpsStart start border\n     * @param bpsEnd end border\n     * @throws IOException if an I/O error occurs\n     */\n    public void clipBackground(Rectangle rect,\n            BorderProps bpsBefore, BorderProps bpsAfter,\n            BorderProps bpsStart, BorderProps bpsEnd) throws IOException {\n        BorderSegment before = borderSegmentForBefore(bpsBefore);\n        BorderSegment after = borderSegmentForAfter(bpsAfter);\n        BorderSegment start = borderSegmentForStart(bpsStart);\n        BorderSegment end = borderSegmentForEnd(bpsEnd);\n        int startx = rect.x;\n        int starty = rect.y;\n        int width = rect.width;\n        int height = rect.height;\n        double correctionFactor = calculateCornerCorrectionFactor(width + start.getWidth() + end.getWidth(),\n                height + before.getWidth() + after.getWidth(), bpsBefore, bpsAfter, bpsStart, bpsEnd);\n        Corner cornerBeforeEnd = Corner.createBeforeEndCorner(before, end, correctionFactor);\n        Corner cornerEndAfter = Corner.createEndAfterCorner(end, after, correctionFactor);\n        Corner cornerAfterStart = Corner.createAfterStartCorner(after, start, correctionFactor);\n        Corner cornerStartBefore = Corner.createStartBeforeCorner(start, before, correctionFactor);\n        new PathPainter(startx + cornerStartBefore.radiusX, starty)\n                .lineHorizTo(width - cornerStartBefore.radiusX - cornerBeforeEnd.radiusX)\n                .drawCorner(cornerBeforeEnd)\n                .lineVertTo(height - cornerBeforeEnd.radiusY - cornerEndAfter.radiusY)\n                .drawCorner(cornerEndAfter)\n                .lineHorizTo(cornerEndAfter.radiusX + cornerAfterStart.radiusX - width)\n                .drawCorner(cornerAfterStart)\n                .lineVertTo(cornerAfterStart.radiusY + cornerStartBefore.radiusY - height)\n                .drawCorner(cornerStartBefore);\n        clip();\n    }\n    /**\n     * The four corners\n     *      SB - Start-Before\n     *      BE - Before-End\n     *      EA - End-After\n     *      AS - After-Start\n     *\n     * 0 --> x\n     * |\n     * v\n     * y\n     *\n     *  SB      BE\n     *    *----*\n     *    |    |\n     *    |    |\n     *    *----*\n     *  AS      EA\n     *\n     */\n    private enum CornerAngles {\n        /** The before-end angles */\n        BEFORE_END(Math.PI * 3 / 2, 0),\n        /** The end-after angles */\n        END_AFTER(0, Math.PI / 2),\n        /** The after-start angles*/\n        AFTER_START(Math.PI / 2, Math.PI),\n        /** The start-before angles */\n        START_BEFORE(Math.PI, Math.PI * 3 / 2);\n        /** Angle of the start of the corner arch relative to the x-axis in the counter-clockwise direction */\n        private final double start;\n        /** Angle of the end of the corner arch relative to the x-axis in the counter-clockwise direction */\n        private final double end;\n        CornerAngles(double start, double end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n<fim_suffix>    private static final class Corner {\n        private static final Corner SQUARE = new Corner(0, 0, null, 0, 0, 0, 0);\n        /** The radius of the elliptic corner in the x direction */\n        private final int radiusX;\n        /** The radius of the elliptic corner in the y direction */\n        private final int radiusY;\n        /** The start and end angles of the corner ellipse */\n        private final CornerAngles angles;\n        /** The offset in the x direction of the center of the ellipse relative to the starting point */\n        private final int centerX;\n        /** The offset in the y direction of the center of the ellipse relative to the starting point */\n        private final int centerY;\n        /** The value in the x direction that the corner extends relative to the starting point */\n        private final int incrementX;\n        /** The value in the y direction that the corner extends relative to the starting point */\n        private final int incrementY;\n        private Corner(int radiusX, int radiusY, CornerAngles angles, int ellipseOffsetX,\n                int ellipseOffsetY, int incrementX, int incrementY) {\n            this.radiusX = radiusX;\n            this.radiusY = radiusY;\n            this.angles = angles;\n            this.centerX = ellipseOffsetX;\n            this.centerY = ellipseOffsetY;\n            this.incrementX = incrementX;\n            this.incrementY = incrementY;\n        }\n        private static int extentFromRadiusStart(BorderSegment border, double correctionFactor) {\n            return extentFromRadius(border.getRadiusStart(), border, correctionFactor);\n        }\n        private static int extentFromRadiusEnd(BorderSegment border, double correctionFactor) {\n            return extentFromRadius(border.getRadiusEnd(), border, correctionFactor);\n        }\n        private static int extentFromRadius(int radius, BorderSegment border, double correctionFactor) {\n            return Math.max((int) (radius * correctionFactor) - border.getWidth(), 0);\n        }\n        public static Corner createBeforeEndCorner(BorderSegment before, BorderSegment end,\n                double correctionFactor) {\n            int width = end.getRadiusStart();\n            int height = before.getRadiusEnd();\n            if (width == 0 || height == 0) {\n                return SQUARE;\n            }\n            int x = extentFromRadiusStart(end, correctionFactor);\n            int y = extentFromRadiusEnd(before, correctionFactor);\n            return new Corner(x, y, CornerAngles.BEFORE_END, 0, y, x, y);\n        }\n        public static Corner createEndAfterCorner(BorderSegment end, BorderSegment after,\n                double correctionFactor) {\n            int width = end.getRadiusEnd();\n            int height = after.getRadiusStart();\n            if (width == 0 || height == 0) {\n                return SQUARE;\n            }\n            int x = extentFromRadiusEnd(end, correctionFactor);\n            int y = extentFromRadiusStart(after, correctionFactor);\n            return new Corner(x, y, CornerAngles.END_AFTER, -x, 0, -x, y);\n        }\n        public static Corner createAfterStartCorner(BorderSegment after, BorderSegment start,\n                double correctionFactor) {\n            int width = start.getRadiusStart();\n            int height = after.getRadiusEnd();\n            if (width == 0 || height == 0) {\n                return SQUARE;\n            }\n            int x = extentFromRadiusStart(start, correctionFactor);\n            int y = extentFromRadiusEnd(after, correctionFactor);\n            return new Corner(x, y, CornerAngles.AFTER_START, 0, -y, -x, -y);\n        }\n        public static Corner createStartBeforeCorner(BorderSegment start, BorderSegment before,\n                double correctionFactor) {\n            int width = start.getRadiusEnd();\n            int height = before.getRadiusStart();\n            if (width == 0 || height == 0) {\n                return SQUARE;\n            }\n            int x = extentFromRadiusEnd(start, correctionFactor);\n            int y = extentFromRadiusStart(before, correctionFactor);\n            return new Corner(x, y, CornerAngles.START_BEFORE, x, 0, x, -y);\n        }\n    }<fim_middle>// class below has no smell\n"}