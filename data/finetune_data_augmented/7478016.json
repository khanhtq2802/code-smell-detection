{"text": "<fim_prefix>/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * The Universal Permissive License (UPL), Version 1.0\n *\n * Subject to the condition set forth below, permission is hereby granted to any\n * person obtaining a copy of this software, associated documentation and/or\n * data (collectively the \"Software\"), free of charge and under any and all\n * copyright rights in the Software, and any and all patent rights owned or\n * freely licensable by each licensor hereunder covering either (i) the\n * unmodified Software as contributed to or provided by such licensor, or (ii)\n * the Larger Works (as defined below), to deal in both\n *\n * (a) the Software, and\n *\n * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n * one is included with the Software each a \"Larger Work\" to which the Software\n * is contributed by such licensors),\n *\n * without restriction, including without limitation the rights to copy, create\n * derivative works of, display, perform, and distribute the Software and make,\n * use, sell, offer for sale, import, export, have made, and have sold the\n * Software and the Larger Work(s), and to sublicense the foregoing rights on\n * either these or other terms.\n *\n * This license is subject to the following condition:\n *\n * The above copyright notice and either this complete permission notice or at a\n * minimum a reference to the UPL must be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.oracle.truffle.dsl.processor.model;\nimport static com.oracle.truffle.dsl.processor.java.ElementUtils.getAnnotationValue;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.type.TypeMirror;\nimport com.oracle.truffle.api.dsl.Cached;\nimport com.oracle.truffle.api.dsl.Cached.Shared;\nimport com.oracle.truffle.api.dsl.CachedContext;\nimport com.oracle.truffle.api.dsl.CachedLanguage;\nimport com.oracle.truffle.api.library.CachedLibrary;\nimport com.oracle.truffle.dsl.processor.ProcessorContext;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression.Binary;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression.Call;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression.DSLExpressionReducer;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression.Negate;\nimport com.oracle.truffle.dsl.processor.expression.DSLExpression.Variable;\nimport com.oracle.truffle.dsl.processor.java.ElementUtils;\nimport com.oracle.truffle.dsl.processor.java.model.CodeVariableElement;\npublic final class CacheExpression extends MessageContainer {\n    private final Parameter sourceParameter;\n    private final AnnotationMirror sourceAnnotationMirror;\n    private int dimensions = -1;\n    private DSLExpression defaultExpression;\n    private DSLExpression uncachedExpression;\n    private boolean alwaysInitialized = false;\n    private Message uncachedExpressionError;\n    private boolean requiresBoundary;\n    private String sharedGroup;\n    private boolean mergedLibrary;\n    private TypeMirror languageType;\n    private TypeMirror referenceType;\n    public CacheExpression(Parameter sourceParameter, AnnotationMirror sourceAnnotationMirror) {\n        this.sourceParameter = sourceParameter;\n        this.sourceAnnotationMirror = sourceAnnotationMirror;\n    }\n    public CacheExpression copy() {\n        CacheExpression copy = new CacheExpression(sourceParameter, sourceAnnotationMirror);\n        copy.dimensions = this.dimensions;\n        copy.defaultExpression = this.defaultExpression;\n        copy.uncachedExpression = this.uncachedExpression;\n        copy.alwaysInitialized = this.alwaysInitialized;\n        copy.sharedGroup = this.sharedGroup;\n        return copy;\n    }\n    public void setLanguageType(TypeMirror languageType) {\n        this.languageType = languageType;\n    }\n<fim_suffix>    public boolean isReference() {\n        if (isCachedLanguage()) {\n            return !ElementUtils.typeEquals(getLanguageType(), getParameter().getType());\n        } else {\n            return ElementUtils.typeEquals(getReferenceType(), getParameter().getType());\n        }\n    }\n    public TypeMirror getReferenceType() {\n        return referenceType;\n    }\n    public void setReferenceType(TypeMirror supplierType) {\n        this.referenceType = supplierType;\n    }\n    public TypeMirror getLanguageType() {\n        return languageType;\n    }\n    public void setSharedGroup(String sharedGroup) {\n        this.sharedGroup = sharedGroup;\n    }\n    public AnnotationMirror getSharedGroupMirror() {\n        return ElementUtils.findAnnotationMirror(sourceParameter.getVariableElement(), Shared.class);\n    }\n    public AnnotationValue getSharedGroupValue() {\n        AnnotationMirror sharedAnnotation = getSharedGroupMirror();\n        if (sharedAnnotation != null) {\n            return getAnnotationValue(sharedAnnotation, \"value\");\n        }\n        return null;\n    }\n    public String getSharedGroup() {\n        AnnotationMirror sharedAnnotation = getSharedGroupMirror();\n        if (sharedAnnotation != null) {\n            return getAnnotationValue(String.class, sharedAnnotation, \"value\");\n        }\n        return null;\n    }\n    public void setDefaultExpression(DSLExpression expression) {\n        this.defaultExpression = expression;\n    }\n    public void setUncachedExpressionError(Message message) {\n        this.uncachedExpressionError = message;\n    }\n    public void setUncachedExpression(DSLExpression getUncachedExpression) {\n        this.uncachedExpression = getUncachedExpression;\n    }\n    public Message getUncachedExpresionError() {\n        return uncachedExpressionError;\n    }\n    public DSLExpression getUncachedExpression() {\n        return uncachedExpression;\n    }\n    public void setAlwaysInitialized(boolean fastPathCache) {\n        this.alwaysInitialized = fastPathCache;\n    }\n    public boolean isAlwaysInitialized() {\n        return alwaysInitialized;\n    }\n    public void setDimensions(int dimensions) {\n        this.dimensions = dimensions;\n    }\n    public int getDimensions() {\n        return dimensions;\n    }\n    public Parameter getParameter() {\n        return sourceParameter;\n    }\n    public boolean isCached() {\n        return isType(Cached.class);\n    }\n    public boolean isCachedLibrary() {\n        return isType(CachedLibrary.class);\n    }\n    public boolean isCachedContext() {\n        return isType(CachedContext.class);\n    }\n    public boolean isCachedLanguage() {\n        return isType(CachedLanguage.class);\n    }\n    private boolean isType(Class<?> type) {\n        return ElementUtils.typeEquals(sourceAnnotationMirror.getAnnotationType(), ProcessorContext.getInstance().getType(type));\n    }\n    @Override\n    public Element getMessageElement() {\n        return sourceParameter.getVariableElement();\n    }\n    @Override\n    public AnnotationMirror getMessageAnnotation() {\n        return sourceAnnotationMirror;\n    }\n    public void setRequiresBoundary(boolean requiresBoundary) {\n        this.requiresBoundary = requiresBoundary;\n    }\n    public boolean isRequiresBoundary() {\n        return requiresBoundary;\n    }\n    public DSLExpression getDefaultExpression() {\n        return defaultExpression;\n    }\n    public void setMergedLibrary(boolean mergedLibrary) {\n        this.mergedLibrary = mergedLibrary;\n    }\n    public boolean isMergedLibrary() {\n        return mergedLibrary;\n    }\n    public String getMergedLibraryIdentifier() {\n        String libraryName = ElementUtils.getSimpleName(getParameter().getType());\n        DSLExpression identifierExpression = getDefaultExpression().reduce(new DSLExpressionReducer() {\n            public DSLExpression visitVariable(Variable binary) {\n                if (binary.getReceiver() == null) {\n                    Variable var = new Variable(binary.getReceiver(), \"receiver\");\n                    var.setResolvedTargetType(binary.getResolvedTargetType());\n                    var.setResolvedVariable(new CodeVariableElement(binary.getResolvedType(), \"receiver\"));\n                    return var;\n                } else {\n                    return binary;\n                }\n            }\n            public DSLExpression visitNegate(Negate negate) {\n                return negate;\n            }\n            public DSLExpression visitCall(Call binary) {\n                return binary;\n            }\n            public DSLExpression visitBinary(Binary binary) {\n                return binary;\n            }\n        });\n        String expressionText = identifierExpression.asString();\n        StringBuilder b = new StringBuilder(expressionText);\n        for (int i = 0; i < b.length(); i++) {<fim_middle>// function below has no smell\n"}