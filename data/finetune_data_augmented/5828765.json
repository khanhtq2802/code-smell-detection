{"text": "<fim_prefix>                                \"        \\\"folding\\\": {\\n\" +\n                                \"          \\\"type\\\":\\\"custom\\\",\\n\" +\n                                \"          \\\"tokenizer\\\": \\\"keyword\\\",\\n\" +\n                                \"          \\\"filter\\\":  [ \\\"lowercase\\\", \\\"asciifolding\\\" ]\\n\" +\n                                \"        }\\n\" +\n                                \"      }\\n\" +\n                                \"    }\\n\" +\n                                \"}\\n\", XContentType.JSON);\n                Map<String, String> indexMappings = new HashMap<String, String>();\n                indexMappings.put(\"_default_\", mappings.get(\"_default_\"));\n                for (Map.Entry<String, String> entry : mappings.entrySet()) {\n                    if (itemsMonthlyIndexed.contains(entry.getKey())) {\n                        indexMappings.put(entry.getKey(), entry.getValue());\n                    }\n                }\n                putIndexTemplateRequest.mappings().putAll(indexMappings);\n                PutIndexTemplateResponse putIndexTemplateResponse = client.admin().indices().putTemplate(putIndexTemplateRequest).actionGet();\n                return putIndexTemplateResponse.isAcknowledged();\n            }\n        }.catchingExecuteInClassLoader(true);\n        if (result == null) {\n            return false;\n        } else {\n            return result;\n        }\n    }\n    public boolean createIndex(final String indexName) {\n        Boolean result = new InClassLoaderExecute<Boolean>(metricsService, this.getClass().getName() + \".createItem\") {\n            protected Boolean execute(Object... args) {\n                IndicesExistsResponse indicesExistsResponse = client.admin().indices().prepareExists(indexName).execute().actionGet();\n                boolean indexExists = indicesExistsResponse.isExists();\n                if (!indexExists) {\n                    Map<String, String> indexMappings = new HashMap<String, String>();\n                    indexMappings.put(\"_default_\", mappings.get(\"_default_\"));\n                    for (Map.Entry<String, String> entry : mappings.entrySet()) {\n                        if (indexNames.containsKey(entry.getKey()) && indexNames.get(entry.getKey()).equals(indexName)) {\n                            indexMappings.put(entry.getKey(), entry.getValue());\n                        }\n                    }\n                    internalCreateIndex(indexName, indexMappings);\n                }\n                return !indexExists;\n            }\n        }.catchingExecuteInClassLoader(true);\n        if (result == null) {\n            return false;\n        } else {\n            return result;\n        }\n    }\n    public boolean removeIndex(final String indexName) {\n        Boolean result = new InClassLoaderExecute<Boolean>(metricsService, this.getClass().getName() + \".removeIndex\") {\n            protected Boolean execute(Object... args) {\n                IndicesExistsResponse indicesExistsResponse = client.admin().indices().prepareExists(indexName).execute().actionGet();\n                boolean indexExists = indicesExistsResponse.isExists();\n                if (indexExists) {\n                    client.admin().indices().prepareDelete(indexName).execute().actionGet();\n                }\n                return indexExists;\n            }\n        }.catchingExecuteInClassLoader(true);\n        if (result == null) {\n            return false;\n        } else {\n            return result;\n        }\n    }\n    private void internalCreateIndex(String indexName, Map<String, String> mappings) {\n        CreateIndexRequestBuilder builder = client.admin().indices().prepareCreate(indexName)\n                .setSettings(\"{\\n\" +\n                        \"    \\\"index\\\" : {\\n\" +\n                        \"        \\\"number_of_shards\\\" : \" + numberOfShards + \",\\n\" +\n                        \"        \\\"number_of_replicas\\\" : \" + numberOfReplicas + \"\\n\" +\n                        \"    },\\n\" +\n                        \"    \\\"analysis\\\": {\\n\" +\n                        \"      \\\"analyzer\\\": {\\n\" +\n                        \"        \\\"folding\\\": {\\n\" +\n                        \"          \\\"type\\\":\\\"custom\\\",\\n\" +\n                        \"          \\\"tokenizer\\\": \\\"keyword\\\",\\n\" +\n                        \"          \\\"filter\\\":  [ \\\"lowercase\\\", \\\"asciifolding\\\" ]\\n\" +\n                        \"        }\\n\" +\n                        \"      }\\n\" +\n                        \"    }\\n\" +\n                        \"}\\n\", XContentType.JSON);\n        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n            builder.addMapping(entry.getKey(), entry.getValue(), XContentType.JSON);\n        }\n        builder.execute().actionGet();\n    }\n    private void createMapping(final String type, final String source, final String indexName) {\n        client.admin().indices()\n                .preparePutMapping(indexName)\n                .setType(type)\n                .setSource(source, XContentType.JSON)\n                .execute().actionGet();\n    }\n    @Override\n    public void createMapping(String type, String source) {\n        if (type.equals(\"_default_\")) {\n            return;\n        }\n        if (itemsMonthlyIndexed.contains(type)) {\n            createMonthlyIndexTemplate();\n            if (client.admin().indices().prepareExists(indexName + \"-*\").execute().actionGet().isExists()) {\n                createMapping(type, source, indexName + \"-*\");\n            }\n        } else if (indexNames.containsKey(type)) {\n            if (client.admin().indices().prepareExists(indexNames.get(type)).execute().actionGet().isExists()) {\n                createMapping(type, source, indexNames.get(type));\n            }\n        } else {\n            createMapping(type, source, indexName);\n        }\n    }\n    @Override\n    public Map<String, Map<String, Object>> getPropertiesMapping(final String itemType) {\n        return new InClassLoaderExecute<Map<String, Map<String, Object>>>(metricsService, this.getClass().getName() + \".getPropertiesMapping\") {\n            @SuppressWarnings(\"unchecked\")\n            protected Map<String, Map<String, Object>> execute(Object... args) throws Exception {\n                // Get all mapping for current itemType\n                GetMappingsResponse getMappingsResponse = client.admin().indices().prepareGetMappings().setTypes(itemType).execute().actionGet();\n                ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getMappingsResponse.getMappings();\n                // create a list of Keys to get the mappings in chronological order\n                // in case there is monthly context then the mapping will be added from the oldest to the most recent one\n                Set<String> orderedKeys = new TreeSet<>(Arrays.asList(mappings.keys().toArray(String.class)));\n                Map<String, Map<String, Object>> result = new HashMap<>();\n                try {\n                    for (String key : orderedKeys) {\n                        if (mappings.containsKey(key)) {\n                            ImmutableOpenMap<String, MappingMetaData> next = mappings.get(key);\n                            Map<String, Map<String, Object>> properties = (Map<String, Map<String, Object>>) next.get(itemType).getSourceAsMap().get(\"properties\");\n                            for (Map.Entry<String, Map<String, Object>> entry : properties.entrySet()) {\n                                if (result.containsKey(entry.getKey())) {\n                                    Map<String, Object> subResult = result.get(entry.getKey());\n                                    for (Map.Entry<String, Object> subentry : entry.getValue().entrySet()) {\n                                        if (subResult.containsKey(subentry.getKey())\n                                            && subResult.get(subentry.getKey()) instanceof Map\n                                            && subentry.getValue() instanceof Map) {\n                                            mergePropertiesMapping((Map) subResult.get(subentry.getKey()), (Map) subentry.getValue());\n                                        } else {\n                                            subResult.put(subentry.getKey(), subentry.getValue());\n                                        }\n                                    }\n                                } else {\n                                    result.put(entry.getKey(), entry.getValue());\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable t) {\n                    throw new Exception(\"Cannot get mapping for itemType=\"+ itemType, t);\n                }\n                return result;\n            }\n        }.catchingExecuteInClassLoader(true);\n    }\n    private void mergePropertiesMapping(Map<String, Object> result, Map<String, Object> entry) {\n        for (Map.Entry<String, Object> subentry : entry.entrySet()) {\n            if (result.containsKey(subentry.getKey())\n                    && result.get(subentry.getKey()) instanceof Map\n                    && subentry.getValue() instanceof Map) {\n                mergePropertiesMapping((Map) result.get(subentry.getKey()), (Map) subentry.getValue());\n            } else {\n                result.put(subentry.getKey(), subentry.getValue());\n            }\n        }\n    }\n<fim_suffix>    public Map<String, Object> getPropertyMapping(String property, String itemType) {\n        Map<String, Map<String, Object>> mappings = knownMappings.get(itemType);\n        Map<String, Object> result = getPropertyMapping(property, mappings);\n        if (result == null) {\n            mappings = getPropertiesMapping(itemType);\n            knownMappings.put(itemType, mappings);\n            result = getPropertyMapping(property, mappings);\n        }\n        return result;\n    }<fim_middle>// function below has no smell\n"}