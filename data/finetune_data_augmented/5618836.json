{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.subject;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.StringUtils;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.*;\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @since 0.9\n */\n@SuppressWarnings({\"unchecked\"})\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n    // Serialization reminder:\n    // You _MUST_ change this number if you introduce a change to this class\n    // that is NOT serialization backwards compatible.  Serialization-compatible\n    // changes do not require a change to this number.  If you need to generate\n    // a new number in this case, use the JDK's 'serialver' program to generate it.\n    private static final long serialVersionUID = -6305224034025797558L;\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n    private transient String cachedToString; //cached toString() result, as this can be printed many times in logging\n    public SimplePrincipalCollection() {\n    }\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n    /**\n     * Returns the first available principal from any of the {@code Realm} principals, or {@code null} if there are\n     * no principals yet.\n     * <p/>\n     * The 'first available principal' is interpreted as the principal that would be returned by\n     * <code>{@link #iterator() iterator()}.{@link java.util.Iterator#next() next()}.</code>\n     *\n     * @inheritDoc\n     */\n    public Object getPrimaryPrincipal() {\n        if (isEmpty()) {\n            return null;\n        }\n        return iterator().next();\n    }\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        this.cachedToString = null;\n        getPrincipalsLazy(realmName).add(principal);\n    }\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        this.cachedToString = null;\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n<fim_suffix>    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n    public void clear() {\n        this.cachedToString = null;\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n    /**\n     * Returns a simple string representation suitable for printing.\n     *\n     * @return a simple string representation suitable for printing.\n     * @since 1.0\n     */\n    public String toString() {\n        if (this.cachedToString == null) {\n            Set<Object> principals = asSet();\n            if (!CollectionUtils.isEmpty(principals)) {\n                this.cachedToString = StringUtils.toString(principals.toArray());\n            } else {\n                this.cachedToString = \"empty\";\n            }\n        }\n        return this.cachedToString;\n    }\n    /**\n     * Serialization write support.\n     * <p/>\n     * NOTE: Don't forget to change the serialVersionUID constant at the top of this class\n     * if you make any backwards-incompatible serialization changes!!!\n     * (use the JDK 'serialver' program for this)\n     *\n     * @param out output stream provided by Java serialization\n     * @throws IOException if there is a stream error\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        boolean principalsExist = !CollectionUtils.isEmpty(realmPrincipals);\n        out.writeBoolean(principalsExist);<fim_middle>// function below has no smell\n"}