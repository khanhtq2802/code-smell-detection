{"text": "<fim_prefix>                Path path = getPath(state.getId(), hmgr);\n                events.add(EventState.propertyAdded(state.getParentId(),\n                        getParent(path),\n                        path.getLastElement(),\n                        nodeType.getQName(),\n                        mixins,\n                        session));\n            }\n        }\n    }\n    /**\n     * Adds all event states in the given collection to this collection\n     *\n     * @param c\n     */\n    public void addAll(Collection<EventState> c) {\n        events.addAll(c);\n    }\n    /**\n     * Prepares already added events for dispatching.\n     */\n    public void prepare() {\n        dispatcher.prepareEvents(this);\n    }\n    /**\n     * Prepares deleted items from <code>changes</code>.\n     *\n     * @param changes the changes to prepare.\n     */\n    public void prepareDeleted(ChangeLog changes) {\n        dispatcher.prepareDeleted(this, changes);\n    }\n    /**\n     * Dispatches the events to the {@link javax.jcr.observation.EventListener}s.\n     */\n    public void dispatch() {\n        dispatcher.dispatchEvents(this);\n    }\n    /**\n     * Returns the path prefix for this event state collection or <code>null</code>\n     * if no path prefix was set in the constructor of this collection. See\n     * also {@link EventStateCollection#EventStateCollection}.\n     *\n     * @return the path prefix for this event state collection.\n     */\n    public Path getPathPrefix() {\n        return pathPrefix;\n    }\n    /**\n     * @return the timestamp when this collection was created.\n     */\n    public long getTimestamp() {\n        return timestamp;\n    }\n    /**\n     * Sets a new timestamp for this collection.\n     *\n     * @param timestamp the new timestamp value.\n     */\n    public void setTimestamp(long timestamp) {\n        this.timestamp = timestamp;\n    }\n    /**\n     * Returns an iterator over {@link EventState} instance.\n     *\n     * @return an iterator over {@link EventState} instance.\n     */\n    Iterator<EventState> iterator() {\n        return events.iterator();\n    }\n    /**\n     * Return the list of events.\n     * @return list of events\n     */\n    public List<EventState> getEvents() {\n        return Collections.unmodifiableList(events);\n    }\n    /**\n     * Get the number of events.\n     *\n     * @return the size\n     */\n    public int size() {\n        return events.size();\n    }\n    /**\n     * Return the session who is the origin of this events.\n     * @return event source\n     */\n    public SessionImpl getSession() {\n        return session;\n    }\n    /**\n     * @return the user data attached to this event state collection.\n     */\n    public String getUserData() {\n        return userData;\n    }\n    /**\n     * Sets the user data for this event state collection.\n     *\n     * @param userData the user data.\n     */\n    public void setUserData(String userData) {\n        this.userData = userData;\n    }\n    //----------------------------< internal >----------------------------------\n    private void createShareableNodeEvents(NodeState n,\n                                           ChangeLog changes,\n                                           ChangeLogBasedHierarchyMgr hmgr,\n                                           ItemStateManager stateMgr)\n            throws ItemStateException {\n        if (n.isShareable()) {\n            // check if a share was added or removed\n            for (NodeId parentId : n.getAddedShares()) {\n                // ignore primary parent id\n                if (n.getParentId().equals(parentId)) {\n                    continue;\n                }\n                NodeState parent = (NodeState) changes.get(parentId);\n                if (parent == null) {\n                    // happens when mix:shareable is added to an existing node\n                    // usually the parent node state is in the change log\n                    // when a node is added to a shared set -> new child node\n                    // entry on parent node state.\n                    parent = (NodeState) stateMgr.getItemState(parentId);\n                }\n                Name ntName = getNodeType(parent, session).getQName();\n                EventState es = EventState.childNodeAdded(parentId,\n                        getPath(parentId, hmgr),\n                        n.getNodeId(),\n                        getNameElement(n.getNodeId(), parentId, hmgr),\n                        ntName,\n                        parent.getMixinTypeNames(),\n                        session);\n                es.setShareableNode(true);\n                events.add(es);\n            }\n            for (NodeId parentId : n.getRemovedShares()) {\n                // if this shareable node is removed, only create events for\n                // parent ids that are not primary\n                if (n.getParentId().equals(parentId)) {\n                    continue;\n                }\n                NodeState parent = null;\n                try {\n                    parent = (NodeState) changes.get(parentId);\n                } catch (NoSuchItemStateException e) {\n                    // parent has been removed as well\n                    // ignore and retrieve from stateMgr\n                }\n                if (parent == null) {\n                    // happens when mix:shareable is removed from an existing\n                    // node. Usually the parent node state is in the change log\n                    // when a node is removed to a shared set -> removed child\n                    // node entry on parent node state.\n                    parent = (NodeState) stateMgr.getItemState(parentId);\n                }\n                Name ntName = getNodeType(parent, session).getQName();\n                EventState es = EventState.childNodeRemoved(parentId,\n                        getZombiePath(parentId, hmgr),\n                        n.getNodeId(),\n                        getZombieNameElement(n.getNodeId(), parentId, hmgr),\n                        ntName,\n                        parent.getMixinTypeNames(),\n                        session);\n                es.setShareableNode(true);\n                events.add(es);\n            }\n        }\n    }\n    /**\n     * Resolves the node type name in <code>node</code> into a {@link javax.jcr.nodetype.NodeType}\n     * object using the {@link javax.jcr.nodetype.NodeTypeManager} of <code>session</code>.\n     *\n     * @param node    the node.\n     * @param session the session.\n     * @return the {@link javax.jcr.nodetype.NodeType} of <code>node</code>.\n     * @throws ItemStateException if the nodetype cannot be resolved.\n     */\n    private NodeTypeImpl getNodeType(NodeState node, SessionImpl session)\n            throws ItemStateException {\n        try {\n            return session.getNodeTypeManager().getNodeType(node.getNodeTypeName());\n        } catch (Exception e) {\n            // also catch eventual runtime exceptions here\n            // should never happen actually\n            String msg;\n            if (node == null) {\n                msg = \"Node state is null\";\n            } else {\n                msg = \"Item \" + node.getNodeId() + \" has unknown node type: \" + node.getNodeTypeName();\n            }\n            log.error(msg);\n            throw new ItemStateException(msg, e);\n        }\n    }\n    /**\n     * Returns the path of the parent node of node at <code>path</code>..\n     *\n     * @param p the path.\n     * @return the parent path.\n     * @throws ItemStateException if <code>p</code> does not have a parent\n     *                            path. E.g. <code>p</code> designates root.\n     */\n    private Path getParent(Path p) throws ItemStateException {\n        try {\n            return p.getAncestor(1);\n        } catch (RepositoryException e) {\n            // should never happen actually\n            String msg = \"Unable to resolve parent for path: \" + p;\n            log.error(msg);\n            throw new ItemStateException(msg, e);\n        }\n    }\n    /**\n     * Resolves the path of the Item with id <code>itemId</code>.\n     *\n     * @param itemId the id of the item.\n     * @return the path of the item.\n     * @throws ItemStateException if the path cannot be resolved.\n     */\n    private Path getPath(ItemId itemId, HierarchyManager hmgr)\n            throws ItemStateException {\n        try {\n            return prefixPath(hmgr.getPath(itemId));\n        } catch (RepositoryException e) {\n            // should never happen actually\n            String msg = \"Unable to resolve path for item: \" + itemId;\n            log.error(msg);\n            throw new ItemStateException(msg, e);\n        }\n    }\n    /**\n     * Returns the name element for the node with the given <code>nodeId</code>\n     * and its parent with <code>parentId</code>. This method is only useful\n     * if <code>nodeId</code> denotes a shareable node.\n     *\n     * @param nodeId the node id of a shareable node.\n     * @param parentId the id of the parent node.\n     * @param hmgr the hierarchy manager.\n     * @return the name element for the node.\n     * @throws ItemStateException if an error occurs while resolving the name.\n     */\n<fim_suffix>    private Path getNameElement(\n            NodeId nodeId, NodeId parentId, HierarchyManager hmgr)\n            throws ItemStateException {\n        try {\n            Name name = hmgr.getName(nodeId, parentId);\n            return PathFactoryImpl.getInstance().create(name);\n        } catch (RepositoryException e) {\n            String msg = \"Unable to get name for node with id: \" + nodeId;\n            throw new ItemStateException(msg, e);\n        }\n    }<fim_middle>// function below has no smell\n"}