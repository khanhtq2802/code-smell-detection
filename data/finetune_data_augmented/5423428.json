{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.phoenix.hbase.index.write;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.Stoppable;\nimport org.apache.hadoop.hbase.client.Mutation;\nimport org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\nimport org.apache.hadoop.hbase.util.Pair;\nimport org.apache.phoenix.hbase.index.exception.IndexWriteException;\nimport org.apache.phoenix.hbase.index.table.HTableInterfaceReference;\nimport org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\nimport org.apache.phoenix.index.PhoenixIndexFailurePolicy;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Multimap;\n/**\n * Do the actual work of writing to the index tables. Ensures that if we do fail to write to the\n * index table that we cleanly kill the region/server to ensure that the region's WAL gets replayed.\n * <p>\n * We attempt to do the index updates in parallel using a backing threadpool. All threads are daemon\n * threads, so it will not block the region from shutting down.\n */\npublic class IndexWriter implements Stoppable {\n  private static final Log LOG = LogFactory.getLog(IndexWriter.class);\n  public static final String INDEX_COMMITTER_CONF_KEY = \"index.writer.commiter.class\";\n  public static final String INDEX_FAILURE_POLICY_CONF_KEY = \"index.writer.failurepolicy.class\";\n  private AtomicBoolean stopped = new AtomicBoolean(false);\n  private IndexCommitter writer;\n  private IndexFailurePolicy failurePolicy;\n  /**\n   * @throws IOException if the {@link IndexWriter} or {@link IndexFailurePolicy} cannot be\n   *           instantiated\n   */\n  public IndexWriter(RegionCoprocessorEnvironment env, String name) throws IOException {\n    this(getCommitter(env), getFailurePolicy(env), env, name);\n  }\n  public IndexWriter(IndexFailurePolicy failurePolicy, RegionCoprocessorEnvironment env, String name) throws IOException {\n      this(getCommitter(env), failurePolicy, env, name);\n    }\n  public static IndexCommitter getCommitter(RegionCoprocessorEnvironment env) throws IOException {\n      return getCommitter(env,TrackingParallelWriterIndexCommitter.class);\n  }\n  public static IndexCommitter getCommitter(RegionCoprocessorEnvironment env, Class<? extends IndexCommitter> defaultClass) throws IOException {\n    Configuration conf = env.getConfiguration();\n    try {\n      IndexCommitter committer =\n          conf.getClass(INDEX_COMMITTER_CONF_KEY, defaultClass,\n            IndexCommitter.class).newInstance();\n      return committer;\n    } catch (InstantiationException e) {\n      throw new IOException(e);\n    } catch (IllegalAccessException e) {\n      throw new IOException(e);\n    }\n  }\n<fim_suffix>  public static IndexFailurePolicy getFailurePolicy(RegionCoprocessorEnvironment env)\n      throws IOException {\n    Configuration conf = env.getConfiguration();\n    try {\n      IndexFailurePolicy committer =\n          conf.getClass(INDEX_FAILURE_POLICY_CONF_KEY, PhoenixIndexFailurePolicy.class,\n            IndexFailurePolicy.class).newInstance();\n      return committer;\n    } catch (InstantiationException e) {\n      throw new IOException(e);\n    } catch (IllegalAccessException e) {\n      throw new IOException(e);\n    }\n  }\n  /**\n   * Directly specify the {@link IndexCommitter} and {@link IndexFailurePolicy}. Both are expected\n   * to be fully setup before calling.\n   * @param committer\n   * @param policy\n   * @param env\n   */\n  public IndexWriter(IndexCommitter committer, IndexFailurePolicy policy,\n      RegionCoprocessorEnvironment env, String name) {\n    this(committer, policy);\n    this.writer.setup(this, env, name);\n    this.failurePolicy.setup(this, env);\n  }\n  /**\n   * Create an {@link IndexWriter} with an already setup {@link IndexCommitter} and\n   * {@link IndexFailurePolicy}.\n   * @param committer to write updates\n   * @param policy to handle failures\n   */\n  IndexWriter(IndexCommitter committer, IndexFailurePolicy policy) {\n    this.writer = committer;\n    this.failurePolicy = policy;\n  }\n  /**\n   * Write the mutations to their respective table.\n   * <p>\n   * This method is blocking and could potentially cause the writer to block for a long time as we\n   * write the index updates. When we return depends on the specified {@link IndexCommitter}.\n   * <p>\n   * If update fails, we pass along the failure to the installed {@link IndexFailurePolicy}, which\n   * then decides how to handle the failure. By default, we use a {@link KillServerOnFailurePolicy},\n   * which ensures that the server crashes when an index write fails, ensuring that we get WAL\n   * replay of the index edits.\n   * @param indexUpdates Updates to write\n * @param clientVersion version of the client\n * @throws IOException \n   */\n    public void writeAndKillYourselfOnFailure(Collection<Pair<Mutation, byte[]>> indexUpdates,\n            boolean allowLocalUpdates, int clientVersion) throws IOException {\n    // convert the strings to htableinterfaces to which we can talk and group by TABLE\n    Multimap<HTableInterfaceReference, Mutation> toWrite = resolveTableReferences(indexUpdates);\n    writeAndKillYourselfOnFailure(toWrite, allowLocalUpdates, clientVersion);\n  }\n  /**\n   * see {@link #writeAndKillYourselfOnFailure(Collection)}.\n   * @param toWrite\n * @throws IOException \n   */\n    public void writeAndKillYourselfOnFailure(Multimap<HTableInterfaceReference, Mutation> toWrite,\n            boolean allowLocalUpdates, int clientVersion) throws IOException {\n    try {\n      write(toWrite, allowLocalUpdates, clientVersion);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Done writing all index updates!\\n\\t\" + toWrite);\n      }\n    } catch (Exception e) {\n      this.failurePolicy.handleFailure(toWrite, e);\n    }\n  }\n  /**\n   * Write the mutations to their respective table.\n   * <p>\n   * This method is blocking and could potentially cause the writer to block for a long time as we\n   * write the index updates. We only return when either:\n   * <ol>\n   * <li>All index writes have returned, OR</li>\n   * <li>Any single index write has failed</li>\n   * </ol>\n   * We attempt to quickly determine if any write has failed and not write to the remaining indexes\n   * to ensure a timely recovery of the failed index writes.\n   * @param toWrite Updates to write\n   * @throws IndexWriteException if we cannot successfully write to the index. Whether or not we\n   *           stop early depends on the {@link IndexCommitter}.\n   */\n    public void write(Collection<Pair<Mutation, byte[]>> toWrite, int clientVersion) throws IndexWriteException {\n    \twrite(resolveTableReferences(toWrite), false, clientVersion);\n    }\n    public void write(Collection<Pair<Mutation, byte[]>> toWrite, boolean allowLocalUpdates, int clientVersion) throws IOException {\n    \twrite(resolveTableReferences(toWrite), allowLocalUpdates, clientVersion);\n    }\n    /**\n   * see {@link #write(Collection)}\n   * @param toWrite\n   * @throws IndexWriteException\n   */\n  public void write(Multimap<HTableInterfaceReference, Mutation> toWrite, boolean allowLocalUpdates, int clientVersion)\n\t      throws IndexWriteException {\n\t  this.writer.write(toWrite, allowLocalUpdates, clientVersion);\n  }\n  /**\n   * Convert the passed index updates to {@link HTableInterfaceReference}s.\n   * @param indexUpdates from the index builder\n   * @return pairs that can then be written by an {@link IndexWriter}.\n   */\n  protected Multimap<HTableInterfaceReference, Mutation> resolveTableReferences(\n      Collection<Pair<Mutation, byte[]>> indexUpdates) {\n    Multimap<HTableInterfaceReference, Mutation> updates = ArrayListMultimap<fim_middle>// function below has no smell\n"}