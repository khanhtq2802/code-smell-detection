{"text": "<fim_prefix>  private String datePattern;\n  private int dateStyle = DateFormat.DEFAULT;\n  private int timeStyle = DateFormat.DEFAULT;\n  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\n  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\n  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\n  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;\n  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\n  private boolean lenient = DEFAULT_LENIENT;\n  /**\n   * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n   * settings. GsonBuilder follows the builder pattern, and it is typically used by first\n   * invoking various configuration methods to set desired options, and finally calling\n   * {@link #create()}.\n   */\n  public GsonBuilder() {\n  }\n  /**\n   * Configures Gson to enable versioning support.\n   *\n   * @param ignoreVersionsAfter any field or type marked with a version higher than this value\n   * are ignored during serialization or deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder setVersion(double ignoreVersionsAfter) {\n    excluder = excluder.withVersion(ignoreVersionsAfter);\n    return this;\n  }\n  /**\n   * Configures Gson to excludes all class fields that have the specified modifiers. By default,\n   * Gson will exclude all fields marked transient or static. This method will override that\n   * behavior.\n   *\n   * @param modifiers the field modifiers. You must use the modifiers specified in the\n   * {@link java.lang.reflect.Modifier} class. For example,\n   * {@link java.lang.reflect.Modifier#TRANSIENT},\n   * {@link java.lang.reflect.Modifier#STATIC}.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n    excluder = excluder.withModifiers(modifiers);\n    return this;\n  }\n  /**\n   * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\n   * special text. This prevents attacks from third-party sites through script sourcing. See\n   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a>\n   * for details.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder generateNonExecutableJson() {\n    this.generateNonExecutableJson = true;\n    return this;\n  }\n  /**\n   * Configures Gson to exclude all fields from consideration for serialization or deserialization\n   * that do not have the {@link Expose} annotation.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder excludeFieldsWithoutExposeAnnotation() {\n    excluder = excluder.excludeFieldsWithoutExposeAnnotation();\n    return this;\n  }\n  /**\n   * Configure Gson to serialize null fields. By default, Gson omits all fields that are null\n   * during serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   */\n  public GsonBuilder serializeNulls() {\n    this.serializeNulls = true;\n    return this;\n  }\n  /**\n   * Enabling this feature will only change the serialized form if the map key is\n   * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON\n   * form. The default implementation of map serialization uses {@code toString()}\n   * on the key; however, when this is called then one of the following cases\n   * apply:\n   *\n   * <h3>Maps as JSON objects</h3>\n   * For this case, assume that a type adapter is registered to serialize and\n   * deserialize some {@code Point} class, which contains an x and y coordinate,\n   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would\n   * then be serialized as a {@link JsonObject}.\n   *\n   * <p>Below is an example:\n   * <pre>  {@code\n   *   Gson gson = new GsonBuilder()\n   *       .register(Point.class, new MyPointTypeAdapter())\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }</pre>\n   * The above code prints this JSON object:<pre>  {@code\n   *   {\n   *     \"(5,6)\": \"a\",\n   *     \"(8,8)\": \"b\"\n   *   }\n   * }</pre>\n   *\n   * <h3>Maps as JSON arrays</h3>\n   * For this case, assume that a type adapter was NOT registered for some\n   * {@code Point} class, but rather the default Gson serialization is applied.\n   * In this case, some {@code new Point(2,3)} would serialize as {@code\n   * {\"x\":2,\"y\":5}}.\n   *\n   * <p>Given the assumption above, a {@code Map<Point, String>} will be\n   * serialize as an array of arrays (can be viewed as an entry set of pairs).\n   *\n   * <p>Below is an example of serializing complex types as JSON arrays:\n   * <pre> {@code\n   *   Gson gson = new GsonBuilder()\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }\n   *\n   * The JSON output would look as follows:\n   * <pre>   {@code\n   *   [\n   *     [\n   *       {\n   *         \"x\": 5,\n   *         \"y\": 6\n   *       },\n   *       \"a\"\n   *     ],\n   *     [\n   *       {\n   *         \"x\": 8,\n   *         \"y\": 8\n   *       },\n   *       \"b\"\n   *     ]\n   *   ]\n   * }</pre>\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   */\n  public GsonBuilder enableComplexMapKeySerialization() {\n    complexMapKeySerialization = true;\n    return this;\n  }\n  /**\n   * Configures Gson to exclude inner classes during serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder disableInnerClassSerialization() {\n    excluder = excluder.disableInnerClassSerialization();\n    return this;\n  }\n  /**\n   * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\n   * objects.\n   *\n   * @param serializationPolicy the particular policy to use for serializing longs.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\n    this.longSerializationPolicy = serializationPolicy;\n    return this;\n  }\n  /**\n   * Configures Gson to apply a specific naming policy to an object's field during serialization\n   * and deserialization.\n   *\n   * @param namingConvention the JSON field naming convention to use for serialization and\n   * deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\n    this.fieldNamingPolicy = namingConvention;\n    return this;\n  }\n  /**\n   * Configures Gson to apply a specific naming policy strategy to an object's field during\n   * serialization and deserialization.\n   *\n   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n<fim_suffix>  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n    this.fieldNamingPolicy = fieldNamingStrategy;\n    return this;\n  }<fim_middle>// function below has no smell\n"}