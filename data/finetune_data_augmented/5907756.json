{"text": "<fim_prefix>     * specified order is the following:\n     * <ol>\n     *  <li>query the system property using <code>System.getProperty</code>\n     *  <li>read <code>$java.home/lib/<i>propertiesFilename</i></code> file\n     *  <li>read <code>META-INF/services/<i>factoryId</i></code> file\n     *  <li>use fallback classname\n     * </ol>\n     *\n     * @return Class object that provides factory service, never null\n     *\n     * @param factoryId             Name of the factory to find, same as\n     *                              a property name\n     * @param propertiesFilename The filename in the $java.home/lib directory\n     *                           of the properties file.  If none specified,\n     *                           ${java.home}/lib/xalan.properties will be used.\n     * @param fallbackClassName     Implementation class name, if nothing else\n     *                              is found.  Use null to mean no fallback.\n     *\n     * @exception ObjectFactory.ConfigurationError\n     */\n    static Class lookUpFactoryClass(String factoryId,\n                                           String propertiesFilename,\n                                           String fallbackClassName)\n        throws ConfigurationError\n    {\n        String factoryClassName = lookUpFactoryClassName(factoryId,\n                                                         propertiesFilename,\n                                                         fallbackClassName);\n        ClassLoader cl = findClassLoader();\n        if (factoryClassName == null) {\n            factoryClassName = fallbackClassName;\n        }\n        // assert(className != null);\n        try{\n            Class providerClass = findProviderClass(factoryClassName,\n                                                    cl,\n                                                    true);\n            debugPrintln(\"created new instance of \" + providerClass +\n                   \" using ClassLoader: \" + cl);\n            return providerClass;\n        } catch (ClassNotFoundException x) {\n            throw new ConfigurationError(\n                \"Provider \" + factoryClassName + \" not found\", x);\n        } catch (Exception x) {\n            throw new ConfigurationError(\n                \"Provider \"+factoryClassName+\" could not be instantiated: \"+x,\n                x);\n        }\n    } // lookUpFactoryClass(String,String,String):Class\n    /**\n     * Finds the name of the required implementation class in the specified\n     * order.  The specified order is the following:\n     * <ol>\n     *  <li>query the system property using <code>System.getProperty</code>\n     *  <li>read <code>$java.home/lib/<i>propertiesFilename</i></code> file\n     *  <li>read <code>META-INF/services/<i>factoryId</i></code> file\n     *  <li>use fallback classname\n     * </ol>\n     *\n     * @return name of class that provides factory service, never null\n     *\n     * @param factoryId             Name of the factory to find, same as\n     *                              a property name\n     * @param propertiesFilename The filename in the $java.home/lib directory\n     *                           of the properties file.  If none specified,\n     *                           ${java.home}/lib/xalan.properties will be used.\n     * @param fallbackClassName     Implementation class name, if nothing else\n     *                              is found.  Use null to mean no fallback.\n     *\n     * @exception ObjectFactory.ConfigurationError\n     */\n    static String lookUpFactoryClassName(String factoryId,\n                                                String propertiesFilename,\n                                                String fallbackClassName)\n    {\n        // Use the system property first\n        try {\n            String systemProp = SecuritySupport.getSystemProperty(factoryId);\n            if (systemProp != null) {\n                debugPrintln(\"found system property, value=\" + systemProp);\n                return systemProp;\n            }\n        } catch (SecurityException se) {\n            // Ignore and continue w/ next location\n        }\n        // Try to read from propertiesFilename, or\n        // $java.home/lib/xalan.properties\n        String factoryClassName = null;\n        // no properties file name specified; use\n        // $JAVA_HOME/lib/xalan.properties:\n        if (propertiesFilename == null) {\n            File propertiesFile = null;\n            boolean propertiesFileExists = false;\n            try {\n                String javah = SecuritySupport.getSystemProperty(\"java.home\");\n                propertiesFilename = javah + File.separator +\n                    \"lib\" + File.separator + DEFAULT_PROPERTIES_FILENAME;\n                propertiesFile = new File(propertiesFilename);\n                propertiesFileExists = SecuritySupport.getFileExists(propertiesFile);\n            } catch (SecurityException e) {\n                // try again...\n                fLastModified = -1;\n                fXalanProperties = null;\n            }\n            synchronized (ObjectFactory.class) {\n                boolean loadProperties = false;\n                FileInputStream fis = null;\n                try {\n                    // file existed last time\n                    if(fLastModified >= 0) {\n                        if(propertiesFileExists &&\n                                (fLastModified < (fLastModified = SecuritySupport.getLastModified(propertiesFile)))) {\n                            loadProperties = true;\n                        } else {\n                            // file has stopped existing...\n                            if(!propertiesFileExists) {\n                                fLastModified = -1;\n                                fXalanProperties = null;\n                            } // else, file wasn't modified!\n                        }\n                    } else {\n                        // file has started to exist:\n                        if(propertiesFileExists) {\n                            loadProperties = true;\n                            fLastModified = SecuritySupport.getLastModified(propertiesFile);\n                        } // else, nothing's changed\n                    }\n                    if(loadProperties) {\n                        // must never have attempted to read xalan.properties\n                        // before (or it's outdeated)\n                        fXalanProperties = new Properties();\n                        fis = SecuritySupport.getFileInputStream(propertiesFile);\n                        fXalanProperties.load(fis);\n                    }\n\t        } catch (Exception x) {\n\t            fXalanProperties = null;\n\t            fLastModified = -1;\n                    // assert(x instanceof FileNotFoundException\n\t            //        || x instanceof SecurityException)\n\t            // In both cases, ignore and continue w/ next location\n\t        }\n                finally {\n                    // try to close the input stream if one was opened.\n                    if (fis != null) {\n                        try {\n                            fis.close();\n                        }\n                        // Ignore the exception.\n                        catch (IOException exc) {}\n                    }\n                }\t            \n            }\n            if(fXalanProperties != null) {\n                factoryClassName = fXalanProperties.getProperty(factoryId);\n            }\n        } else {\n            FileInputStream fis = null;\n            try {\n                fis = SecuritySupport.getFileInputStream(new File(propertiesFilename));\n                Properties props = new Properties();\n                props.load(fis);\n                factoryClassName = props.getProperty(factoryId);\n            } catch (Exception x) {\n                // assert(x instanceof FileNotFoundException\n                //        || x instanceof SecurityException)\n                // In both cases, ignore and continue w/ next location\n            }\n            finally {\n                // try to close the input stream if one was opened.\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    }\n                    // Ignore the exception.\n                    catch (IOException exc) {}\n                }\n            }               \n        }\n        if (factoryClassName != null) {\n            debugPrintln(\"found in \" + propertiesFilename + \", value=\"\n                          + factoryClassName);\n            return factoryClassName;\n        }\n        // Try Jar Service Provider Mechanism\n        return findJarServiceProviderName(factoryId);\n    } // lookUpFactoryClass(String,String):String\n    //\n    // Private static methods\n    //\n    /** Prints a message to standard error if debugging is enabled. */\n    private static void debugPrintln(String msg) {\n        if (DEBUG) {\n            System.err.println(\"JAXP: \" + msg);\n        }\n    } // debugPrintln(String)\n    /**\n     * Figure out which ClassLoader to use.  For JDK 1.2 and later use\n     * the context ClassLoader.\n     */\n<fim_suffix>    static ClassLoader findClassLoader()\n        throws ConfigurationError\n    { \n        // Figure out which ClassLoader to use for loading the provider\n        // class.  If there is a Context ClassLoader then use it.\n        ClassLoader context = SecuritySupport.getContextClassLoader();\n        ClassLoader system = SecuritySupport.getSystemClassLoader();\n        ClassLoader chain = system;\n        while (true) {\n            if (context == chain) {\n                // Assert: we are on JDK 1.1 or we have no Context ClassLoader\n                // or any Context ClassLoader in chain of system classloader\n                // (including extension ClassLoader) so extend to widest\n                // ClassLoader (always look in system ClassLoader if Xalan\n                // is in boot/extension/system classpath and in current\n                // ClassLoader otherwise); normal classloaders delegate\n                // back to system ClassLoader first so this widening doesn't\n                // change the fact that context ClassLoader will be consulted\n                ClassLoader current = ObjectFactory.class.getClassLoader();\n                chain = system;\n                while (true) {\n                    if (current == chain) {\n                        // Assert: Current ClassLoader in chain of\n                        // boot/extension/system ClassLoaders\n                        return system;\n                    }\n                    if (chain == null) {\n                        break;\n                    }\n                    chain = SecuritySupport.getParentClassLoader(chain);\n                }\n                // Assert: Current ClassLoader not in chain of\n                // boot/extension/system ClassLoaders\n                return current;\n            }\n            if (chain == null) {\n                // boot ClassLoader reached\n                break;\n            }\n            // Check for any extension ClassLoaders in chain up to\n            // boot ClassLoader\n            chain = SecuritySupport.getParentClassLoader(chain);\n        };\n        // Assert: Context ClassLoader not in chain of\n        // boot/extension/system ClassLoaders\n        return context;\n    } // findClassLoader():ClassLoader<fim_middle>// function below is long method\n"}