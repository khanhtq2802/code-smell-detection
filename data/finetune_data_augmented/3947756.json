{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.aries.blueprint.compendium.cm;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Dictionary;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\n\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.cm.Configuration;\nimport org.osgi.service.cm.ConfigurationAdmin;\nimport org.osgi.service.cm.ConfigurationPlugin;\n\npublic class CmUtils {\n\n    private CmUtils() {        \n    }\n    \n    public static Configuration getConfiguration(ConfigurationAdmin configAdmin, String persistentId) throws IOException {\n        String filter = '(' + Constants.SERVICE_PID + '=' + persistentId + ')';\n        Configuration[] configs;\n        try {\n            configs = configAdmin.listConfigurations(filter);\n        } catch (InvalidSyntaxException e) {\n            // this should not happen\n            throw new RuntimeException(\"Invalid filter: \" + filter);\n        }\n        if (configs != null && configs.length > 0) {\n            return configs[0];\n        } else {\n            // TODO: what should we do?\n            // throw new RuntimeException(\"No configuration object for pid=\" + persistentId);\n            return null;\n        }\n    }\n\n    public static Dictionary<String, Object> getProperties(ServiceReference service, String persistentId) throws IOException {\n        BundleContext bc = service.getBundle().getBundleContext();\n        ServiceReference<ConfigurationAdmin> caRef = bc.getServiceReference(ConfigurationAdmin.class);\n        try {\n            ConfigurationAdmin ca = bc.getService(caRef);\n            Configuration config = getConfiguration(ca, persistentId);\n            if (config != null) {\n                Dictionary<String, Object> props = new CaseInsensitiveDictionary(config.getProperties());\n                Bundle bundle = caRef.getBundle();\n                if (bundle != null) {\n                    BundleContext caBc = bundle.getBundleContext();\n                    if (caBc != null) {\n                        try {\n                            callPlugins(caBc, props, service, persistentId, null);\n                        } catch (IllegalStateException ise) {\n                            // we don't care it doesn't exist so, shrug.\n                        }\n                    }\n                }\n                return props;\n            } else {\n                return null;\n            }\n        } finally {\n            bc.ungetService(caRef);\n        }\n    }\n\n    private static void callPlugins(final BundleContext bundleContext,\n                                    final Dictionary<String, Object> props,\n                                    final ServiceReference sr,\n                                    final String configPid,\n                                    final String factoryPid) {\n        ServiceReference[] plugins = null;\n        try {\n            final String targetPid = (factoryPid == null) ? configPid : factoryPid;\n            String filter = \"(|(!(cm.target=*))(cm.target=\" + targetPid + \"))\";\n            plugins = bundleContext.getServiceReferences(ConfigurationPlugin.class.getName(), filter);\n        } catch (InvalidSyntaxException ise) {\n            // no filter, no exception ...\n        }\n\n        // abort early if there are no plugins\n        if (plugins == null || plugins.length == 0) {\n            return;\n        }\n\n        // sort the plugins by their service.cmRanking\n        if (plugins.length > 1) {\n            Arrays.sort(plugins, CM_RANKING);\n        }\n\n        // call the plugins in order\n        for (ServiceReference pluginRef : plugins) {\n            ConfigurationPlugin plugin = (ConfigurationPlugin) bundleContext.getService(pluginRef);\n            if (plugin != null) {\n                try {\n                    plugin.modifyConfiguration(sr, props);\n                } catch (Throwable t) {\n                    // Ignore\n                } finally {\n                    // ensure ungetting the plugin\n                    bundleContext.ungetService(pluginRef);\n                }\n                setAutoProperties(props, configPid, factoryPid);\n            }\n        }\n    }\n\n    private static void setAutoProperties( Dictionary<String, Object> properties, String pid, String factoryPid )\n    {\n        replaceProperty(properties, Constants.SERVICE_PID, pid);\n        replaceProperty(properties, ConfigurationAdmin.SERVICE_FACTORYPID, factoryPid);\n        properties.remove(ConfigurationAdmin.SERVICE_BUNDLELOCATION);\n    }\n\n    private static void replaceProperty(Dictionary<String, Object> properties, String key, String value) {\n        if (value == null) {\n            properties.remove(key);\n        } else {\n            properties.put(key, value);\n        }\n    }\n\n    private static Comparator<ServiceReference> CM_RANKING = new Comparator<ServiceReference>() {\n        @Override\n        public int compare(ServiceReference sr1, ServiceReference sr2) {\n            final long rank1 = getLong(sr1, ConfigurationPlugin.CM_RANKING);\n            final long rank2 = getLong(sr2, ConfigurationPlugin.CM_RANKING);\n            if (rank1 == rank2) {\n                return 0;\n            }\n            return (rank1 < rank2) ? -1 : 1;\n        }\n\n        protected long getLong(ServiceReference sr, String property) {\n            Object rankObj = sr.getProperty(property);\n            if (rankObj instanceof Number) {\n                return ((Number) rankObj).longValue();\n            }\n            return 0;\n        }\n    };\n\n    private static class CaseInsensitiveDictionary extends Dictionary<String, Object> {\n        private final Hashtable<String, Object> internalMap = new Hashtable<String, Object>();\n        private final Hashtable<String, String> originalKeys = new Hashtable<String, String>();\n\n        public CaseInsensitiveDictionary(Dictionary<String, Object> props) {\n            if (props != null) {\n                Enumeration<String> keys = props.keys();\n                while (keys.hasMoreElements()) {\n                    // check the correct syntax of the key\n                    String key = checkKey(keys.nextElement());\n                    // check uniqueness of key\n                    String lowerCase = key.toLowerCase();\n                    if (internalMap.containsKey(lowerCase)) {\n                        throw new IllegalArgumentException(\"Key [\" + key + \"] already present in different case\");\n                    }\n                    // check the value\n                    Object value = props.get(key);\n                    checkValue(value);\n                    // add the key/value pair\n                    internalMap.put(lowerCase, value);\n                    originalKeys.put(lowerCase, key);\n                }\n            }\n        }\n\n        public Enumeration<Object> elements() {\n            return Collections.enumeration(internalMap.values());\n        }\n\n        public Object get(Object keyObj) {\n            String lowerCase = checkKey(keyObj == null ? null : keyObj.toString()).toLowerCase();\n            return internalMap.get(lowerCase);\n        }\n\n        public boolean isEmpty() {\n            return internalMap.isEmpty();\n        }\n\n        public Enumeration<String> keys() {\n            return Collections.enumeration(originalKeys.values());\n        }\n\n        public Object put(String key, Object value) {\n            String lowerCase = checkKey(key).toLowerCase();\n            checkValue(value);\n            originalKeys.put(lowerCase, key);\n            return internalMap.put(lowerCase, value);\n        }\n\n        public Object remove(Object keyObj) {\n            String lowerCase = checkKey(keyObj == null ? null : keyObj.toString()).toLowerCase();\n            originalKeys.remove(lowerCase);\n            return internalMap.remove(lowerCase);\n        }\n\n        public int size() {\n            return internalMap.size();\n        }\n\n        static String checkKey(String key) {\n            if (key == null || key.length() == 0) {\n                throw new IllegalArgumentException(\"Key must not be null nor an empty string\");\n            }\n            return key;\n        }\n\n<fim_suffix>        static Object checkValue(Object value) {\n            if (value == null) {\n                throw new IllegalArgumentException(\"Value must not be null\");\n            }\n            return value;\n        }\n\n        public String toString() {\n            return internalMap.toString();\n        }\n\n    }\n\n}<fim_middle>// function below has no smell\n"}