{"text": "<fim_prefix>                                            i);\n            ClassSymbol ctag = chk.getCompiled(topModle, flatname);\n            if (ctag == null)\n                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;\n            else if (!ctag.isAnonymous())\n                continue;\n            // keep a record of all tags, to verify that all are generated as required\n            accessConstrTags = accessConstrTags.prepend(ctag);\n            return ctag;\n        }\n    }\n    /** Add all required access methods for a private symbol to enclosing class.\n     *  @param sym       The symbol.\n     */\n    void makeAccessible(Symbol sym) {\n        JCClassDecl cdef = classDef(sym.owner.enclClass());\n        if (cdef == null) Assert.error(\"class def not found: \" + sym + \" in \" + sym.owner);\n        if (sym.name == names.init) {\n            cdef.defs = cdef.defs.prepend(\n                accessConstructorDef(cdef.pos, sym, accessConstrs.get(sym)));\n        } else {\n            MethodSymbol[] accessors = accessSyms.get(sym);\n            for (int i = 0; i < AccessCode.numberOfAccessCodes; i++) {\n                if (accessors[i] != null)\n                    cdef.defs = cdef.defs.prepend(\n                        accessDef(cdef.pos, sym, accessors[i], i));\n            }\n        }\n    }\n    /** Construct definition of an access method.\n     *  @param pos        The source code position of the definition.\n     *  @param vsym       The private or protected symbol.\n     *  @param accessor   The access method for the symbol.\n     *  @param acode      The access code.\n     */\n    JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {\n//      System.err.println(\"access \" + vsym + \" with \" + accessor);//DEBUG\n        currentClass = vsym.owner.enclClass();\n        make.at(pos);\n        JCMethodDecl md = make.MethodDef(accessor, null);\n        // Find actual symbol\n        Symbol sym = actualSymbols.get(vsym);\n        if (sym == null) sym = vsym;\n        JCExpression ref;           // The tree referencing the private symbol.\n        List<JCExpression> args;    // Any additional arguments to be passed along.\n        if ((sym.flags() & STATIC) != 0) {\n            ref = make.Ident(sym);\n            args = make.Idents(md.params);\n        } else {\n            JCExpression site = make.Ident(md.params.head);\n            if (acode % 2 != 0) {\n                //odd access codes represent qualified super accesses - need to\n                //emit reference to the direct superclass, even if the refered\n                //member is from an indirect superclass (JLS 13.1)\n                site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));\n            }\n            ref = make.Select(site, sym);\n            args = make.Idents(md.params.tail);\n        }\n        JCStatement stat;          // The statement accessing the private symbol.\n        if (sym.kind == VAR) {\n            // Normalize out all odd access codes by taking floor modulo 2:\n            int acode1 = acode - (acode & 1);\n            JCExpression expr;      // The access method's return value.\n            AccessCode aCode = AccessCode.getFromCode(acode1);\n            switch (aCode) {\n            case DEREF:\n                expr = ref;\n                break;\n            case ASSIGN:\n                expr = make.Assign(ref, args.head);\n                break;\n            case PREINC: case POSTINC: case PREDEC: case POSTDEC:\n                expr = makeUnary(aCode.tag, ref);\n                break;\n            default:\n                expr = make.Assignop(\n                    treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);\n                ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);\n            }\n            stat = make.Return(expr.setType(sym.type));\n        } else {\n            stat = make.Call(make.App(ref, args));\n        }\n        md.body = make.Block(0, List.of(stat));\n        // Make sure all parameters, result types and thrown exceptions\n        // are accessible.\n        for (List<JCVariableDecl> l = md.params; l.nonEmpty(); l = l.tail)\n            l.head.vartype = access(l.head.vartype);\n        md.restype = access(md.restype);\n        for (List<JCExpression> l = md.thrown; l.nonEmpty(); l = l.tail)\n            l.head = access(l.head);\n        return md;\n    }\n    /** Construct definition of an access constructor.\n     *  @param pos        The source code position of the definition.\n     *  @param constr     The private constructor.\n     *  @param accessor   The access method for the constructor.\n     */\n    JCTree accessConstructorDef(int pos, Symbol constr, MethodSymbol accessor) {\n        make.at(pos);\n        JCMethodDecl md = make.MethodDef(accessor,\n                                      accessor.externalType(types),\n                                      null);\n        JCIdent callee = make.Ident(names._this);\n        callee.sym = constr;\n        callee.type = constr.type;\n        md.body =\n            make.Block(0, List.of(\n                make.Call(\n                    make.App(\n                        callee,\n                        make.Idents(md.params.reverse().tail.reverse())))));\n        return md;\n    }\n/**************************************************************************\n * Free variables proxies and this$n\n *************************************************************************/\n    /** A map which allows to retrieve the translated proxy variable for any given symbol of an\n     *  enclosing scope that is accessed (the accessed symbol could be the synthetic 'this$n' symbol).\n     *  Inside a constructor, the map temporarily overrides entries corresponding to proxies and any\n     *  'this$n' symbols, where they represent the constructor parameters.\n     */\n    Map<Symbol, Symbol> proxies;\n    /** A scope containing all unnamed resource variables/saved\n     *  exception variables for translated TWR blocks\n     */\n    WriteableScope twrVars;\n    /** A stack containing the this$n field of the currently translated\n     *  classes (if needed) in innermost first order.\n     *  Inside a constructor, proxies and any this$n symbol are duplicated\n     *  in an additional innermost scope, where they represent the constructor\n     *  parameters.\n     */\n    List<VarSymbol> outerThisStack;\n    /** The name of a free variable proxy.\n     */\n    Name proxyName(Name name, int index) {\n        Name proxyName = names.fromString(\"val\" + target.syntheticNameChar() + name);\n        if (index > 0) {\n            proxyName = proxyName.append(names.fromString(\"\" + target.syntheticNameChar() + index));\n        }\n        return proxyName;\n    }\n    /** Proxy definitions for all free variables in given list, in reverse order.\n     *  @param pos        The source code position of the definition.\n     *  @param freevars   The free variables.\n     *  @param owner      The class in which the definitions go.\n     */\n    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner) {\n        return freevarDefs(pos, freevars, owner, 0);\n    }\n<fim_suffix>    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner,\n            long additionalFlags) {\n        long flags = FINAL | SYNTHETIC | additionalFlags;\n        List<JCVariableDecl> defs = List.nil();\n        Set<Name> proxyNames = new HashSet<>();\n        for (List<VarSymbol> l = freevars; l.nonEmpty(); l = l.tail) {\n            VarSymbol v = l.head;\n            int index = 0;\n            Name proxyName;\n            do {\n                proxyName = proxyName(v.name, index++);\n            } while (!proxyNames.add(proxyName));\n            VarSymbol proxy = new VarSymbol(\n                flags, proxyName, v.erasure(types), owner);\n            proxies.put(v, proxy);\n            JCVariableDecl vd = make.at(pos).VarDef(proxy, null);\n            vd.vartype = access(vd.vartype);\n            defs = defs.prepend(vd);\n        }\n        return defs;\n    }<fim_middle>// function below is long method\n"}