{"text": "<fim_prefix>\n<fim_suffix>public class DataBinder implements PropertyEditorRegistry, TypeConverter {\n\t/** Default object name used for binding: \"target\". */\n\tpublic static final String DEFAULT_OBJECT_NAME = \"target\";\n\t/** Default limit for array and collection growing: 256. */\n\tpublic static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;\n\t/**\n\t * We'll create a lot of DataBinder instances: Let's use a static logger.\n\t */\n\tprotected static final Log logger = LogFactory.getLog(DataBinder.class);\n\t@Nullable\n\tprivate final Object target;\n\tprivate final String objectName;\n\t@Nullable\n\tprivate AbstractPropertyBindingResult bindingResult;\n\t@Nullable\n\tprivate SimpleTypeConverter typeConverter;\n\tprivate boolean ignoreUnknownFields = true;\n\tprivate boolean ignoreInvalidFields = false;\n\tprivate boolean autoGrowNestedPaths = true;\n\tprivate int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;\n\t@Nullable\n\tprivate String[] allowedFields;\n\t@Nullable\n\tprivate String[] disallowedFields;\n\t@Nullable\n\tprivate String[] requiredFields;\n\t@Nullable\n\tprivate ConversionService conversionService;\n\t@Nullable\n\tprivate MessageCodesResolver messageCodesResolver;\n\tprivate BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();\n\tprivate final List<Validator> validators = new ArrayList<>();\n\t/**\n\t * Create a new DataBinder instance, with default object name.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic DataBinder(@Nullable Object target) {\n\t\tthis(target, DEFAULT_OBJECT_NAME);\n\t}\n\t/**\n\t * Create a new DataBinder instance.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @param objectName the name of the target object\n\t */\n\tpublic DataBinder(@Nullable Object target, String objectName) {\n\t\tthis.target = ObjectUtils.unwrapOptional(target);\n\t\tthis.objectName = objectName;\n\t}\n\t/**\n\t * Return the wrapped target object.\n\t */\n\t@Nullable\n\tpublic Object getTarget() {\n\t\treturn this.target;\n\t}\n\t/**\n\t * Return the name of the bound object.\n\t */\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\t/**\n\t * Set whether this binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t * <p>If \"true\", a null path location will be populated with a default object value and traversed\n\t * instead of resulting in an exception. This flag also enables auto-growth of collection elements\n\t * when accessing an out-of-bounds index.\n\t * <p>Default is \"true\" on a standard DataBinder. Note that since Spring 4.1 this feature is supported\n\t * for bean property access (DataBinder's default mode) and field access.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths\n\t */\n\tpublic void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods\");\n\t\tthis.autoGrowNestedPaths = autoGrowNestedPaths;\n\t}\n\t/**\n\t * Return whether \"auto-growing\" of nested paths has been activated.\n\t */\n\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}\n\t/**\n\t * Specify the limit for array and collection auto-growing.\n\t * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.\n\t * Raise this limit if your auto-growing needs are unusually high.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit\n\t */\n\tpublic void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods\");\n\t\tthis.autoGrowCollectionLimit = autoGrowCollectionLimit;\n\t}\n\t/**\n\t * Return the current limit for array and collection auto-growing.\n\t */\n\tpublic int getAutoGrowCollectionLimit() {\n\t\treturn this.autoGrowCollectionLimit;\n\t}\n\t/**\n\t * Initialize standard JavaBean property access for this DataBinder.\n\t * <p>This is the default; an explicit call just leads to eager initialization.\n\t * @see #initDirectFieldAccess()\n\t * @see #createBeanPropertyBindingResult()\n\t */\n\tpublic void initBeanPropertyAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods\");\n\t\tthis.bindingResult = createBeanPropertyBindingResult();\n\t}\n\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using standard\n\t * JavaBean property access.\n\t * @since 4.2.1\n\t */\n\tprotected AbstractPropertyBindingResult createBeanPropertyBindingResult() {\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * Initialize direct field access for this DataBinder,\n\t * as alternative to the default bean property access.\n\t * @see #initBeanPropertyAccess()\n\t * @see #createDirectFieldBindingResult()\n\t */\n\tpublic void initDirectFieldAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initDirectFieldAccess before other configuration methods\");\n\t\tthis.bindingResult = createDirectFieldBindingResult();\n\t}\n\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using direct\n\t * field access.\n\t * @since 4.2.1\n\t */\n\tprotected AbstractPropertyBindingResult createDirectFieldBindingResult() {\n\t\tDirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths());\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * Return the internal BindingResult held by this DataBinder,\n\t * as an AbstractPropertyBindingResult.\n\t */\n\tprotected AbstractPropertyBindingResult getInternalBindingResult() {\n\t\tif (this.bindingResult == null) {\n\t\t\tinitBeanPropertyAccess();\n\t\t}\n\t\treturn this.bindingResult;\n\t}\n\t/**\n\t * Return the underlying PropertyAccessor of this binder's BindingResult.\n\t */\n\tprotected ConfigurablePropertyAccessor getPropertyAccessor() {\n\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t}\n\t/**\n\t * Return this binder's underlying SimpleTypeConverter.\n\t */\n\tprotected SimpleTypeConverter getSimpleTypeConverter() {\n\t\tif (this.typeConverter == null) {\n\t\t\tthis.typeConverter = new SimpleTypeConverter();\n\t\t\tif (this.conversionService != null) {\n\t\t\t\tthis.typeConverter.setConversionService(this.conversionService);\n\t\t\t}\n\t\t}\n\t\treturn this.typeConverter;\n\t}\n\t/**\n\t * Return the underlying TypeConverter of this binder's BindingResult.\n\t */\n\tprotected PropertyEditorRegistry getPropertyEditorRegistry() {<fim_middle>// class below is data class and blob\n"}