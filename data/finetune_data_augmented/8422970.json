{"text": "<fim_prefix>    @UriParam(label = \"consumer\")\n    private String messageAttributeNames;\n    @UriParam(label = \"consumer\")\n    private Integer waitTimeSeconds;\n    @UriParam(label = \"consumer\")\n    private Integer defaultVisibilityTimeout;\n    @UriParam(label = \"consumer\")\n    private boolean extendMessageVisibility;\n    @UriParam(label = \"consumer\")\n    private String kmsMasterKeyId;\n    @UriParam(label = \"consumer\")\n    private Integer kmsDataKeyReusePeriodSeconds;\n    @UriParam(label = \"consumer\")\n    private boolean serverSideEncryptionEnabled;\n    @UriParam(label = \"consumer\", defaultValue = \"1\")\n    private int concurrentConsumers = 1;\n    @UriParam(label = \"advanced\")\n    private String queueUrl;\n    // producer properties\n    @UriParam(label = \"producer\")\n    private Integer delaySeconds;\n    // producer properties\n    @UriParam(label = \"advanced\")\n    private boolean delayQueue;\n    @UriParam(label = \"producer\", enums = \"useConstant,useExchangeId,usePropertyValue\")\n    private MessageGroupIdStrategy messageGroupIdStrategy;\n    @UriParam(label = \"producer\", defaultValue = \"useExchangeId\", enums = \"useExchangeId,useContentBasedDeduplication\")\n    private MessageDeduplicationIdStrategy messageDeduplicationIdStrategy = new ExchangeIdMessageDeduplicationIdStrategy();\n    @UriParam(label = \"producer\")\n    private SqsOperations operation;\n    // queue properties\n    @UriParam(label = \"queue\")\n    private Integer maximumMessageSize;\n    @UriParam(label = \"queue\")\n    private Integer messageRetentionPeriod;\n    @UriParam(label = \"queue\")\n    private Integer receiveMessageWaitTimeSeconds;\n    @UriParam(label = \"queue\")\n    private String policy;\n    // dead letter queue properties\n    @UriParam(label = \"queue\")\n    private String redrivePolicy;\n    /**\n     *  Whether or not the queue is a FIFO queue\n     */\n    boolean isFifoQueue() {\n        // AWS docs suggest this is valid derivation.\n        // FIFO queue names must end with .fifo, and standard queues cannot\n        if (queueName.endsWith(\".fifo\")) {\n            return true;\n        }\n        return false;\n    }\n    public String getAmazonAWSHost() {\n        return amazonAWSHost;\n    }\n    /**\n     * The hostname of the Amazon AWS cloud.\n     */\n    public void setAmazonAWSHost(String amazonAWSHost) {\n        this.amazonAWSHost = amazonAWSHost;\n    }\n    public String getQueueName() {\n        return queueName;\n    }\n    /**\n     * Name of queue. The queue will be created if they don't already exists.\n     */\n    public void setQueueName(String queueName) {\n        this.queueName = queueName;\n    }\n    public String getAccessKey() {\n        return accessKey;\n    }\n    /**\n     * Amazon AWS Access Key\n     */\n    public void setAccessKey(String accessKey) {\n        this.accessKey = accessKey;\n    }\n    public String getSecretKey() {\n        return secretKey;\n    }\n    /**\n     * Amazon AWS Secret Key\n     */\n    public void setSecretKey(String secretKey) {\n        this.secretKey = secretKey;\n    }\n    public boolean isDeleteAfterRead() {\n        return deleteAfterRead;\n    }\n    /**\n     * Delete message from SQS after it has been read\n     */\n    public void setDeleteAfterRead(boolean deleteAfterRead) {\n        this.deleteAfterRead = deleteAfterRead;\n    }\n    public AmazonSQS getAmazonSQSClient() {\n        return amazonSQSClient;\n    }\n    /**\n     * To use the AmazonSQS as client\n     */\n    public void setAmazonSQSClient(AmazonSQS amazonSQSClient) {\n        this.amazonSQSClient = amazonSQSClient;\n    }\n    public Integer getVisibilityTimeout() {\n        return visibilityTimeout;\n    }\n    /**\n     * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved\n     * by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest.\n     * This only make sense if its different from defaultVisibilityTimeout.\n     * It changes the queue visibility timeout attribute permanently.\n     */\n    public void setVisibilityTimeout(Integer visibilityTimeout) {\n        this.visibilityTimeout = visibilityTimeout;\n    }\n    public String getAttributeNames() {\n        return attributeNames;\n    }\n    /**\n     * A list of attribute names to receive when consuming.  Multiple names can be separated by comma.\n     */\n    public void setAttributeNames(String attributeNames) {\n        this.attributeNames = attributeNames;\n    }\n    public String getMessageAttributeNames() {\n        return messageAttributeNames;\n    }\n    /**\n     * A list of message attribute names to receive when consuming. Multiple names can be separated by comma.\n     */\n    public void setMessageAttributeNames(String messageAttributeNames) {\n        this.messageAttributeNames = messageAttributeNames;\n    }\n    public Integer getDefaultVisibilityTimeout() {\n        return defaultVisibilityTimeout;\n    }\n    /**\n     * The default visibility timeout (in seconds)\n     */\n    public void setDefaultVisibilityTimeout(Integer defaultVisibilityTimeout) {\n        this.defaultVisibilityTimeout = defaultVisibilityTimeout;\n    }\n    public Integer getDelaySeconds() {\n        return delaySeconds;\n    }\n    /**\n     * Delay sending messages for a number of seconds.\n     */\n    public void setDelaySeconds(Integer delaySeconds) {\n        this.delaySeconds = delaySeconds;\n    }\n    public boolean isDelayQueue() {\n        return delayQueue;\n    }\n    /**\n     * Define if you want to apply delaySeconds option to the queue or on single messages\n     */\n    public void setDelayQueue(boolean delayQueue) {\n        this.delayQueue = delayQueue;\n    }\n    public Integer getMaximumMessageSize() {\n        return maximumMessageSize;\n    }\n    /**\n     * The maximumMessageSize (in bytes) an SQS message can contain for this queue.\n     */\n    public void setMaximumMessageSize(Integer maximumMessageSize) {\n        this.maximumMessageSize = maximumMessageSize;\n    }\n    public Integer getMessageRetentionPeriod() {\n        return messageRetentionPeriod;\n    }\n    /**\n     * The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.\n     */\n    public void setMessageRetentionPeriod(Integer messageRetentionPeriod) {\n        this.messageRetentionPeriod = messageRetentionPeriod;\n    }\n    public String getPolicy() {\n        return policy;\n    }\n    /**\n     * The policy for this queue\n     */\n    public void setPolicy(String policy) {\n        this.policy = policy;\n    }\n    public String getRedrivePolicy() {\n        return redrivePolicy;\n    }\n    /**\n     * Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.\n     */\n    public void setRedrivePolicy(String redrivePolicy) {\n        this.redrivePolicy = redrivePolicy;\n    }\n    public boolean isExtendMessageVisibility() {\n        return this.extendMessageVisibility;\n    }\n    /**\n     * If enabled then a scheduled background task will keep extending the message visibility on SQS.\n     * This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set.\n     * See details at Amazon docs.\n     */\n    public void setExtendMessageVisibility(boolean extendMessageVisibility) {\n        this.extendMessageVisibility = extendMessageVisibility;\n    }\n    public Integer getReceiveMessageWaitTimeSeconds() {\n        return receiveMessageWaitTimeSeconds;\n    }\n    /**\n     * If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.\n     */\n    public void setReceiveMessageWaitTimeSeconds(Integer receiveMessageWaitTimeSeconds) {\n        this.receiveMessageWaitTimeSeconds = receiveMessageWaitTimeSeconds;\n    }\n    public Integer getWaitTimeSeconds() {\n        return waitTimeSeconds;\n    }\n    /**\n     * Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.\n     */\n    public void setWaitTimeSeconds(Integer waitTimeSeconds) {\n        this.waitTimeSeconds = waitTimeSeconds;\n    }\n    public String getQueueOwnerAWSAccountId() {\n        return queueOwnerAWSAccountId;\n    }\n    /**\n     * Specify the queue owner aws account id when you need to connect the queue with different account owner.\n     */\n    public void setQueueOwnerAWSAccountId(String queueOwnerAWSAccountId) {\n        this.queueOwnerAWSAccountId = queueOwnerAWSAccountId;\n    }\n    public boolean isDeleteIfFiltered() {\n        return deleteIfFiltered;\n    }\n    /**\n     * Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter.\n     * If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage.\n     */\n    public void setDeleteIfFiltered(boolean deleteIfFiltered) {\n        this.deleteIfFiltered = deleteIfFiltered;\n    }\n    public String getRegion() {\n        return region;\n    }\n    /**\n     * Specify the queue region which could be used with queueOwnerAWSAccountId to build the service URL.\n     */\n    public void setRegion(String region) {\n        this.region = region;\n    }\n<fim_suffix>    public int getConcurrentConsumers() {\n        return concurrentConsumers;\n    }<fim_middle>// function below has no smell\n"}