{"text": "<fim_prefix>/*\n * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.security.access.intercept.aopalliance;\n\nimport org.springframework.security.access.SecurityMetadataSource;\nimport org.springframework.security.access.intercept.AbstractSecurityInterceptor;\nimport org.springframework.security.access.intercept.InterceptorStatusToken;\nimport org.springframework.security.access.method.MethodSecurityMetadataSource;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\n\n/**\n * Provides security interception of AOP Alliance based method invocations.\n * <p>\n * The <code>SecurityMetadataSource</code> required by this security interceptor is of\n * type {@link MethodSecurityMetadataSource}. This is shared with the AspectJ based\n * security interceptor (<code>AspectJSecurityInterceptor</code>), since both work with\n * Java <code>Method</code>s.\n * <p>\n * Refer to {@link AbstractSecurityInterceptor} for details on the workflow.\n *\n * @author Ben Alex\n * @author Rob Winch\n */\n<fim_suffix>public class MethodSecurityInterceptor extends AbstractSecurityInterceptor implements\n\t\tMethodInterceptor {\n\t// ~ Instance fields\n\t// ================================================================================================\n\n\tprivate MethodSecurityMetadataSource securityMetadataSource;\n\n\t// ~ Methods\n\t// ========================================================================================================\n\n\tpublic Class<?> getSecureObjectClass() {\n\t\treturn MethodInvocation.class;\n\t}\n\n\t/**\n\t * This method should be used to enforce security on a <code>MethodInvocation</code>.\n\t *\n\t * @param mi The method being invoked which requires a security decision\n\t *\n\t * @return The returned value from the method invocation (possibly modified by the\n\t * {@code AfterInvocationManager}).\n\t *\n\t * @throws Throwable if any error occurs\n\t */\n\tpublic Object invoke(MethodInvocation mi) throws Throwable {\n\t\tInterceptorStatusToken token = super.beforeInvocation(mi);\n\n\t\tObject result;\n\t\ttry {\n\t\t\tresult = mi.proceed();\n\t\t}\n\t\tfinally {\n\t\t\tsuper.finallyInvocation(token);\n\t\t}\n\t\treturn super.afterInvocation(token, result);\n\t}\n\n\tpublic MethodSecurityMetadataSource getSecurityMetadataSource() {\n\t\treturn this.securityMetadataSource;\n\t}\n\n\tpublic SecurityMetadataSource obtainSecurityMetadataSource() {\n\t\treturn this.securityMetadataSource;\n\t}\n\n\tpublic void setSecurityMetadataSource(MethodSecurityMetadataSource newSource) {\n\t\tthis.securityMetadataSource = newSource;\n\t}\n}<fim_middle>// class below has no smell\n"}