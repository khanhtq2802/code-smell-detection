{"text": "<fim_prefix>            repositoryResponse.setStackName(stackName);\n          }\n          if (repositoryResponse.getStackVersion() == null) {\n            repositoryResponse.setStackVersion(stackVersion);\n          }\n          repositoryResponse.setClusterVersionId(request.getClusterVersionId());\n        }\n        response.addAll(repositories);\n      } catch (StackAccessException e) {\n        if (requests.size() == 1) {\n          // only throw exception if 1 request.\n          // there will be > 1 request in case of OR predicate\n          throw e;\n        }\n      }\n    }\n    return response;\n  }\n  @Experimental(feature = ExperimentalFeature.CUSTOM_SERVICE_REPOS,\n    comment = \"Remove logic for handling custom service repos after enabling multi-mpack cluster deployment\")\n  private Set<RepositoryResponse> getRepositories(RepositoryRequest request) throws AmbariException {\n    String stackName = request.getStackName();\n    String stackVersion = request.getStackVersion();\n    String osType = request.getOsType();\n    String repoId = request.getRepoId();\n    Long repositoryVersionId = request.getRepositoryVersionId();\n    String versionDefinitionId = request.getVersionDefinitionId();\n    // !!! when asking for Repository responses for a versionDefinition, it is either for\n    // an established repo version (a Long) OR from the in-memory generated ones (a String)\n    if (null == repositoryVersionId && null != versionDefinitionId) {\n      if (NumberUtils.isDigits(versionDefinitionId)) {\n        repositoryVersionId = Long.valueOf(versionDefinitionId);\n      }\n    }\n    Set<RepositoryResponse> responses = new HashSet<>();\n    if (repositoryVersionId != null) {\n      final RepositoryVersionEntity repositoryVersion = repositoryVersionDAO.findByPK(repositoryVersionId);\n      if (repositoryVersion != null) {\n        for (RepoOsEntity operatingSystem : repositoryVersion.getRepoOsEntities()) {\n          if (operatingSystem.getFamily().equals(osType)) {\n            for (RepoDefinitionEntity repository : operatingSystem.getRepoDefinitionEntities()) {\n              final RepositoryResponse response = new RepositoryResponse(repository.getBaseUrl(), osType, repository.getRepoID(),\n                  repository.getRepoName(), repository.getDistribution(), repository.getComponents(), \"\", \"\",\n                      repository.getTags(), repository.getApplicableServices());\n              if (null != versionDefinitionId) {\n                response.setVersionDefinitionId(versionDefinitionId);\n              } else {\n                response.setRepositoryVersionId(repositoryVersionId);\n              }\n              response.setStackName(repositoryVersion.getStackName());\n              response.setStackVersion(repositoryVersion.getStackVersion());\n              responses.add(response);\n            }\n            break;\n          }\n        }\n      }\n    } else if (null != versionDefinitionId) {\n      VersionDefinitionXml xml = ambariMetaInfo.getVersionDefinition(versionDefinitionId);\n      if (null == xml) {\n        throw new AmbariException(String.format(\"Version identified by %s does not exist\",\n            versionDefinitionId));\n      }\n      StackId stackId = new StackId(xml.release.stackId);\n      ListMultimap<String, RepositoryInfo> stackRepositoriesByOs = ambariMetaInfo.getStackManager().getStack(stackName, stackVersion).getRepositoriesByOs();\n      for (RepositoryXml.Os os : xml.repositoryInfo.getOses()) {\n        for (RepositoryXml.Repo repo : os.getRepos()) {\n          RepositoryResponse resp = new RepositoryResponse(repo.getBaseUrl(), os.getFamily(),\n              repo.getRepoId(), repo.getRepoName(), repo.getDistribution(), repo.getComponents(), repo.getMirrorsList(),\n              repo.getBaseUrl(), repo.getTags(), Collections.EMPTY_LIST);\n          resp.setVersionDefinitionId(versionDefinitionId);\n          resp.setStackName(stackId.getStackName());\n          resp.setStackVersion(stackId.getStackVersion());\n          responses.add(resp);\n        }\n      }\n      // Add service repos to the response. (These are not contained by the VDF but are present in the stack model)\n      List<RepositoryInfo> serviceRepos =\n          RepoUtil.getServiceRepos(xml.repositoryInfo.getRepositories(), stackRepositoriesByOs);\n      responses.addAll(RepoUtil.asResponses(serviceRepos, versionDefinitionId, stackName, stackVersion));\n    } else {\n      if (repoId == null) {\n        List<RepositoryInfo> repositories = ambariMetaInfo.getRepositories(stackName, stackVersion, osType);\n        for (RepositoryInfo repository: repositories) {\n          responses.add(repository.convertToResponse());\n        }\n      } else {\n        RepositoryInfo repository = ambariMetaInfo.getRepository(stackName, stackVersion, osType, repoId);\n        responses = Collections.singleton(repository.convertToResponse());\n      }\n    }\n    return responses;\n  }\n  @Override\n  public void verifyRepositories(Set<RepositoryRequest> requests) throws AmbariException {\n    for (RepositoryRequest request: requests) {\n      if (request.getBaseUrl() == null) {\n        throw new AmbariException(\"Base url is missing for request \" + request);\n      }\n      verifyRepository(request);\n    }\n  }\n  /**\n   * Verifies single repository, see {{@link #verifyRepositories(Set)}.\n   *\n   * @param request request\n   * @throws AmbariException if verification fails\n   */\n<fim_suffix>  private void verifyRepository(RepositoryRequest request) throws AmbariException {\n    URLStreamProvider usp = new URLStreamProvider(REPO_URL_CONNECT_TIMEOUT, REPO_URL_READ_TIMEOUT, null, null, null);\n    usp.setSetupTruststoreForHttps(false);\n    String repoName = request.getRepoName();\n    if (StringUtils.isEmpty(repoName)) {\n      throw new IllegalArgumentException(\"repo_name is required to verify repository\");\n    }\n    String errorMessage = null;\n    Exception e = null;\n    String[] suffixes = configs.getRepoValidationSuffixes(request.getOsType());\n    for (String suffix : suffixes) {\n      String formatted_suffix = String.format(suffix, repoName);\n      String spec = request.getBaseUrl().trim();\n      // This logic is to identify if the end of baseurl has a slash ('/') and/or the beginning of suffix String (e.g. \"/repodata/repomd.xml\")\n      // has a slash and they can form a good url.\n      // e.g. \"http://baseurl.com/\" + \"/repodata/repomd.xml\" becomes \"http://baseurl.com/repodata/repomd.xml\" but not \"http://baseurl.com//repodata/repomd.xml\"\n      if (spec.charAt(spec.length() - 1) != '/' && formatted_suffix.charAt(0) != '/') {\n        spec = spec + \"/\" + formatted_suffix;\n      } else if (spec.charAt(spec.length() - 1) == '/' && formatted_suffix.charAt(0) == '/') {\n        spec = spec + formatted_suffix.substring(1);\n      } else {\n        spec = spec + formatted_suffix;\n      }\n      // if spec contains \"file://\" then check local file system.\n      final String FILE_SCHEME = \"file://\";\n      if(spec.toLowerCase().startsWith(FILE_SCHEME)){\n        String filePath = spec.substring(FILE_SCHEME.length());\n        File f = new File(filePath);\n        if(!f.exists()){\n          errorMessage = \"Could not access base url . \" + spec + \" . \";\n          e = new FileNotFoundException(errorMessage);\n          break;\n        }\n      }else{\n        try {\n          IOUtils.readLines(usp.readFrom(spec));\n        } catch (IOException ioe) {\n          e = ioe;\n          errorMessage = \"Could not access base url . \" + request.getBaseUrl() + \" . \";\n          if (LOG.isDebugEnabled()) {\n            errorMessage += ioe;\n          } else {\n            errorMessage += ioe.getMessage();\n          }\n          break;\n        }\n      }\n    }\n    if (e != null) {\n      LOG.error(errorMessage);\n      throw new IllegalArgumentException(errorMessage, e);\n    }\n  }<fim_middle>// function below is long method\n"}