{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 Pivotal, Inc.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Pivotal, Inc. - initial API and implementation\n *******************************************************************************/\npackage org.springframework.ide.vscode.commons.yaml.util;\n\nimport org.springframework.ide.vscode.commons.util.Assert;\nimport org.springframework.ide.vscode.commons.util.StringUtil;\nimport org.springframework.ide.vscode.commons.util.text.IDocument;\nimport org.springframework.ide.vscode.commons.yaml.structure.YamlDocument;\nimport org.springframework.ide.vscode.commons.yaml.structure.YamlStructureParser.SNode;\nimport org.springframework.ide.vscode.commons.yaml.structure.YamlStructureParser.SNodeType;\n\nimport com.google.common.base.Strings;\n\n/**\n * Helper methods to manipulate indentation levels in yaml content.\n *\n * @author Kris De Volder\n */\npublic class YamlIndentUtil {\n\n\t/**\n\t * Number of indentation levels (spaces) added between a child and parent.\n\t * TODO: replace this constant by (existing!) yedit preference value\n\t */\n\tpublic static final int INDENT_BY = 2;\n\n\tpublic static final String INDENT_STR = Strings.repeat(\" \", INDENT_BY);\n\n\t/**\n\t * Some functions introduce line separators and this may depend on the context (i.e. default line separator\n\t * for the current document).\n\t */\n\tpublic final String NEWLINE;\n\n\tpublic YamlIndentUtil(String newline) {\n\t\tthis.NEWLINE = newline;\n\t\tAssert.isNotNull(NEWLINE);\n\t}\n\n\tpublic YamlIndentUtil(YamlDocument doc) {\n\t\tthis(doc.getDocument());\n\t}\n\n\tpublic YamlIndentUtil(IDocument doc) {\n\t\tthis(doc.getDefaultLineDelimiter());\n\t}\n\n\t/**\n\t * Determine the 'known minimum' of two indentation levels. Correctly handle\n\t * when either one or both indent levels are '-1' (unknown).\n\t */\n\tpublic static int minIndent(int a, int b) {\n\t\tif (a==-1) {\n\t\t\treturn b;\n\t\t} else if (b==-1) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn Math.min(a, b);\n\t\t}\n\t}\n\n\tpublic static void addIndent(int indent, StringBuilder buf) {\n\t\tfor (int i = 0; i < indent; i++) {\n\t\t\tbuf.append(' ');\n\t\t}\n\t}\n\n\tpublic void addNewlineWithIndent(int indent, StringBuilder buf) {\n\t\tbuf.append(NEWLINE);\n\t\taddIndent(indent, buf);\n\t}\n\n<fim_suffix>\tpublic String newlineWithIndent(int indent) {\n\t\tStringBuilder buf = new StringBuilder();\n\t\taddNewlineWithIndent(indent, buf);\n\t\treturn buf.toString();\n\t}\n\n\tpublic String indentString(int indent) {\n\t\tStringBuilder buf = new StringBuilder();\n\t\taddIndent(indent, buf);\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t * Applies a certain level of indentation to all new lines in the given text. Newlines\n\t * are expressed by '\\n' characters in the text will be replaced by the appropriate\n\t * newline + indent.\n\t * <p>\n\t * Notes:\n\t *  - '\\n' are replaced by the default line delimeter for the current document.\n\t *  - indentation is not applied to the first line of text.\n\t *  - negative indentations are support and result in removing upto that number of spaces after each newline\n\t */\n\tpublic String applyIndentation(String text, int indentBy) {\n\t\tif (indentBy>0) {\n\t\t\treturn text.replaceAll(\"\\\\n\", newlineWithIndent(indentBy));\n\t\t} else if (indentBy<0) {\n\t\t\tint dedentBy = - indentBy;\n\t\t\tStringBuilder dedented = new StringBuilder();\n\t\t\tboolean first = true;\n\t\t\tfor (String line : StringUtil.split(text, '\\n')) {\n\t\t\t\tif (!first) {\n\t\t\t\t\tdedented.append('\\n');\n\t\t\t\t\tline = dedentLine(line, dedentBy);\n\t\t\t\t}\n\t\t\t\tdedented.append(line);\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\treturn dedented.toString();\n\t\t} else { // indentBy==0\n\t\t\treturn text;\n\t\t}\n\t}\n\n\tprivate String dedentLine(String line, int dedentBy) {\n\t\tint i = 0;\n\t\twhile (i<line.length() && i<dedentBy && line.charAt(i)==' ') {\n\t\t\ti++;\n\t\t}\n\t\treturn line.substring(i);\n\t}\n\n\tpublic String applyIndentation(String text, String indentStr) {\n\t\treturn text.replaceAll(\"\\\\n\", \"\\n\"+indentStr);\n\t}\n\n\tpublic static int getNewChildKeyIndent(SNode parent) {\n\t\tif (parent.getNodeType()==SNodeType.DOC) {\n\t\t\treturn parent.getIndent();\n\t\t} else {\n\t\t\treturn parent.getIndent()+INDENT_BY;\n\t\t}\n\t}\n\n\t/**\n\t * Increase offset by indentation. Take care when 'indent' is -1 (unkownn) to\n\t * just return offset unmodified.\n\t */\n\tpublic static int addToOffset(int offset, int indent) {\n\t\tif (indent==-1) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn offset + indent;\n\t}\n\n\t/**\n\t * Add given offset to an indent, correctly handling the case\n\t * were the indent is -1 (unknown)\n\t */\n\tpublic static int add(int indent, int adjustment) {\n\t\tif (indent==-1) {\n\t\t\treturn indent; //indent remains unknown\n\t\t}\n\t\tindent += adjustment;\n\t\treturn indent>=0 ? indent : 0;\n\t}\n\n}<fim_middle>// function below has no smell\n"}