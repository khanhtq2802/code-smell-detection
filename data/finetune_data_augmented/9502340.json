{"text": "<fim_prefix>      this.namenode = proxyInfo.getProxy();\n    } else if (rpcNamenode != null) {\n      // This case is used for testing.\n      Preconditions.checkArgument(nameNodeUri == null);\n      this.namenode = rpcNamenode;\n      dtService = null;\n    } else {\n      Preconditions.checkArgument(nameNodeUri != null,\n          \"null URI\");\n      proxyInfo = NameNodeProxiesClient.createProxyWithClientProtocol(conf,\n          nameNodeUri, nnFallbackToSimpleAuth);\n      this.dtService = proxyInfo.getDelegationTokenService();\n      this.namenode = proxyInfo.getProxy();\n    }\n    String localInterfaces[] =\n        conf.getTrimmedStrings(DFS_CLIENT_LOCAL_INTERFACES);\n    localInterfaceAddrs = getLocalInterfaceAddrs(localInterfaces);\n    if (LOG.isDebugEnabled() && 0 != localInterfaces.length) {\n      LOG.debug(\"Using local interfaces [\" +\n          Joiner.on(',').join(localInterfaces)+ \"] with addresses [\" +\n          Joiner.on(',').join(localInterfaceAddrs) + \"]\");\n    }\n    Boolean readDropBehind =\n        (conf.get(DFS_CLIENT_CACHE_DROP_BEHIND_READS) == null) ?\n            null : conf.getBoolean(DFS_CLIENT_CACHE_DROP_BEHIND_READS, false);\n    Long readahead = (conf.get(DFS_CLIENT_CACHE_READAHEAD) == null) ?\n        null : conf.getLongBytes(DFS_CLIENT_CACHE_READAHEAD, 0);\n    this.serverDefaultsValidityPeriod =\n            conf.getLong(DFS_CLIENT_SERVER_DEFAULTS_VALIDITY_PERIOD_MS_KEY,\n      DFS_CLIENT_SERVER_DEFAULTS_VALIDITY_PERIOD_MS_DEFAULT);\n    Boolean writeDropBehind =\n        (conf.get(DFS_CLIENT_CACHE_DROP_BEHIND_WRITES) == null) ?\n            null : conf.getBoolean(DFS_CLIENT_CACHE_DROP_BEHIND_WRITES, false);\n    this.defaultReadCachingStrategy =\n        new CachingStrategy(readDropBehind, readahead);\n    this.defaultWriteCachingStrategy =\n        new CachingStrategy(writeDropBehind, readahead);\n    this.clientContext = ClientContext.get(\n        conf.get(DFS_CLIENT_CONTEXT, DFS_CLIENT_CONTEXT_DEFAULT),\n        dfsClientConf, conf);\n    if (dfsClientConf.getHedgedReadThreadpoolSize() > 0) {\n      this.initThreadsNumForHedgedReads(dfsClientConf.\n          getHedgedReadThreadpoolSize());\n    }\n    this.initThreadsNumForStripedReads(dfsClientConf.\n        getStripedReadThreadpoolSize());\n    this.saslClient = new SaslDataTransferClient(\n        conf, DataTransferSaslUtil.getSaslPropertiesResolver(conf),\n        TrustedChannelResolver.getInstance(conf), nnFallbackToSimpleAuth);\n  }\n  /**\n   * Return the socket addresses to use with each configured\n   * local interface. Local interfaces may be specified by IP\n   * address, IP address range using CIDR notation, interface\n   * name (e.g. eth0) or sub-interface name (e.g. eth0:0).\n   * The socket addresses consist of the IPs for the interfaces\n   * and the ephemeral port (port 0). If an IP, IP range, or\n   * interface name matches an interface with sub-interfaces\n   * only the IP of the interface is used. Sub-interfaces can\n   * be used by specifying them explicitly (by IP or name).\n   *\n   * @return SocketAddresses for the configured local interfaces,\n   *    or an empty array if none are configured\n   * @throws UnknownHostException if a given interface name is invalid\n   */\n  private static SocketAddress[] getLocalInterfaceAddrs(\n      String interfaceNames[]) throws UnknownHostException {\n    List<SocketAddress> localAddrs = new ArrayList<>();\n    for (String interfaceName : interfaceNames) {\n      if (InetAddresses.isInetAddress(interfaceName)) {\n        localAddrs.add(new InetSocketAddress(interfaceName, 0));\n      } else if (NetUtils.isValidSubnet(interfaceName)) {\n        for (InetAddress addr : NetUtils.getIPs(interfaceName, false)) {\n          localAddrs.add(new InetSocketAddress(addr, 0));\n        }\n      } else {\n        for (String ip : DNS.getIPs(interfaceName, false)) {\n          localAddrs.add(new InetSocketAddress(ip, 0));\n        }\n      }\n    }\n    return localAddrs.toArray(new SocketAddress[localAddrs.size()]);\n  }\n  /**\n   * Select one of the configured local interfaces at random. We use a random\n   * interface because other policies like round-robin are less effective\n   * given that we cache connections to datanodes.\n   *\n   * @return one of the local interface addresses at random, or null if no\n   *    local interfaces are configured\n   */\n  SocketAddress getRandomLocalInterfaceAddr() {\n    if (localInterfaceAddrs.length == 0) {\n      return null;\n    }\n    final int idx = r.nextInt(localInterfaceAddrs.length);\n    final SocketAddress addr = localInterfaceAddrs[idx];\n    LOG.debug(\"Using local interface {}\", addr);\n    return addr;\n  }\n  /**\n   * Return the timeout that clients should use when writing to datanodes.\n   * @param numNodes the number of nodes in the pipeline.\n   */\n  int getDatanodeWriteTimeout(int numNodes) {\n    final int t = dfsClientConf.getDatanodeSocketWriteTimeout();\n    return t > 0? t + HdfsConstants.WRITE_TIMEOUT_EXTENSION*numNodes: 0;\n  }\n  int getDatanodeReadTimeout(int numNodes) {\n    final int t = dfsClientConf.getSocketTimeout();\n    return t > 0? HdfsConstants.READ_TIMEOUT_EXTENSION*numNodes + t: 0;\n  }\n  @VisibleForTesting\n  public String getClientName() {\n    return clientName;\n  }\n  void checkOpen() throws IOException {\n    if (!clientRunning) {\n      throw new IOException(\"Filesystem closed\");\n    }\n  }\n  /** Return the lease renewer instance. The renewer thread won't start\n   *  until the first output stream is created. The same instance will\n   *  be returned until all output streams are closed.\n   */\n  public LeaseRenewer getLeaseRenewer() {\n    return LeaseRenewer.getInstance(\n        namenodeUri != null ? namenodeUri.getAuthority() : \"null\", ugi, this);\n  }\n  /** Get a lease and start automatic renewal */\n  private void beginFileLease(final long inodeId, final DFSOutputStream out)\n      throws IOException {\n    synchronized (filesBeingWritten) {\n      putFileBeingWritten(inodeId, out);\n      getLeaseRenewer().put(this);\n    }\n  }\n  /** Stop renewal of lease for the file. */\n  void endFileLease(final long inodeId) {\n    synchronized (filesBeingWritten) {\n      removeFileBeingWritten(inodeId);\n      // remove client from renewer if no files are open\n      if (filesBeingWritten.isEmpty()) {\n        getLeaseRenewer().closeClient(this);\n      }\n    }\n  }\n  /** Put a file. Only called from LeaseRenewer, where proper locking is\n   *  enforced to consistently update its local dfsclients array and\n   *  client's filesBeingWritten map.\n   */\n  public void putFileBeingWritten(final long inodeId,\n      final DFSOutputStream out) {\n    synchronized(filesBeingWritten) {\n      filesBeingWritten.put(inodeId, out);\n      // update the last lease renewal time only when there was no\n      // writes. once there is one write stream open, the lease renewer\n      // thread keeps it updated well with in anyone's expiration time.\n      if (lastLeaseRenewal == 0) {\n        updateLastLeaseRenewal();\n      }\n    }\n  }\n  /** Remove a file. Only called from LeaseRenewer. */\n<fim_suffix>  public void removeFileBeingWritten(final long inodeId) {\n    synchronized(filesBeingWritten) {\n      filesBeingWritten.remove(inodeId);\n      if (filesBeingWritten.isEmpty()) {\n        lastLeaseRenewal = 0;\n      }\n    }\n  }<fim_middle>// function below has no smell\n"}