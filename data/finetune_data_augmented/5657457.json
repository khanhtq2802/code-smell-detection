{"text": "<fim_prefix> *   <tr><td>    </td> <td>          </td> <td>{@code num_col}</td> <td>3</td></tr>\n *   <tr><td>8623</td> <td>{@code A0}</td> <td>{@code elt_0_0}</td> <td>1</td></tr>\n *   <tr><td>8624</td> <td>{@code A1}</td> <td>{@code elt_0_1}</td> <td>0</td></tr>\n *   <tr><td>8625</td> <td>{@code A2}</td> <td>{@code elt_0_2}</td> <td>0</td></tr>\n *   <tr><td>8639</td> <td>{@code B0}</td> <td>{@code elt_1_0}</td> <td>0</td></tr>\n *   <tr><td>8640</td> <td>{@code B1}</td> <td>{@code elt_1_1}</td> <td>1</td></tr>\n *   <tr><td>8641</td> <td>{@code B2}</td> <td>{@code elt_1_2}</td> <td>0</td></tr>\n *   <tr><td>    </td> <td>          </td> <td>{@code elt_2_0}</td> <td>0</td></tr>\n *   <tr><td>    </td> <td>          </td> <td>{@code elt_2_1}</td> <td>0</td></tr>\n *   <tr><td>    </td> <td>          </td> <td>{@code elt_2_2}</td> <td>1</td></tr>\n * </table>\n *\n * @author  Martin Desruisseaux (IRD, Geomatys)\n * @version 0.8\n * @since   0.5\n * @module\n */\n@XmlTransient\npublic final class Affine extends AbstractProvider {\n    /**\n     * Serial number for inter-operability with different versions.\n     */\n    private static final long serialVersionUID = 649555815622129472L;\n    /**\n     * The operation method name as defined in the EPSG database.\n     * Must matches exactly the EPSG name (this will be verified by JUnit tests).\n     *\n     * <p>Note: in contrast, the name used by OGC is just \"Affine\".</p>\n     *\n     * @see org.apache.sis.internal.util.Constants#AFFINE\n     */\n    public static final String NAME = \"Affine parametric transformation\";\n    /**\n     * The EPSG:9624 compliant instance, created when first needed.\n     */\n    private static volatile Affine EPSG_METHOD;\n    /**\n     * The number of dimensions used by the EPSG:9624 definition. This will be used as the\n     * default number of dimensions. Operation methods of other dimensions, where we have\n     * no EPSG definition, shall use the Well Known Text (WKT) parameter names.\n     */\n    public static final int EPSG_DIMENSION = 2;\n    /**\n     * The maximal number of dimensions to be cached. Descriptors having more than\n     * this amount of dimensions will be recreated every time they are requested.\n     */\n    private static final int MAX_CACHED_DIMENSION = 6;\n    /**\n     * Cached providers for methods of dimension 1\u00d71 to {@link #MAX_CACHED_DIMENSION}.\n     * The index of each element is computed by {@link #cacheIndex(int, int)}.\n     * All usages of this array shall be synchronized on {@code cached}.\n     */\n    private static final Affine[] cached = new Affine[MAX_CACHED_DIMENSION * MAX_CACHED_DIMENSION];\n    /**\n     * A map containing identification properties for creating {@code OperationMethod} or\n     * {@code ParameterDescriptorGroup} instances.\n     */\n    private static final Map<String,?> IDENTIFICATION_EPSG, IDENTIFICATION_OGC;\n    static {\n        final NamedIdentifier nameOGC = new NamedIdentifier(Citations.OGC, Constants.OGC, Constants.AFFINE, null, null);\n        IDENTIFICATION_OGC = Collections.singletonMap(NAME_KEY, nameOGC);\n        IDENTIFICATION_EPSG = EPSGName.properties(9624, NAME, nameOGC);\n    }\n    /**\n     * Creates a provider for affine transform with a default matrix size (standard EPSG:9624 instance).\n     * This constructor is public for the needs of {@link java.util.ServiceLoader} \u2014 do not invoke explicitly.\n     * If an instance of {@code Affine()} is desired, invoke {@code getProvider(EPSG_DIMENSION, EPSG_DIMENSION)}\n     * instead.\n     *\n     * @see org.apache.sis.referencing.operation.transform.DefaultMathTransformFactory\n     */\n    public Affine() {\n        super(IDENTIFICATION_EPSG, EPSG_DIMENSION, EPSG_DIMENSION, new Descriptor(IDENTIFICATION_EPSG,\n                Arrays.copyOfRange( // Discards param 0 and 1, take only the ones in index range [2\u20267].\n                        TensorParameters.ALPHANUM.getAllDescriptors(EPSG_DIMENSION, EPSG_DIMENSION + 1), 2, 8)));\n        /*\n         * Do caching ourselves because this constructor is usually not invoked by getProvider(int, int).\n         * It is usually invoked when DefaultMathTransformFactory scans the classpath with a ServiceLoader.\n         * This normally happen only once, so this instance is probably the unique instance to keep in the JVM.\n         */\n        EPSG_METHOD = this;\n    }\n    /**\n     * Creates a provider for affine transform with the specified dimensions.\n     * This is created when first needed by {@link #getProvider(int, int, boolean)}.\n     *\n     * @see #getProvider(int, int, boolean)\n     */\n    private Affine(final int sourceDimensions, final int targetDimensions) {\n        super(IDENTIFICATION_OGC, sourceDimensions, targetDimensions, new Descriptor(IDENTIFICATION_OGC,\n                TensorParameters.WKT1.getAllDescriptors(targetDimensions + 1, sourceDimensions + 1)));\n    }\n    /**\n     * The parameter descriptor to be returned by {@link Affine#getParameters()}.\n     * The only purpose of this class is to override the {@link #createValue()} method.\n     */\n    private static final class Descriptor extends DefaultParameterDescriptorGroup {\n        /** For cross-version compatibility. */\n        private static final long serialVersionUID = 8320799650519834830L;\n        /** Creates a new descriptor for the given parameters. */\n        Descriptor(final Map<String,?> properties, final ParameterDescriptor<?>[] parameters) {\n            super(properties, 1, 1, parameters);\n        }\n        /**\n         * Returns default parameter values for the \"Affine\" operation. Unconditionally use the WKT1 parameter names,\n         * regardless of whether this descriptor is for the EPSG:9624 case, because the caller is free to change the\n         * matrix size, in which case (strictly speaking) the parameters would no longer be for EPSG:9624 operation.\n         */\n        @Override\n        public ParameterValueGroup createValue() {\n            return TensorParameters.WKT1.createValueGroup(IDENTIFICATION_OGC);\n        }\n    }\n    /*\n     * Do not override the 'getOperationType()' method. We want to inherit the super-type value, which is\n     * SingleOperation.class, because we do not know if this operation method will be used for a Conversion\n     * or a Transformation. When applied on geocentric coordinates, this method applies a transformation\n     * (indeeded, the EPSG method name is \"Affine parametric transformation\"). But this method can also\n     * be applied for unit conversions or axis swapping for examples, which are conversions.\n     */\n    /**\n     * The inverse of this operation can be described by the same operation with different parameter values.\n     *\n     * @return {@code true} for all {@code Affine}.\n     */\n    @Override\n    public final boolean isInvertible() {\n        return true;\n    }\n    /**\n     * Creates a projective transform from the specified group of parameter values.\n     *\n     * @param  factory  ignored (can be null).\n     * @param  values   the group of parameter values.\n     * @return the created math transform.\n     * @throws ParameterNotFoundException if a required parameter was not found.\n     */\n<fim_suffix>    @Override\n    public MathTransform createMathTransform(final MathTransformFactory factory, final ParameterValueGroup values)\n            throws ParameterNotFoundException\n    {\n        /*\n         * The TensorParameters constant used below (WKT1 or EPSG) does not matter,\n         * since both of them understand the names of the other TensorParameters.\n         */\n        return MathTransforms.linear(TensorParameters.WKT1.toMatrix(values));\n    }<fim_middle>// function below has no smell\n"}