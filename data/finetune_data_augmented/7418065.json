{"text": "<fim_prefix>    private static final int LLVM_DBG_VALUE_LOCALREF_ARGINDEX_OLD = 2;\n    private static final int LLVM_DBG_VALUE_EXPR_ARGINDEX_OLD = 3;\n    private static final int LLVM_DBG_VALUE_LOCALREF_ARGSIZE_OLD = 4;\n    private static final int LLVM_DBG_VALUE_LOCALREF_ARGINDEX_NEW = 1;\n    private static final int LLVM_DBG_VALUE_EXPR_ARGINDEX_NEW = 2;\n    private static final int LLVM_DBG_VALUE_LOCALREF_ARGSIZE_NEW = 3;\n    private static final String LLVM_DEBUGTRAP_NAME = \"@llvm.debugtrap\";\n    private final DebugInfoCache cache;\n    DebugInfoFunctionProcessor(DebugInfoCache cache) {\n        this.cache = cache;\n    }\n    public void process(FunctionDefinition function, IRScope scope, Source bitcodeSource, LLVMContext context) {\n        ImportsProcessor.process(scope.getMetadata(), context, cache);\n        initSourceFunction(function, bitcodeSource);\n        function.accept((FunctionVisitor) new SymbolProcessor(function.getSourceFunction()));\n        scope.getMetadata().consumeLocals(new MetadataProcessor());\n        for (SourceVariable local : function.getSourceFunction().getVariables()) {\n            local.processFragments();\n        }\n        cache.endLocalScope();\n    }\n    private void initSourceFunction(FunctionDefinition function, Source bitcodeSource) {\n        final MDBaseNode debugInfo = getDebugInfo(function);\n        LLVMSourceLocation scope = null;\n        LLVMSourceFunctionType type = null;\n        if (debugInfo != null) {\n            scope = cache.buildLocation(debugInfo);\n            LLVMSourceType actualType = cache.parseType(debugInfo);\n            if (actualType instanceof LLVMSourceFunctionType) {\n                type = (LLVMSourceFunctionType) actualType;\n            }\n        }\n        if (scope == null) {\n            final String sourceText = String.format(\"%s:%s\", bitcodeSource.getName(), function.getName());\n            final Source irSource = Source.newBuilder(\"llvm\", sourceText, sourceText).mimeType(DIScopeBuilder.getMimeType(null)).build();\n            final SourceSection simpleSection = irSource.createSection(1);\n            scope = LLVMSourceLocation.createBitcodeFunction(function.getName(), simpleSection);\n        }\n        final SourceFunction sourceFunction = new SourceFunction(scope, type);\n        function.setSourceFunction(sourceFunction);\n    }\n    private static SymbolImpl getArg(VoidCallInstruction call, int index) {\n        return index < call.getArgumentCount() ? call.getArgument(index) : null;\n    }\n    private static MDExpression getExpression(VoidCallInstruction call, int index) {\n        final SymbolImpl argSymbol = getArg(call, index);\n        if (argSymbol instanceof MetadataSymbol) {\n            final MDBaseNode mdNode = ((MetadataSymbol) argSymbol).getNode();\n            if (mdNode instanceof MDExpression) {\n                return (MDExpression) mdNode;\n            }\n        }\n        return MDExpression.EMPTY;\n    }\n<fim_suffix>    private final class SymbolProcessor implements FunctionVisitor, InstructionVisitorAdapter {\n        private final SourceFunction function;\n        private final LinkedList<Integer> removeFromBlock = new LinkedList<>();\n        private int blockInstIndex = 0;\n        private DbgValueInstruction lastDbgValue = null;\n        private InstructionBlock currentBlock = null;\n        private SymbolProcessor(SourceFunction function) {\n            this.function = function;\n        }\n        @Override\n        public void visit(InstructionBlock block) {\n            currentBlock = block;\n            lastDbgValue = null;\n            for (blockInstIndex = 0; blockInstIndex < block.getInstructionCount(); blockInstIndex++) {\n                block.getInstruction(blockInstIndex).accept(this);\n            }\n            if (!removeFromBlock.isEmpty()) {\n                for (int i : removeFromBlock) {\n                    currentBlock.remove(i);\n                }\n                removeFromBlock.clear();\n            }\n        }\n        @Override\n        public void visitInstruction(Instruction instruction) {\n            final MDLocation loc = instruction.getDebugLocation();\n            if (loc != null) {\n                final LLVMSourceLocation scope = cache.buildLocation(loc);\n                if (scope != null) {\n                    instruction.setSourceLocation(scope);\n                }\n            }\n        }\n        @Override\n        public void visit(VoidCallInstruction call) {\n            final SymbolImpl callTarget = call.getCallTarget();\n            if (callTarget instanceof FunctionDeclaration) {\n                switch (((FunctionDeclaration) callTarget).getName()) {\n                    case LLVM_DBG_DECLARE_NAME:\n                        handleDebugIntrinsic(call, true);\n                        return;\n                    case LLVM_DBG_ADDR_NAME:\n                        // dbg.declare and dbg.addr have the same interface and, for our purposes,\n                        // the same semantics\n                        handleDebugIntrinsic(call, true);\n                        return;\n                    case LLVM_DBG_VALUE_NAME:\n                        handleDebugIntrinsic(call, false);\n                        return;\n                    case LLVM_DEBUGTRAP_NAME:\n                        visitDebugTrap(call);\n                        return;\n                }\n            }\n            visitInstruction(call);\n        }\n        private void visitDebugTrap(VoidCallInstruction call) {\n            final DebugTrapInstruction trap = DebugTrapInstruction.create(call);\n            currentBlock.set(blockInstIndex, trap);\n            visitInstruction(trap);\n        }\n        private SourceVariable getVariable(VoidCallInstruction call, int index) {\n            final SymbolImpl varSymbol = getArg(call, index);\n            if (varSymbol instanceof MetadataSymbol) {\n                final MDBaseNode mdLocal = ((MetadataSymbol) varSymbol).getNode();\n                final LLVMSourceSymbol symbol = cache.getSourceSymbol(mdLocal, false);\n                return function.getLocal(symbol);\n            }\n            return null;\n        }\n        private void handleDebugIntrinsic(VoidCallInstruction call, boolean isDeclaration) {\n            SymbolImpl value = getArg(call, LLVM_DBG_INTRINSICS_VALUE_ARGINDEX);\n            if (value instanceof MetadataSymbol) {\n                value = MDSymbolExtractor.getSymbol(((MetadataSymbol) value).getNode());\n            }\n            if (value == null) {\n                // this may happen if llvm optimizations removed a variable\n                value = new NullConstant(MetaType.DEBUG);\n            } else if (value instanceof ValueInstruction) {\n                ((ValueInstruction) value).setSourceVariable(true);\n            } else if (value instanceof FunctionParameter) {\n                ((FunctionParameter) value).setSourceVariable(true);\n            }\n            int mdLocalArgIndex;\n            int mdExprArgIndex;\n            if (isDeclaration) {\n                mdLocalArgIndex = LLVM_DBG_DECLARE_LOCALREF_ARGINDEX;\n                mdExprArgIndex = LLVM_DBG_DECLARE_EXPR_ARGINDEX;\n            } else if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_NEW) {\n                mdLocalArgIndex = LLVM_DBG_VALUE_LOCALREF_ARGINDEX_NEW;\n                mdExprArgIndex = LLVM_DBG_VALUE_EXPR_ARGINDEX_NEW;\n            } else if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_OLD) {\n                mdLocalArgIndex = LLVM_DBG_VALUE_LOCALREF_ARGINDEX_OLD;\n                mdExprArgIndex = LLVM_DBG_VALUE_EXPR_ARGINDEX_OLD;\n            } else {\n                return;\n            }\n            final SourceVariable variable = getVariable(call, mdLocalArgIndex);\n            if (variable == null) {\n                // invalid or unsupported debug information\n                // remove upper indices so we do not need to update the later ones\n                removeFromBlock.addFirst(blockInstIndex);\n                return;\n            }\n            final MDExpression expression = getExpression(call, mdExprArgIndex);\n            if (ValueFragment.describesFragment(expression)) {\n                variable.addFragment(ValueFragment.parse(expression));\n            } else {\n                variable.addFullDefinition();\n            }\n            if (isDeclaration) {\n                final DbgDeclareInstruction dbgDeclare = new DbgDeclareInstruction(value, variable, expression);\n                variable.addDeclaration(dbgDeclare);\n                currentBlock.set(blockInstIndex, dbgDeclare);\n            } else {\n                long index = 0;\n                if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_OLD) {\n                    final SymbolImpl indexSymbol = call.getArgument(LLVM_DBG_VALUE_INDEX_ARGINDEX_OLD);\n                    final Long l = LLVMSymbolReadResolver.evaluateLongIntegerConstant(indexSymbol);\n                    if (l != null) {\n                        index = l;\n                    }\n                }\n                final DbgValueInstruction dbgValue = new DbgValueInstruction(value, variable, index, expression);\n                if (dbgValue.equals(lastDbgValue)) {\n                    // at higher optimization levels llvm often duplicates the @llvm.dbg.value\n                    // intrinsic call, we remove it again to avoid unnecessary runtime overhead\n                    removeFromBlock.addFirst(blockInstIndex);\n                } else {\n                    variable.addValue(dbgValue);\n                    currentBlock.set(blockInstIndex, dbgValue);\n                    lastDbgValue = dbgValue;\n                }\n            }\n        }\n    }<fim_middle>// class below is blob\n"}