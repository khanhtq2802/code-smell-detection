{"text": "<fim_prefix>      }\n      break;\n    }\n    // Now, look at the result signal, and set up the version appropriately.\n    if (activityResultCode != null)\n      activities.recordActivity(null,ACTIVITY_FETCH,null,documentIdentifier,activityResultCode,fetchStatus.contextMessage,null);\n  }\n  protected void processDocument(IProcessActivity activities, String documentIdentifier, String versionString,\n    boolean indexDocument, Map<String,Set<String>> metaHash, String[] acls, DocumentURLFilter filter)\n    throws ManifoldCFException, ServiceInterruption\n  {\n    // Consider this document for ingestion.\n    String errorCode = null;\n    String errorDesc = null;\n    Long fileLengthLong = null;\n    long startTime = System.currentTimeMillis();\n    try\n    {\n      // We can exclude it if it does not seem to be a kind of document that the ingestion system knows\n      // about.\n      if (!indexDocument)\n      {\n        errorCode = \"CONTENTNOTINDEXABLE\";\n        errorDesc = \"Content not indexable\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      int responseCode = cache.getResponseCode(documentIdentifier);\n      if (responseCode != 200)\n      {\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because response code not indexable: \"+responseCode);\n        errorCode = \"RESPONSECODENOTINDEXABLE\";\n        errorDesc = \"HTTP response code not indexable (\"+responseCode+\")\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      long dataLength = cache.getDataLength(documentIdentifier);\n      if (!activities.checkLengthIndexable(dataLength))\n      {\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because pipeline thinks length \"+dataLength+\" is not acceptable\");\n        errorCode = activities.EXCLUDED_LENGTH;\n        errorDesc = \"Rejected due to length (\"+dataLength+\")\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      if (activities.checkURLIndexable(documentIdentifier) == false)\n      {\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because output connector does not want URL\");\n        errorCode = activities.EXCLUDED_URL;\n        errorDesc = \"Rejected due to URL ('\"+documentIdentifier+\"')\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      String ingestURL = filter.isDocumentIndexable(documentIdentifier);\n      if (ingestURL == null)\n      {\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because document does not match web job constraints\");\n        errorCode = \"JOBRESTRICTION\";\n        errorDesc = \"Rejected because job excludes this URL ('\"+documentIdentifier+\"')\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      // Check if it's a recognized content type\n      String contentType = cache.getContentType(documentIdentifier);\n      // Some sites have multiple content types.  We just look at the LAST one in that case.\n      if (contentType != null)\n      {\n        String[] contentTypes = contentType.split(\",\");\n        if (contentTypes.length > 0)\n          contentType = contentTypes[contentTypes.length-1].trim();\n        else\n          contentType = null;\n      }\n      if (contentType != null)\n      {\n        int pos = contentType.indexOf(\";\");\n        if (pos != -1)\n          contentType = contentType.substring(0,pos);\n        contentType = contentType.trim();\n      }\n      if (!activities.checkMimeTypeIndexable(contentType))\n      {\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because output connector does not want mime type '\"+contentType+\"'\");\n        errorCode = activities.EXCLUDED_MIMETYPE;\n        errorDesc = \"Rejected because of mime type (\"+contentType+\")\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      if(!filter.isDocumentContentIndexable(documentIdentifier)){\n        if (Logging.connectors.isDebugEnabled())\n          Logging.connectors.debug(\"Web: For document '\"+documentIdentifier+\"', not indexing because document content matched document content exclusion rule\");\n        errorCode = activities.EXCLUDED_CONTENT;\n        errorDesc = \"Rejected due to content exclusion rule\";\n        activities.noDocument(documentIdentifier,versionString);\n        return;\n      }\n      // Ingest the document\n      if (Logging.connectors.isDebugEnabled())\n        Logging.connectors.debug(\"WEB: Decided to ingest '\"+documentIdentifier+\"'\");\n      RepositoryDocument rd = new RepositoryDocument();\n      // Set the file name\n      String fileName = \"\";\n      try {\n        fileName = documentIdentifiertoFileName(documentIdentifier);\n      } catch (URISyntaxException e1) {\n        fileName = \"\";\n      }\n      if (fileName.length() > 0){\n        rd.setFileName(fileName);\n      }\n      // Set the content type\n      String mimeType = cache.getContentType(documentIdentifier);\n      if (mimeType != null)\n        rd.setMimeType(mimeType);\n      // Turn into acls and add into description\n      String[] denyAcls;\n      if (acls == null)\n        denyAcls = null;\n      else\n      {\n        if (acls.length > 0)\n          denyAcls = new String[]{defaultAuthorityDenyToken};\n        else\n          denyAcls = new String[0];\n      }\n      if (acls != null && denyAcls != null)\n        rd.setSecurity(RepositoryDocument.SECURITY_TYPE_DOCUMENT,acls,denyAcls);\n      // Grab metadata\n      for (String key : metaHash.keySet())\n      {\n        Set<String> metaList = metaHash.get(key);\n        String[] values = new String[metaList.size()];\n        int k = 0;\n        for (String value : metaList)\n        {\n          values[k++] = value;\n        }\n        rd.addField(key,values);\n      }\n      InputStream is = cache.getData(documentIdentifier);\n      if (is != null)\n      {\n        try\n        {\n          rd.setBinary(is,dataLength);\n          try\n          {\n            activities.ingestDocumentWithException(documentIdentifier,versionString,ingestURL,rd);\n            errorCode = \"OK\";\n            fileLengthLong = new Long(dataLength);\n          }\n          catch (IOException e)\n          {\n            errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);\n            errorDesc = e.getMessage();\n            handleIOException(e,\"reading data\");\n          }\n        }\n        finally\n        {\n          try\n          {\n            is.close();\n          }\n          catch (IOException e)\n          {\n            errorCode = e.getClass().getSimpleName().toUpperCase(Locale.ROOT);\n            errorDesc = e.getMessage();\n            handleIOException(e,\"closing stream\");\n          }\n        }\n      }\n      else\n        Logging.connectors.error(\"WEB: Expected a cached document for '\"+documentIdentifier+\"', but none present!\");\n    }\n    catch (ManifoldCFException e)\n    {\n      if (e.getErrorCode() == ManifoldCFException.INTERRUPTED)\n        errorCode = null;\n      throw e;\n    }\n    finally\n    {\n      if (errorCode != null)\n        activities.recordActivity(new Long(startTime),ACTIVITY_PROCESS,\n          fileLengthLong,documentIdentifier,errorCode,errorDesc,null);\n    }\n  }\n  protected static String extractContentType(String contentType)\n  {\n    // Some sites have multiple content types.  We just look at the LAST one in that case.\n    if (contentType != null)\n    {\n      String[] contentTypes = contentType.split(\",\");\n      if (contentTypes.length > 0)\n        contentType = contentTypes[contentTypes.length-1].trim();\n      else\n        contentType = null;\n    }\n    return contentType;\n  }\n  protected static String extractEncoding(String contentType)\n  {\n    if (contentType == null)\n      return null;\n    int semiIndex = contentType.indexOf(\";\");\n    if (semiIndex == -1)\n      return null;\n    String suffix = contentType.substring(semiIndex+1);\n    suffix = suffix.trim();\n    if (suffix.startsWith(\"charset=\"))\n      return suffix.substring(\"charset=\".length());\n    return null;\n  }\n  protected static String extractMimeType(String contentType)\n  {\n    if (contentType == null)\n      return null;\n    int semiIndex = contentType.indexOf(\";\");\n    if (semiIndex != -1)\n      contentType = contentType.substring(0,semiIndex);\n    contentType = contentType.trim();\n    return contentType;\n  }\n<fim_suffix>  protected static void handleIOException(IOException e, String context)\n    throws ManifoldCFException, ServiceInterruption\n  {\n    if (e instanceof java.net.SocketException)\n      throw new ManifoldCFException(\"Socket timeout error \"+context+\": \"+e.getMessage(),e);\n    else if (e instanceof ConnectTimeoutException)\n      throw new ManifoldCFException(\"Socket connect timeout error \"+context+\": \"+e.getMessage(),e);\n    else if (e instanceof InterruptedIOException)\n      throw new ManifoldCFException(\"Interrupted: \"+e.getMessage(),e,ManifoldCFException.INTERRUPTED);\n    else\n      throw new ManifoldCFException(\"IO error \"+context+\": \"+e.getMessage(),e);\n  }<fim_middle>// function below has no smell\n"}