{"text": "<fim_prefix>\n<fim_suffix>public class WireAdminImpl implements WireAdmin, ServiceListener {\n\tprivate BundleContext m_bundleContext;\n    // A Map containing a service reference associated to a producer and a List\n    // of wire objects\t\n    private Map m_consumers = new HashMap(); /* ServiceReferences, List */\n    private Map m_producers = new HashMap(); /* ServiceReferences, List */\n\tprivate List m_wires; // List containing the wires\n\t//private BindingController wireAdminListenersBindingController;\n    // Filter corresponding to a consumer service\n\tprivate Filter m_consumerFilter;\n    //  Filter corresponding to a producer service\n\tprivate Filter m_producerFilter;\n    // EventManager\n    private EventManager m_eventManager;\n\tprivate static int m_wireCount = 0;\n    private AsyncMethodCaller m_asyncMethodCaller = new AsyncMethodCaller();        //m_eventDispatcher.stop();\n    private static PrintStream m_traceout = null;\n    private static PrintStream m_errorout = System.err;\n\t/**\n     * Constructor with package visibility\n     * \n\t * @param bundleContext the bundle context\n\t */\n\tWireAdminImpl(BundleContext bundleContext) \n    {\n\t\tm_bundleContext = bundleContext;\n        if(bundleContext.getProperty(\"fr.imag.adele.wireadmin.trace\") != null)\n        {\n            String value = bundleContext.getProperty(\"fr.imag.adele.wireadmin.trace\");\n            if(value.equals(\"true\"))\n            {\n                m_traceout = System.out;\n            }\n        }\n        // Create the event manager (the event manager will start its own thread)       \n        m_eventManager = new EventManager(m_bundleContext);\n\t\ttry \n        {\n\t\t\tm_producerFilter = m_bundleContext.createFilter(\n\t\t\t\t\t\"(objectClass=org.osgi.service.wireadmin.Producer)\");\n\t\t\tm_consumerFilter = m_bundleContext.createFilter(\n\t\t\t\t\t\"(objectClass=org.osgi.service.wireadmin.Consumer)\");\n\t\t} \n        catch (InvalidSyntaxException e) \n        {\n\t\t\t// never thrown since LDAP expressions are correct\n\t\t}\n        // Recover persistent wires\n        getPersistentWires();\n        // Activate thread that does asynchronous calls to\n        // the producersConnected and consummersConnected methods\n        new Thread(m_asyncMethodCaller).start();\n        // Gets all producers and consumers that are present at the\n        // moment the wire admin is created\n        try \n        {\n            // Registration for events must be done first, as some service\n            // can be registered during initialization\n            m_bundleContext.addServiceListener(this,\"(|\"+m_producerFilter.toString()+m_consumerFilter.toString()+\")\");\n            // Replacement for the two following lines which work under OSCAR, \n            // but not work under IBM's SMF\n            //m_bundleContext.addServiceListener(this,m_consumerFilter.toString());\n            //m_bundleContext.addServiceListener(this,m_producerFilter.toString());\n            // Get all producers\n            ServiceReference[] producerRefs = m_bundleContext.getServiceReferences(Producer.class.getName(),null);\n            if(producerRefs!=null)\n            {\n                // lock the producers Map to avoid concurrent modifications due\n                // to service events\n                synchronized(m_producers)\n                {\n                    for(int i=0;i<producerRefs.length;i++)\n                    {\n                        ServiceReference currentRef=(ServiceReference)producerRefs[i];\n                        Iterator wireIt = m_wires.iterator();\n                        while(wireIt.hasNext())\n                        {\n                            WireImpl currentWire = (WireImpl) wireIt.next();\n                            if(currentWire.getProducerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))\n                            {\n                                currentWire.bindProducer(currentRef);\n                            }\n                        }\n                        m_producers.put(currentRef,new ArrayList());\n                    }\n                }\n            }\n            // Get all the consumers\n            ServiceReference[] consumerRefs = m_bundleContext.getServiceReferences(Consumer.class.getName(),null);\n            if(consumerRefs!=null)\n            {\n                for(int i=0;i<consumerRefs.length;i++)\n                {\n                    // lock the consumers to avoid concurrent modifications due\n                    // to service events\n                    synchronized(m_consumers)\n                    {\n                        ServiceReference currentRef=(ServiceReference)consumerRefs[i];\n                        Iterator wireIt = m_wires.iterator();\n                        while(wireIt.hasNext())\n                        {\n                            WireImpl currentWire = (WireImpl) wireIt.next();\n                            if(currentWire.getConsumerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))\n                            {\n                                currentWire.bindConsumer(currentRef);\n                            }\n                        }\n                        m_consumers.put(currentRef,new ArrayList());\n                    }\n                }\n            }\n        } \n        catch (InvalidSyntaxException e) \n        {\n            trace(e);\n        }\n        // Iterate over all the wires, when a wire is connected\n        // add it to the list of wires associated to a particular\n        // producer or consumer\n        synchronized(m_wires)\n        {\n            Iterator wireIterator = m_wires.iterator();\n            while(wireIterator.hasNext())\n            {\n                WireImpl currentWire = (WireImpl) wireIterator.next();\n                if(currentWire.isConnected())\n                {                \n                    // p. 327 \"If both Producer and consumer services are registered\n                    // with the framework, they are connected by the WireAdmin service\"\n                    List wires = (List) m_producers.get(currentWire.getProducerServiceRef());\n                    wires.add(currentWire);\n                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));\n                    wires = (List) m_consumers.get(currentWire.getConsumerServiceRef());\n                    wires.add(currentWire);\n                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));\n                }            \n            }\n        }       \n\t}\n    /**\n     * Pass the service reference to the event dispatcher\n     * \n     * @param ref the service reference\n     */\n    void setServiceReference(ServiceReference ref)\n    {\n        m_eventManager.setServiceReference(ref);\n    }\n\t/**\n\t * Create a new <tt>Wire</tt> object that connects a Producer\n\t * service to a Consumer service.\n\t *\n\t * The Producer service and Consumer service do not\n\t * have to be registered when the <tt>Wire</tt> object is created.\n\t *\n\t * <p>The <tt>Wire</tt> configuration data must be persistently stored.\n\t * All <tt>Wire</tt> connections are reestablished when the\n\t * <tt>WireAdmin</tt> service is registered.\n\t * A <tt>Wire</tt> can be permanently removed by using the\n\t * {@link #deleteWire} method.\n\t *\n\t * <p>The <tt>Wire</tt> object's properties must have case\n\t * insensitive <tt>String</tt> objects as keys (like the Framework).\n\t * However, the case of the key must be preserved.\n\t * The type of the value of the property must be one of the following:\n\t *\n\t * <pre>\n\t * type        = basetype\n\t *  | vector | arrays\n\t *\n\t * basetype = String | Integer | Long\n\t *  | Float | Double | Byte\n\t *  | Short | Character\n\t *  | Boolean\n\t *\n\t * primitive   = long | int | short\n\t *  | char | byte | double | float\n\t *\n\t * arrays   = primitive '[]' | basetype '[]'\n\t *\n\t * vector   = Vector of basetype\n\t * </pre>\n\t *\n\t * <p>The <tt>WireAdmin</tt> service must automatically add the\n\t * following <tt>Wire</tt> properties:\n\t * <ul>\n\t * <li>\n\t * {@link WireConstants#WIREADMIN_PID} set to the value of the <tt>Wire</tt> object's\n\t * persistent identity (PID). This value is generated by the\n\t * Wire Admin service when a <tt>Wire</tt> object is created.\n\t * </li>\n\t * <li>\n\t * {@link WireConstants#WIREADMIN_PRODUCER_PID} set to the value of\n\t * Producer service's PID.\n\t * </li>\n\t * <li>\n\t * {@link WireConstants#WIREADMIN_CONSUMER_PID} set to the value of\n\t * Consumer service's PID.\n\t * </li>\n\t * </ul>\n\t * If the <tt>properties</tt> argument\n\t * already contains any of these keys, then the supplied values\n\t * are replaced with the values assigned by the Wire Admin service.\n\t *\n\t * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type\n\t * {@link WireAdminEvent#WIRE_CREATED}\n\t * after the new <tt>Wire</tt> object becomes available from {@link #getWires}.\n\t *\n\t * @param producerPID The <tt>service.pid</tt> of the Producer service\n\t * to be connected to the <tt>Wire</tt> object.<fim_middle>// class below is blob\n"}