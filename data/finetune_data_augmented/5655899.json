{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.util.collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport java.lang.reflect.Array;\nimport java.lang.ref.WeakReference;\nimport org.apache.sis.util.Debug;\nimport org.apache.sis.util.ArraysExt;\nimport org.apache.sis.util.Utilities;\nimport org.apache.sis.util.Workaround;\nimport org.apache.sis.util.NullArgumentException;\nimport org.apache.sis.util.resources.Errors;\nimport static org.apache.sis.util.collection.WeakEntry.*;\n/**\n * A hashtable-based map implementation that uses {@linkplain WeakReference weak references},\n * leaving memory when an entry is not used anymore. An entry in a {@code WeakValueHashMap}\n * will automatically be removed when its value is no longer in ordinary use. This class is\n * similar to the standard {@link java.util.WeakHashMap} class, except that weak references\n * apply to values rather than keys.\n *\n * <p>Note that this class is <strong>not</strong> a cache, because the entries are discarded\n * as soon as the garbage collector determines that they are no longer in use. If caching\n * service are wanted, or if concurrency are wanted, consider using {@link Cache} instead.</p>\n *\n * <p>This class is convenient for avoiding the creation of duplicated elements, as in the\n * example below:</p>\n *\n * {@preformat java\n *     K key = ...\n *     V value;\n *     synchronized (map) {\n *         value = map.get(key);\n *         if (value == null) {\n *             value = ...; // Create the value here.\n *             map.put(key, value);\n *         }\n *     }\n * }\n *\n * In the above example, the calculation of a new value needs to be fast because it is performed inside a synchronized\n * statement blocking all other access to the map. This is okay if that particular {@code WeakValueHashMap} instance\n * is not expected to be used in a highly concurrent environment.\n *\n * <p>{@code WeakValueHashMap} works with array keys as one would expect. For example arrays of {@code int[]} are\n * compared using the {@link java.util.Arrays#equals(int[], int[])} method.</p>\n *\n * <div class=\"section\">Thread safety</div>\n * The same {@code WeakValueHashMap} instance can be safely used by many threads without synchronization on the part\n * of the caller. But if a sequence of two or more method calls need to appear atomic from other threads perspective,\n * then the caller can synchronize on {@code this}.\n *\n * @author  Martin Desruisseaux (IRD, Geomatys)\n * @version 0.7\n *\n * @param <K>  the class of key elements.\n * @param <V>  the class of value elements.\n *\n * @see java.util.WeakHashMap\n * @see WeakHashSet\n * @see Cache\n *\n * @since 0.3\n * @module\n */\npublic class WeakValueHashMap<K,V> extends AbstractMap<K,V> {\n    /**\n     * Comparison mode for key objects. The standard mode is {@code EQUALS}, which means that keys are compared\n     * using their {@link Object#equals(Object)} method. But {@code WeakValueHashMap} will automatically select\n     * {@code DEEP_EQUALS} if there is a chance that some keys are arrays. In the later case, comparisons will\n     * be done by the more costly {@link Objects#deepEquals(Object, Object)} method instead.\n     *\n     * <p>The {@code IDENTITY} mode is rarely used, and is selected only if the user explicitly asks for this mode\n     * at construction time. This mode is provided because reference-equality semantic is sometime required, and\n     * hard to simulate if not supported natively by the hash map. See {@link java.util.IdentityHashMap} javadoc\n     * for some examples of cases where reference-equality semantic is useful.</p>\n     *\n     * @see #comparisonMode\n     * @see #keyEquals(Object, Object)\n     * @see #keyHashCode(Object)\n     */\n    private static final byte IDENTITY = 0, EQUALS = 1, DEEP_EQUALS = 2;\n    /**\n     * An entry in the {@link WeakValueHashMap}. This is a weak reference\n     * to a value together with a strong reference to a key.\n     */\n    private final class Entry extends WeakEntry<V> implements Map.Entry<K,V> {\n        /**\n         * The key.\n         */\n        final K key;\n        /**\n         * Constructs a new weak reference.\n         */\n        Entry(final K key, final V value, final Entry next, final int hash) {\n            super(value, next, hash);\n            this.key   = key;\n            this.next  = next;\n        }\n        /**\n         * Returns the key corresponding to this entry.\n         */\n        @Override\n        public K getKey() {\n            return key;\n        }\n        /**\n         * Returns the value corresponding to this entry.\n         */\n        @Override\n        public V getValue() {\n            return get();\n        }\n        /**\n         * Replaces the value corresponding in this entry with the specified value.\n         * This method can be used only for setting the value to {@code null}.\n         */\n<fim_suffix>        @Override\n        public V setValue(final V value) {\n            if (value != null) {\n                throw new UnsupportedOperationException();\n            }\n            final V old = get();\n            dispose();\n            return old;\n        }\n        /**\n         * Invoked by {@link org.apache.sis.internal.system.ReferenceQueueConsumer}\n         * for removing the reference from the enclosing collection.\n         */\n        @Override\n        public void dispose() {\n            super.clear();\n            removeEntry(this);\n        }\n        /**\n         * Compares the specified object with this entry for equality.\n         */\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof Map.Entry<?,?>) {\n                final Map.Entry<?,?> that = (Map.Entry<?,?>) other;\n                return keyEquals(key, that.getKey()) && Objects.equals(get(), that.getValue());\n            }\n            return false;\n        }\n        /**\n         * Returns the hash code value for this map entry. <strong>This hash code\n         * is not stable</strong>, since it will change after GC collect the value.\n         */\n        @Override\n        public int hashCode() {\n            int code = keyHashCode(key);\n            final V val = get();\n            if (val != null) {\n                code ^= val.hashCode();\n            }\n            return code;\n        }\n    }\n    /**\n     * Table of weak references.\n     */\n    private Entry[] table;\n    /**\n     * Number of non-null elements in {@link #table}.\n     */\n    private int count;\n    /**\n     * The type of the keys in this map.\n     */\n    private final Class<K> keyType;\n    /**\n     * Whether keys shall be compared by reference-equality ({@link #IDENTITY}), by shallow object-equality\n     * ({@link #EQUALS}) or by deep object-equality ({@link #DEEP_EQUALS}). The {@code DEEP_EQUALS} mode is\n     * selected only if the keys in this map may be arrays. If the keys can not be arrays, then we select the\n     * {@code EQUALS} mode for avoiding calls to the costly {@link Objects#deepEquals(Object, Object)} method.\n     *\n     * @see #keyEquals(Object, Object)\n     * @see #keyHashCode(Object)\n     */\n    private final byte comparisonMode;\n    /**\n     * The set of entries, created only when first needed.\n     */\n    private transient Set<Map.Entry<K,V>> entrySet;\n    /**\n     * The last time when {@link #table} was not in need for rehash. When the garbage collector\n     * collected a lot of elements, we will wait a few seconds before rehashing {@link #table}\n     * in case lot of news entries are going to be added. Without this field, we noticed many<fim_middle>// function below has no smell\n"}