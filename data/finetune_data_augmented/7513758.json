{"text": "<fim_prefix>/*\n * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.lir;\n\nimport static jdk.vm.ci.code.ValueUtil.asRegister;\nimport static jdk.vm.ci.code.ValueUtil.isRegister;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport jdk.vm.ci.code.Register;\nimport jdk.vm.ci.code.RegisterValue;\nimport jdk.vm.ci.code.StackSlot;\nimport jdk.vm.ci.meta.Constant;\nimport jdk.vm.ci.meta.JavaConstant;\nimport jdk.vm.ci.meta.Value;\n\npublic final class LIRValueUtil {\n\n    public static boolean isVariable(Value value) {\n        assert value != null;\n        return value instanceof Variable;\n    }\n\n    public static Variable asVariable(Value value) {\n        assert value != null;\n        return (Variable) value;\n    }\n\n    public static boolean isConstantValue(Value value) {\n        assert value != null;\n        return value instanceof ConstantValue;\n    }\n\n    public static ConstantValue asConstantValue(Value value) {\n        assert value != null;\n        return (ConstantValue) value;\n    }\n\n    public static Constant asConstant(Value value) {\n        return asConstantValue(value).getConstant();\n    }\n\n    public static boolean isJavaConstant(Value value) {\n        return isConstantValue(value) && asConstantValue(value).isJavaConstant();\n    }\n\n    public static JavaConstant asJavaConstant(Value value) {\n        return asConstantValue(value).getJavaConstant();\n    }\n\n    public static boolean isNullConstant(Value value) {\n        assert value != null;\n        return isJavaConstant(value) && asJavaConstant(value).isNull();\n    }\n\n    public static boolean isIntConstant(Value value, long expected) {\n        if (isJavaConstant(value)) {\n            JavaConstant javaConstant = asJavaConstant(value);\n            if (javaConstant != null && javaConstant.getJavaKind().isNumericInteger()) {\n                return javaConstant.asLong() == expected;\n            }\n        }\n        return false;\n    }\n\n    public static boolean isStackSlotValue(Value value) {\n        assert value != null;\n        return value instanceof StackSlot || value instanceof VirtualStackSlot;\n    }\n\n<fim_suffix>    public static boolean isVirtualStackSlot(Value value) {\n        assert value != null;\n        return value instanceof VirtualStackSlot;\n    }\n\n    public static VirtualStackSlot asVirtualStackSlot(Value value) {\n        assert value != null;\n        return (VirtualStackSlot) value;\n    }\n\n    public static boolean sameRegister(Value v1, Value v2) {\n        return isRegister(v1) && isRegister(v2) && asRegister(v1).equals(asRegister(v2));\n    }\n\n    public static boolean sameRegister(Value v1, Value v2, Value v3) {\n        return sameRegister(v1, v2) && sameRegister(v1, v3);\n    }\n\n    /**\n     * Checks if all the provided values are different physical registers. The parameters can be\n     * either {@link Register registers}, {@link Value values} or arrays of them. All values that\n     * are not {@link RegisterValue registers} are ignored.\n     */\n    public static boolean differentRegisters(Object... values) {\n        List<Register> registers = collectRegisters(values, new ArrayList<Register>());\n        for (int i = 1; i < registers.size(); i++) {\n            Register r1 = registers.get(i);\n            for (int j = 0; j < i; j++) {\n                Register r2 = registers.get(j);\n                if (r1.equals(r2)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static List<Register> collectRegisters(Object[] values, List<Register> registers) {\n        for (Object o : values) {\n            if (o instanceof Register) {\n                registers.add((Register) o);\n            } else if (o instanceof Value) {\n                if (isRegister((Value) o)) {\n                    registers.add(asRegister((Value) o));\n                }\n            } else if (o instanceof Object[]) {\n                collectRegisters((Object[]) o, registers);\n            } else {\n                throw new IllegalArgumentException(\"Not a Register or Value: \" + o);\n            }\n        }\n        return registers;\n    }\n\n    /**\n     * Subtract sets of registers (x - y).\n     *\n     * @param x a set of register to subtract from.\n     * @param y a set of registers to subtract.\n     * @return resulting set of registers (x - y).\n     */\n    public static Value[] subtractRegisters(Value[] x, Value[] y) {\n        ArrayList<Value> result = new ArrayList<>(x.length);\n        for (Value i : x) {\n            boolean append = true;\n            for (Value j : y) {\n                if (sameRegister(i, j)) {\n                    append = false;\n                    break;\n                }\n            }\n            if (append) {\n                result.add(i);\n            }\n        }\n        Value[] resultArray = new Value[result.size()];\n        return result.toArray(resultArray);\n    }\n}<fim_middle>// function below has no smell\n"}