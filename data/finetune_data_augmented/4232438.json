{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.crypto.jna;\n\nimport java.nio.ByteBuffer;\nimport java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Properties;\nimport java.util.Random;\n\nimport org.apache.commons.crypto.random.CryptoRandom;\nimport org.apache.commons.crypto.utils.Utils;\n\nimport com.sun.jna.NativeLong;\nimport com.sun.jna.ptr.PointerByReference;\n\n/**\n * <p>\n * OpenSSL secure random using JNA. This implementation is thread-safe.\n * </p>\n *\n * <p>\n * If using an Intel chipset with RDRAND, the high-performance hardware random\n * number generator will be used and it's much faster than SecureRandom. If\n * RDRAND is unavailable, default OpenSSL secure random generator will be used.\n * It's still faster and can generate strong random bytes.\n * </p>\n *\n * @see <a href=\"https://wiki.openssl.org/index.php/Random_Numbers\">\n *      https://wiki.openssl.org/index.php/Random_Numbers</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/RdRand\">\n *      http://en.wikipedia.org/wiki/RdRand</a>\n */\nclass OpenSslJnaCryptoRandom extends Random implements CryptoRandom {\n    private static final long serialVersionUID = -7128193502768749585L;\n    private final boolean rdrandEnabled;\n    private PointerByReference rdrandEngine;\n\n    /**\n     * Constructs a {@link OpenSslJnaCryptoRandom}.\n     *\n     * @param props the configuration properties (not used)\n     * @throws GeneralSecurityException  if could not enable JNA access\n     */\n    public OpenSslJnaCryptoRandom(Properties props) //NOPMD\n            throws GeneralSecurityException {\n        if (!OpenSslJna.isEnabled()) {\n            throw new GeneralSecurityException(\"Could not enable JNA access\", OpenSslJna.initialisationError());\n        }\n\n        boolean rdrandLoaded = false;\n        try {\n            OpenSslNativeJna.ENGINE_load_rdrand();\n            rdrandEngine = OpenSslNativeJna.ENGINE_by_id(\"rdrand\");\n            int ENGINE_METHOD_RAND = 0x0008;\n            if(rdrandEngine != null) {\n                int rc = OpenSslNativeJna.ENGINE_init(rdrandEngine);\n                \n                if(rc != 0) {\n                    int rc2 = OpenSslNativeJna.ENGINE_set_default(rdrandEngine, ENGINE_METHOD_RAND);\n                    if(rc2 != 0) {\n                        rdrandLoaded = true;\n                    }\n                }\n            }\n            \n        } catch (Exception e) {\n            throw new NoSuchAlgorithmException();\n        }\n        \n        rdrandEnabled = rdrandLoaded;\n        \n        if(!rdrandLoaded) {\n            closeRdrandEngine();\n        }\n    }\n\n    /**\n     * Generates a user-specified number of random bytes. It's thread-safe.\n     *\n     * @param bytes the array to be filled in with random bytes.\n     */\n<fim_suffix>    @Override\n    public void nextBytes(byte[] bytes) {\n        \n        synchronized (OpenSslJnaCryptoRandom.class) {\n            //this method is synchronized for now\n            //to support multithreading https://wiki.openssl.org/index.php/Manual:Threads(3) needs to be done\n            \n            if(rdrandEnabled && OpenSslNativeJna.RAND_get_rand_method().equals(OpenSslNativeJna.RAND_SSLeay())) {\n                close();\n                throw new RuntimeException(\"rdrand should be used but default is detected\");\n            }\n\n            ByteBuffer buf = ByteBuffer.allocateDirect(bytes.length);\n            int retVal = OpenSslNativeJna.RAND_bytes(buf, bytes.length);\n            throwOnError(retVal);\n            buf.rewind();\n            buf.get(bytes,0, bytes.length);\n        }\n    }\n\n    /**\n     * Overrides {@link OpenSslJnaCryptoRandom}. For {@link OpenSslJnaCryptoRandom},\n     * we don't need to set seed.\n     *\n     * @param seed the initial seed.\n     */\n    @Override\n    public void setSeed(long seed) {\n        // Self-seeding.\n    }\n\n    /**\n     * Overrides Random#next(). Generates an integer containing the\n     * user-specified number of random bits(right justified, with leading\n     * zeros).\n     *\n     * @param numBits number of random bits to be generated, where 0\n     *        {@literal <=} <code>numBits</code> {@literal <=} 32.\n     * @return int an <code>int</code> containing the user-specified number of\n     *         random bits (right justified, with leading zeros).\n     */\n    @Override\n    final protected int next(int numBits) {\n        Utils.checkArgument(numBits >= 0 && numBits <= 32);\n        int numBytes = (numBits + 7) / 8;\n        byte b[] = new byte[numBytes];\n        int next = 0;\n\n        nextBytes(b);\n        for (int i = 0; i < numBytes; i++) {\n            next = (next << 8) + (b[i] & 0xFF);\n        }\n\n        return next >>> (numBytes * 8 - numBits);\n    }\n\n    /**\n     * Overrides {@link java.lang.AutoCloseable#close()}. Closes OpenSSL context\n     * if native enabled.\n     */\n    @Override\n    public void close() {\n        closeRdrandEngine();\n        OpenSslNativeJna.ENGINE_cleanup();\n        \n        //cleanup locks\n        //OpenSslNativeJna.CRYPTO_set_locking_callback(null);\n        //LOCK.unlock();\n    }\n\n    /**\n     * Closes the rdrand engine.\n     */\n    private void closeRdrandEngine() {\n        \n        if(rdrandEngine != null) {\n            OpenSslNativeJna.ENGINE_finish(rdrandEngine);\n            OpenSslNativeJna.ENGINE_free(rdrandEngine);\n        }\n    }\n\n    /**\n     * Checks if rdrand engine is used to retrieve random bytes\n     * \n     * @return true if rdrand is used, false if default engine is used\n     */\n    public boolean isRdrandEnabled() {\n        return rdrandEnabled;\n    }\n\n    /**\n     * @param retVal the result value of error.\n     */\n    private void throwOnError(int retVal) {  \n        if (retVal != 1) {\n            NativeLong err = OpenSslNativeJna.ERR_peek_error();\n            String errdesc = OpenSslNativeJna.ERR_error_string(err, null);\n            close();\n            throw new RuntimeException(\"return code \" + retVal + \" from OpenSSL. Err code is \" + err + \": \" + errdesc);\n        }\n    }\n}<fim_middle>// function below has no smell\n"}