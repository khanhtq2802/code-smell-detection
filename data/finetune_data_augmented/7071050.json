{"text": "<fim_prefix>         * @return handle of next namespace, or DTM.NULL to indicate none exists.\n         */\n        public int getNextNamespaceNode(int baseHandle,int namespaceHandle, boolean inScope) {\n                // ###shs need to work on namespace\n                return NULL;\n        }\n        /**\n         * Given a node handle, advance to its next descendant.\n         * If not yet resolved, waits for more nodes to be added to the document and\n         * tries again.\n         *\n         * @param subtreeRootHandle\n         * @param nodeHandle int Handle of the node.\n         * @return handle of next descendant,\n         * or DTM.NULL to indicate none exists.\n         */\n        public int getNextDescendant(int subtreeRootHandle, int nodeHandle) {\n                subtreeRootHandle &= NODEHANDLE_MASK;\n                nodeHandle &= NODEHANDLE_MASK;\n                // Document root [Document Node? -- jjk] - no next-sib\n                if (nodeHandle == 0)\n                        return NULL;\n                while (!m_isError) {\n                        // Document done and node out of bounds\n                        if (done && (nodeHandle > nodes.slotsUsed()))\n                                break;\n                        if (nodeHandle > subtreeRootHandle) {\n                                nodes.readSlot(nodeHandle+1, gotslot);\n                                if (gotslot[2] != 0) {\n                                        short type = (short) (gotslot[0] & 0xFFFF);\n                                        if (type == ATTRIBUTE_NODE) {\n                                                nodeHandle +=2;\n                                        } else {\n                                                int nextParentPos = gotslot[1];\n                                                if (nextParentPos >= subtreeRootHandle)\n                                                        return (m_docHandle | (nodeHandle+1));\n                                                else\n                                                        break;\n                                        }\n                                } else if (!done) {\n                                        // Add wait logic here\n                                } else\n                                        break;\n                        } else {\n                                nodeHandle++;\n                        }\n                }\n                // Probably should throw error here like original instead of returning\n                return NULL;\n        }\n        /**\n         * Given a node handle, advance to the next node on the following axis.\n         *\n         * @param axisContextHandle the start of the axis that is being traversed.\n         * @param nodeHandle\n         * @return handle of next sibling,\n         * or DTM.NULL to indicate none exists.\n         */\n        public int getNextFollowing(int axisContextHandle, int nodeHandle) {\n                //###shs still working on\n                return NULL;\n        }\n        /**\n         * Given a node handle, advance to the next node on the preceding axis.\n         *\n         * @param axisContextHandle the start of the axis that is being traversed.\n         * @param nodeHandle the id of the node.\n         * @return int Node-number of preceding sibling,\n         * or DTM.NULL to indicate none exists.\n         */\n        public int getNextPreceding(int axisContextHandle, int nodeHandle) {\n                // ###shs copied from Xalan 1, what is this suppose to do?\n                nodeHandle &= NODEHANDLE_MASK;\n                while (nodeHandle > 1) {\n                        nodeHandle--;\n                        if (ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF))\n                                continue;\n                        // if nodeHandle is _not_ an ancestor of\n                        // axisContextHandle, specialFind will return it.\n                        // If it _is_ an ancestor, specialFind will return -1\n                        // %REVIEW% unconditional return defeats the\n                        // purpose of the while loop -- does this\n                        // logic make any sense?\n                        return (m_docHandle | nodes.specialFind(axisContextHandle, nodeHandle));\n                }\n                return NULL;\n        }\n        /**\n         * Given a node handle, find its parent node.\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node-number of parent,\n         * or DTM.NULL to indicate none exists.\n         */\n        public int getParent(int nodeHandle) {\n                // Should check to see within range?\n                // Document Root should not have to be handled differently\n                return (m_docHandle | nodes.readEntry(nodeHandle, 1));\n        }\n        /**\n         * Returns the root element of the document.\n         * @return nodeHandle to the Document Root.\n         */\n        public int getDocumentRoot() {\n                return (m_docHandle | m_docElement);\n        }\n        /**\n         * Given a node handle, find the owning document node.\n         *\n         * @return int Node handle of document, which should always be valid.\n         */\n        public int getDocument() {\n                return m_docHandle;\n        }\n        /**\n         * Given a node handle, find the owning document node.  This has the exact\n         * same semantics as the DOM Document method of the same name, in that if\n         * the nodeHandle is a document node, it will return NULL.\n         *\n         * <p>%REVIEW% Since this is DOM-specific, it may belong at the DOM\n         * binding layer. Included here as a convenience function and to\n         * aid porting of DOM code to DTM.</p>\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node handle of owning document, or NULL if the nodeHandle is\n         *             a document.\n         */\n        public int getOwnerDocument(int nodeHandle) {\n                // Assumption that Document Node is always in 0 slot\n                if ((nodeHandle & NODEHANDLE_MASK) == 0)\n                        return NULL;\n                return (nodeHandle & DOCHANDLE_MASK);\n        }\n        /**\n         * Given a node handle, find the owning document node.  This has the DTM\n         * semantics; a Document node is its own owner.\n         *\n         * <p>%REVIEW% Since this is DOM-specific, it may belong at the DOM\n         * binding layer. Included here as a convenience function and to\n         * aid porting of DOM code to DTM.</p>\n         *\n         * @param nodeHandle the id of the node.\n         * @return int Node handle of owning document, or NULL if the nodeHandle is\n         *             a document.\n         */\n        public int getDocumentRoot(int nodeHandle) {\n                // Assumption that Document Node is always in 0 slot\n                if ((nodeHandle & NODEHANDLE_MASK) == 0)\n                        return NULL;\n                return (nodeHandle & DOCHANDLE_MASK);\n        }\n        /**\n         * Get the string-value of a node as a String object\n         * (see http://www.w3.org/TR/xpath#data-model\n         * for the definition of a node's string-value).\n         *\n         * @param nodeHandle The node ID.\n         *\n         * @return A string object that represents the string-value of the given node.\n         */\n<fim_suffix>        public XMLString getStringValue(int nodeHandle) {\n        // ###zaj - researching\n        nodes.readSlot(nodeHandle, gotslot);\n        int nodetype=gotslot[0] & 0xFF;\n        String value=null;\n        switch (nodetype) {\n        case TEXT_NODE:\n        case COMMENT_NODE:\n        case CDATA_SECTION_NODE:\n                value= m_char.getString(gotslot[2], gotslot[3]);\n                break;\n        case PROCESSING_INSTRUCTION_NODE:\n        case ATTRIBUTE_NODE:\n        case ELEMENT_NODE:\n        case ENTITY_REFERENCE_NODE:\n        default:\n                break;\n        }\n        return m_xsf.newstr( value );\n        }<fim_middle>// function below has no smell\n"}