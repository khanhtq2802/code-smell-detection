{"text": "<fim_prefix>/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.cli;\nimport com.facebook.buck.event.FlushConsoleEvent;\nimport com.facebook.buck.io.filesystem.ProjectFilesystem;\nimport com.facebook.buck.parser.DefaultProjectBuildFileParserFactory;\nimport com.facebook.buck.parser.ParserPythonInterpreterProvider;\nimport com.facebook.buck.parser.api.ProjectBuildFileParser;\nimport com.facebook.buck.parser.function.BuckPyFunction;\nimport com.facebook.buck.parser.syntax.ListWithSelects;\nimport com.facebook.buck.rules.coercer.DefaultTypeCoercerFactory;\nimport com.facebook.buck.util.Escaper;\nimport com.facebook.buck.util.ExitCode;\nimport com.facebook.buck.util.string.MoreStrings;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.CaseFormat;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.function.Predicate;\nimport javax.annotation.Nullable;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\n/**\n * Evaluates a build file and prints out an equivalent build file with all includes/macros expanded.\n * When complex macros are in play, this helps clarify what the resulting build rule definitions\n * are.\n */\npublic class AuditRulesCommand extends AbstractCommand {\n  /** Indent to use in generated build file. */\n  private static final String INDENT = \"  \";\n  /** Properties that should be listed last in the declaration of a build rule. */\n  private static final ImmutableSet<String> LAST_PROPERTIES = ImmutableSet.of(\"deps\", \"visibility\");\n  @Option(\n      name = \"--type\",\n      aliases = {\"-t\"},\n      usage = \"The types of rule to filter by\")\n  @Nullable\n  private List<String> types = null;\n  @Argument private List<String> arguments = new ArrayList<>();\n  public List<String> getArguments() {\n    return arguments;\n  }\n  public ImmutableSet<String> getTypes() {\n    return types == null ? ImmutableSet.of() : ImmutableSet.copyOf(types);\n  }\n  @Override\n  public String getShortDescription() {\n    return \"List build rule definitions resulting from expanding macros.\";\n  }\n<fim_suffix>  @Override\n  public ExitCode runWithoutHelp(CommandRunnerParams params) throws Exception {\n    ProjectFilesystem projectFilesystem = params.getCell().getFilesystem();\n    try (ProjectBuildFileParser parser =\n        new DefaultProjectBuildFileParserFactory(\n                new DefaultTypeCoercerFactory(),\n                params.getConsole(),\n                new ParserPythonInterpreterProvider(\n                    params.getCell().getBuckConfig(), params.getExecutableFinder()),\n                params.getKnownRuleTypesProvider(),\n                params.getManifestServiceSupplier(),\n                params.getFileHashCache())\n            .createBuildFileParser(\n                params.getBuckEventBus(), params.getCell(), params.getWatchman())) {\n      /*\n       * The super console does a bunch of rewriting over the top of the console such that\n       * simultaneously writing to stdout and stderr in an interactive session is problematic.\n       * (Overwritten characters, lines never showing up, etc). As such, writing to stdout directly\n       * stops superconsole rendering (no errors appear). Because of all of this, we need to\n       * just buffer the output and print it to stdout at the end fo the run. The downside\n       * is that we have to buffer all of the output in memory, and it could potentially be large,\n       * however, we'll just have to accept that tradeoff for now to get both error messages\n       * from the parser, and the final output\n       */\n      try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n          PrintStream out = new PrintStream(new BufferedOutputStream(byteOut))) {\n        for (String pathToBuildFile : getArguments()) {\n          // Print a comment with the path to the build file.\n          out.printf(\"# %s\\n\\n\", pathToBuildFile);\n          // Resolve the path specified by the user.\n          Path path = Paths.get(pathToBuildFile);\n          if (!path.isAbsolute()) {\n            Path root = projectFilesystem.getRootPath();\n            path = root.resolve(path);\n          }\n          // Parse the rules from the build file.\n          ImmutableMap<String, Map<String, Object>> rawRules =\n              parser.getBuildFileManifest(path).getTargets();\n          // Format and print the rules from the raw data, filtered by type.\n          ImmutableSet<String> types = getTypes();\n          Predicate<String> includeType = type -> types.isEmpty() || types.contains(type);\n          printRulesToStdout(out, rawRules, includeType);\n        }\n        // Make sure we tell the event listener to flush, otherwise there is a race condition where\n        // the event listener might not have flushed, we dirty the stream, and then it will not\n        // render the last frame (see {@link SuperConsoleEventListener})\n        params.getBuckEventBus().post(new FlushConsoleEvent());\n        out.close();\n        params.getConsole().getStdOut().write(byteOut.toByteArray());\n      }\n    }\n    return ExitCode.SUCCESS;\n  }\n  @Override\n  public boolean isReadOnly() {\n    return true;\n  }\n  private void printRulesToStdout(\n      PrintStream stdOut,\n      ImmutableMap<String, Map<String, Object>> rawRules,\n      Predicate<String> includeType) {\n    rawRules\n        .entrySet()\n        .stream()\n        .filter(\n            rawRule -> {\n              String type = (String) rawRule.getValue().get(BuckPyFunction.TYPE_PROPERTY_NAME);\n              return includeType.test(type);\n            })\n        .sorted(Comparator.comparing(Map.Entry::getKey))\n        .forEach(rawRule -> printRuleAsPythonToStdout(stdOut, rawRule.getValue()));\n  }\n  private static void printRuleAsPythonToStdout(PrintStream out, Map<String, Object> rawRule) {\n    String type = (String) rawRule.get(BuckPyFunction.TYPE_PROPERTY_NAME);\n    out.printf(\"%s(\\n\", type);\n    // The properties in the order they should be displayed for this rule.\n    LinkedHashSet<String> properties = new LinkedHashSet<>();\n    // Always display the \"name\" property first.\n    properties.add(\"name\");\n    // Add the properties specific to the rule.\n    SortedSet<String> customProperties = new TreeSet<>();\n    for (String key : rawRule.keySet()) {\n      // Ignore keys that start with \"buck.\".\n      if (!(key.startsWith(BuckPyFunction.INTERNAL_PROPERTY_NAME_PREFIX)\n          || LAST_PROPERTIES.contains(key))) {\n        customProperties.add(key);\n      }\n    }\n    properties.addAll(customProperties);\n    // Add common properties that should be displayed last.\n    properties.addAll(Sets.intersection(LAST_PROPERTIES, rawRule.keySet()));\n    // Write out the properties and their corresponding values.\n    for (String property : properties) {\n      Object rawValue = rawRule.get(property);\n      if (!shouldInclude(rawValue)) {\n        continue;\n      }\n      String displayValue = createDisplayString(INDENT, rawValue);\n      out.printf(\"%s%s = %s,\\n\", INDENT, formatAttribute(property), displayValue);\n    }\n    // Close the rule definition.\n    out.print(\")\\n\\n\");\n  }\n  private static String formatAttribute(String property) {\n    return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, property);\n  }\n  private static boolean shouldInclude(@Nullable Object rawValue) {\n    return rawValue != null\n        && rawValue != Optional.empty()\n        && !(rawValue instanceof Collection && ((Collection<?>) rawValue).isEmpty());\n  }\n  /**\n   * @param value a map representing a raw build target.<fim_middle>// function below is long method\n"}