{"text": "<fim_prefix>/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cache.jcache.interceptor;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.cache.annotation.CacheInvocationParameter;\nimport javax.cache.annotation.CacheKeyGenerator;\nimport javax.cache.annotation.CacheKeyInvocationContext;\n\nimport org.springframework.cache.interceptor.KeyGenerator;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.CollectionUtils;\n\n/**\n * Spring's {@link KeyGenerator} implementation that either delegates to a standard JSR-107\n * {@link javax.cache.annotation.CacheKeyGenerator}, or wrap a standard {@link KeyGenerator}\n * so that only relevant parameters are handled.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n */\n<fim_suffix>class KeyGeneratorAdapter implements KeyGenerator {\n\n\tprivate final JCacheOperationSource cacheOperationSource;\n\n\t@Nullable\n\tprivate KeyGenerator keyGenerator;\n\n\t@Nullable\n\tprivate CacheKeyGenerator cacheKeyGenerator;\n\n\n\t/**\n\t * Create an instance with the given {@link KeyGenerator} so that {@link javax.cache.annotation.CacheKey}\n\t * and {@link javax.cache.annotation.CacheValue} are handled according to the spec.\n\t */\n\tpublic KeyGeneratorAdapter(JCacheOperationSource cacheOperationSource, KeyGenerator target) {\n\t\tAssert.notNull(cacheOperationSource, \"JCacheOperationSource must not be null\");\n\t\tAssert.notNull(target, \"KeyGenerator must not be null\");\n\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\tthis.keyGenerator = target;\n\t}\n\n\t/**\n\t * Create an instance used to wrap the specified {@link javax.cache.annotation.CacheKeyGenerator}.\n\t */\n\tpublic KeyGeneratorAdapter(JCacheOperationSource cacheOperationSource, CacheKeyGenerator target) {\n\t\tAssert.notNull(cacheOperationSource, \"JCacheOperationSource must not be null\");\n\t\tAssert.notNull(target, \"CacheKeyGenerator must not be null\");\n\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\tthis.cacheKeyGenerator = target;\n\t}\n\n\n\t/**\n\t * Return the target key generator to use in the form of either a {@link KeyGenerator}\n\t * or a {@link CacheKeyGenerator}.\n\t */\n\tpublic Object getTarget() {\n\t\tif (this.cacheKeyGenerator != null) {\n\t\t\treturn this.cacheKeyGenerator;\n\t\t}\n\t\tAssert.state(this.keyGenerator != null, \"No key generator\");\n\t\treturn this.keyGenerator;\n\t}\n\n\t@Override\n\tpublic Object generate(Object target, Method method, Object... params) {\n\t\tJCacheOperation<?> operation = this.cacheOperationSource.getCacheOperation(method, target.getClass());\n\t\tif (!(AbstractJCacheKeyOperation.class.isInstance(operation))) {\n\t\t\tthrow new IllegalStateException(\"Invalid operation, should be a key-based operation \" + operation);\n\t\t}\n\t\tCacheKeyInvocationContext<?> invocationContext = createCacheKeyInvocationContext(target, operation, params);\n\n\t\tif (this.cacheKeyGenerator != null) {\n\t\t\treturn this.cacheKeyGenerator.generateCacheKey(invocationContext);\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.keyGenerator != null, \"No key generator\");\n\t\t\treturn doGenerate(this.keyGenerator, invocationContext);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static Object doGenerate(KeyGenerator keyGenerator, CacheKeyInvocationContext<?> context) {\n\t\tList<Object> parameters = new ArrayList<>();\n\t\tfor (CacheInvocationParameter param : context.getKeyParameters()) {\n\t\t\tObject value = param.getValue();\n\t\t\tif (param.getParameterPosition() == context.getAllParameters().length - 1 &&\n\t\t\t\t\tcontext.getMethod().isVarArgs()) {\n\t\t\t\tparameters.addAll((List<Object>) CollectionUtils.arrayToList(value));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparameters.add(value);\n\t\t\t}\n\t\t}\n\t\treturn keyGenerator.generate(context.getTarget(), context.getMethod(), parameters.toArray());\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate CacheKeyInvocationContext<?> createCacheKeyInvocationContext(\n\t\t\tObject target, JCacheOperation<?> operation, Object[] params) {\n\n\t\tAbstractJCacheKeyOperation<Annotation> keyCacheOperation = (AbstractJCacheKeyOperation<Annotation>) operation;\n\t\treturn new DefaultCacheKeyInvocationContext<>(keyCacheOperation, target, params);\n\t}\n\n}<fim_middle>// class below has no smell\n"}