{"text": "<fim_prefix>  }\n  /**\n   * Accessor that assumes that the underlying value is a Time,\n   * in its default representation {@code int};\n   * corresponds to {@link java.sql.Types#TIME}.\n   */\n  private static class TimeFromNumberAccessor extends NumberAccessor {\n    private final Calendar localCalendar;\n    private TimeFromNumberAccessor(Getter getter, Calendar localCalendar) {\n      super(getter, 0);\n      this.localCalendar = localCalendar;\n    }\n    @Override public Object getObject() throws SQLException {\n      return getTime(localCalendar);\n    }\n    @Override public Time getTime(Calendar calendar) throws SQLException {\n      final Number v = getNumber();\n      if (v == null) {\n        return null;\n      }\n      return intToTime(v.intValue(), calendar);\n    }\n    @Override public Timestamp getTimestamp(Calendar calendar) throws SQLException {\n      final Number v = getNumber();\n      if (v == null) {\n        return null;\n      }\n      return longToTimestamp(v.longValue(), calendar);\n    }\n    @Override public String getString() throws SQLException {\n      final Number v = getNumber();\n      if (v == null) {\n        return null;\n      }\n      return timeAsString(v.intValue(), null);\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a TIMESTAMP,\n   * in its default representation {@code long};\n   * corresponds to {@link java.sql.Types#TIMESTAMP}.\n   */\n  private static class TimestampFromNumberAccessor extends NumberAccessor {\n    private final Calendar localCalendar;\n    private TimestampFromNumberAccessor(Getter getter, Calendar localCalendar) {\n      super(getter, 0);\n      this.localCalendar = localCalendar;\n    }\n    @Override public Object getObject() throws SQLException {\n      return getTimestamp(localCalendar);\n    }\n    @Override public Timestamp getTimestamp(Calendar calendar) throws SQLException {\n      final Number v = getNumber();\n      if (v == null) {\n        return null;\n      }\n      return longToTimestamp(v.longValue(), calendar);\n    }\n    @Override public Date getDate(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Date(timestamp.getTime());\n    }\n    @Override public Time getTime(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Time(\n          DateTimeUtils.floorMod(timestamp.getTime(),\n              DateTimeUtils.MILLIS_PER_DAY));\n    }\n    @Override public String getString() throws SQLException {\n      final Number v = getNumber();\n      if (v == null) {\n        return null;\n      }\n      return timestampAsString(v.longValue(), null);\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a DATE,\n   * represented as a java.sql.Date;\n   * corresponds to {@link java.sql.Types#DATE}.\n   */\n  private static class DateAccessor extends ObjectAccessor {\n    private DateAccessor(Getter getter) {\n      super(getter);\n    }\n    @Override public Date getDate(Calendar calendar) throws SQLException {\n      java.sql.Date date = (Date) getObject();\n      if (date == null) {\n        return null;\n      }\n      if (calendar != null) {\n        long v = date.getTime();\n        v -= calendar.getTimeZone().getOffset(v);\n        date = new Date(v);\n      }\n      return date;\n    }\n    @Override public String getString() throws SQLException {\n      final int v = getInt();\n      if (v == 0 && wasNull()) {\n        return null;\n      }\n      return dateAsString(v, null);\n    }\n    @Override public long getLong() throws SQLException {\n      Date date = getDate(null);\n      return date == null\n          ? 0L\n          : (date.getTime() / DateTimeUtils.MILLIS_PER_DAY);\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a TIME,\n   * represented as a java.sql.Time;\n   * corresponds to {@link java.sql.Types#TIME}.\n   */\n  private static class TimeAccessor extends ObjectAccessor {\n    private TimeAccessor(Getter getter) {\n      super(getter);\n    }\n    @Override public Time getTime(Calendar calendar) throws SQLException {\n      Time date  = (Time) getObject();\n      if (date == null) {\n        return null;\n      }\n      if (calendar != null) {\n        long v = date.getTime();\n        v -= calendar.getTimeZone().getOffset(v);\n        date = new Time(v);\n      }\n      return date;\n    }\n    @Override public String getString() throws SQLException {\n      final int v = getInt();\n      if (v == 0 && wasNull()) {\n        return null;\n      }\n      return timeAsString(v, null);\n    }\n    @Override public long getLong() throws SQLException {\n      Time time = getTime(null);\n      return time == null ? 0L\n          : (time.getTime() % DateTimeUtils.MILLIS_PER_DAY);\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a TIMESTAMP,\n   * represented as a java.sql.Timestamp;\n   * corresponds to {@link java.sql.Types#TIMESTAMP}.\n   */\n  private static class TimestampAccessor extends ObjectAccessor {\n    private TimestampAccessor(Getter getter) {\n      super(getter);\n    }\n    @Override public Timestamp getTimestamp(Calendar calendar) throws SQLException {\n      Timestamp timestamp  = (Timestamp) getObject();\n      if (timestamp == null) {\n        return null;\n      }\n      if (calendar != null) {\n        long v = timestamp.getTime();\n        v -= calendar.getTimeZone().getOffset(v);\n        timestamp = new Timestamp(v);\n      }\n      return timestamp;\n    }\n    @Override public Date getDate(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Date(timestamp.getTime());\n    }\n    @Override public Time getTime(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Time(\n          DateTimeUtils.floorMod(timestamp.getTime(),\n              DateTimeUtils.MILLIS_PER_DAY));\n    }\n    @Override public String getString() throws SQLException {\n      final long v = getLong();\n      if (v == 0 && wasNull()) {\n        return null;\n      }\n      return timestampAsString(v, null);\n    }\n    @Override public long getLong() throws SQLException {\n      Timestamp timestamp = getTimestamp(null);\n      return timestamp == null ? 0 : timestamp.getTime();\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a TIMESTAMP,\n   * represented as a java.util.Date;\n   * corresponds to {@link java.sql.Types#TIMESTAMP}.\n   */\n  private static class TimestampFromUtilDateAccessor extends ObjectAccessor {\n    private final Calendar localCalendar;\n    private TimestampFromUtilDateAccessor(Getter getter,\n        Calendar localCalendar) {\n      super(getter);\n      this.localCalendar = localCalendar;\n    }\n    @Override public Timestamp getTimestamp(Calendar calendar) throws SQLException {\n      java.util.Date date  = (java.util.Date) getObject();\n      if (date == null) {\n        return null;\n      }\n      long v = date.getTime();\n      if (calendar != null) {\n        v -= calendar.getTimeZone().getOffset(v);\n      }\n      return new Timestamp(v);\n    }\n    @Override public Date getDate(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Date(timestamp.getTime());\n    }\n    @Override public Time getTime(Calendar calendar) throws SQLException {\n      final Timestamp timestamp  = getTimestamp(calendar);\n      if (timestamp == null) {\n        return null;\n      }\n      return new Time(\n          DateTimeUtils.floorMod(timestamp.getTime(),\n              DateTimeUtils.MILLIS_PER_DAY));\n    }\n    @Override public String getString() throws SQLException {\n      java.util.Date date  = (java.util.Date) getObject();\n      if (date == null) {\n        return null;\n      }\n      return timestampAsString(date.getTime(), null);\n    }\n    @Override public long getLong() throws SQLException {\n      Timestamp timestamp = getTimestamp(localCalendar);\n      return timestamp == null ? 0 : timestamp.getTime();\n    }\n  }\n  /**\n   * Accessor that assumes that the underlying value is a {@code int};\n   * corresponds to {@link java.sql.Types#OTHER}.\n   */\n<fim_suffix>  private static class IntervalYearMonthAccessor extends IntAccessor {\n    private final TimeUnitRange range;\n    private IntervalYearMonthAccessor(Getter getter, TimeUnitRange range) {\n      super(getter);\n      this.range = range;\n    }\n    @Override public String getString() throws SQLException {\n      final int v = getInt();\n      if (v == 0 && wasNull()) {\n        return null;\n      }\n      return DateTimeUtils.intervalYearMonthToString(v, range);\n    }\n  }<fim_middle>// class below has no smell\n"}