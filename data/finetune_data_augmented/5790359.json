{"text": "<fim_prefix>\n<fim_suffix>public class ChmLzxBlock {\n    private int block_number;\n    private long block_length;\n    private ChmLzxState state;\n    private byte[] content = null;\n    private ChmSection chmSection = null;\n    private int contentLength = 0;\n    // trying to find solution for bad blocks ...\n    private int previousBlockType = -1;\n    public ChmLzxBlock(int blockNumber, byte[] dataSegment, long blockLength,\n            ChmLzxBlock prevBlock) throws TikaException {\n        try {\n            if (validateConstructorParams(blockNumber, dataSegment, blockLength)) {\n                setBlockNumber(blockNumber);\n                if (prevBlock != null\n                        && prevBlock.getState().getBlockLength() > prevBlock\n                                .getState().getBlockRemaining())\n                    setChmSection(new ChmSection(dataSegment, prevBlock.getContent()));\n                else\n                    setChmSection(new ChmSection(dataSegment));\n                setBlockLength(blockLength);\n                // ============================================\n                // we need to take care of previous context\n                // ============================================\n                checkLzxBlock(prevBlock);\n                if (prevBlock == null\n                        || blockLength < (int) getBlockLength()) {\n                    setContent((int) getBlockLength());\n                }\n                else {\n                    setContent((int) blockLength);\n                }\n                if (prevBlock != null && prevBlock.getState() != null)\n                    previousBlockType = prevBlock.getState().getBlockType();\n                extractContent();\n            } else\n                throw new TikaException(\"Check your chm lzx block parameters\");\n        } catch (TikaException e) {\n            throw e;\n        }\n    }\n    protected int getContentLength() {\n        return contentLength;\n    }\n    protected void setContentLength(int contentLength) {\n        this.contentLength = contentLength;\n    }\n    private ChmSection getChmSection() {\n        return chmSection;\n    }\n    private void setChmSection(ChmSection chmSection) {\n        this.chmSection = chmSection;\n    }\n    private void assertStateNotNull() throws TikaException {\n        if (getState() == null)\n            throw new ChmParsingException(\"state is null\");\n    }\n    private void extractContent() throws TikaException {\n        assertStateNotNull();\n        if (getChmSection().getData() != null) {\n            boolean continueLoop = true;\n            while (continueLoop && getContentLength() < getBlockLength()) {\n                if (getState() != null && getState().getBlockRemaining() == 0) {\n                    if (getState().getHadStarted() == LzxState.NOT_STARTED_DECODING) {\n                        getState().setHadStarted(LzxState.STARTED_DECODING);\n                        if (getChmSection().getSyncBits(1) == 1) {\n                            int intelSizeTemp = (getChmSection()\n                                    .getSyncBits(16) << 16)\n                                    + getChmSection().getSyncBits(16);\n                            if (intelSizeTemp >= 0)\n                                getState().setIntelFileSize(intelSizeTemp);\n                            else\n                                getState().setIntelFileSize(0);\n                        }\n                    }\n                    getState().setBlockType(getChmSection().getSyncBits(3));\n                    getState().setBlockLength(\n                            (getChmSection().getSyncBits(16) << 8)\n                                    + getChmSection().getSyncBits(8));\n                    getState().setBlockRemaining(getState().getBlockLength());\n                    // ----------------------------------------\n                    // Trying to handle 3 - 7 block types\n                    // ----------------------------------------\n                    if (getState().getBlockType() > 3) {\n                        if (previousBlockType >= 0 && previousBlockType < 3)\n                            getState().setBlockType(previousBlockType);\n                    }\n                    switch (getState().getBlockType()) {\n                        case ChmCommons.ALIGNED_OFFSET:\n                            createAlignedTreeTable();\n                            //fall through\n                        case ChmCommons.VERBATIM:\n                            /* Creates mainTreeTable */\n                            createMainTreeTable();\n                            createLengthTreeTable();\n                            if (getState().getMainTreeLengtsTable()[0xe8] != 0)\n                                getState().setIntelState(IntelState.STARTED);\n                            break;\n                        case ChmCommons.UNCOMPRESSED:\n                            getState().setIntelState(IntelState.STARTED);\n                            if (getChmSection().getTotal() > 16)\n                                getChmSection().setSwath(\n                                        getChmSection().getSwath() - 1);\n                            getState().setR0(\n                                    (new BigInteger(getChmSection()\n                                            .reverseByteOrder(\n                                                    getChmSection().unmarshalBytes(\n                                                            4))).longValue()));\n                            getState().setR1(\n                                    (new BigInteger(getChmSection()\n                                            .reverseByteOrder(\n                                                    getChmSection().unmarshalBytes(\n                                                            4))).longValue()));\n                            getState().setR2(\n                                    (new BigInteger(getChmSection()\n                                            .reverseByteOrder(\n                                                    getChmSection().unmarshalBytes(\n                                                            4))).longValue()));\n                            break;\n                        default:\n                            break;\n                    }\n                } //end of if BlockRemaining == 0\n                int tempLen;\n                if (getContentLength() + getState().getBlockRemaining() > getBlockLength()) {\n                    getState().setBlockRemaining(\n                            getContentLength() + getState().getBlockRemaining()\n                                    - (int) getBlockLength());\n                    tempLen = (int) getBlockLength();\n                } else {\n                    tempLen = getContentLength()\n                            + getState().getBlockRemaining();\n                    getState().setBlockRemaining(0);\n                }\n                int lastLength = getContentLength();\n                switch (getState().getBlockType()) {\n                case ChmCommons.ALIGNED_OFFSET:\n                    // if(prevblock.lzxState.length>prevblock.lzxState.remaining)\n                    decompressAlignedBlock(tempLen, getChmSection().getPrevContent() == null ? getChmSection().getData() : getChmSection().getPrevContent());// prevcontext\n                    break;\n                case ChmCommons.VERBATIM:\n                    decompressVerbatimBlock(tempLen, getChmSection().getPrevContent() == null ? getChmSection().getData() : getChmSection().getPrevContent());\n                    break;\n                case ChmCommons.UNCOMPRESSED:\n                    decompressUncompressedBlock(tempLen, getChmSection().getPrevContent() == null ? getChmSection().getData() : getChmSection().getPrevContent());\n                    break;\n                }\n                getState().increaseFramesRead();\n                if ((getState().getFramesRead() < 32768)\n                        && getState().getIntelFileSize() != 0)\n                    intelE8Decoding();\n                continueLoop = getContentLength() > lastLength;\n            }\n        }\n    }\n    protected void intelE8Decoding() {\n        if (getBlockLength() <= ChmConstants.LZX_PRETREE_TABLEBITS\n                || (getState().getIntelState() == IntelState.NOT_STARTED)) {\n            getState().setBlockRemaining(\n                    getState().getBlockRemaining() - (int) getBlockLength());\n        } else {\n            long curpos = getState().getBlockRemaining();\n            getState().setBlockRemaining(\n                    getState().getBlockRemaining() - (int) getBlockLength());\n            int i = 0;\n            while (i < getBlockLength() - 10) {\n                if (content[i] != 0xe8) {\n                    i++;\n                    continue;\n                }\n                byte[] b = new byte[4];\n                b[0] = getContent()[i + 3];\n                b[1] = getContent()[i + 2];\n                b[2] = getContent()[i + 1];\n                b[3] = getContent()[i + 0];\n                long absoff = (new BigInteger(b)).longValue();\n                if ((absoff >= -curpos)\n                        && (absoff < getState().getIntelFileSize())) {\n                    long reloff = (absoff >= 0) ? absoff - curpos : absoff\n                            + getState().getIntelFileSize();\n                    getContent()[i + 0] = (byte) reloff;\n                    getContent()[i + 1] = (byte) (reloff >>> 8);\n                    getContent()[i + 2] = (byte) (reloff >>> 16);\n                    getContent()[i + 3] = (byte) (reloff >>> 24);\n                }\n                i += 4;\n                curpos += 5;\n            }\n        }\n    }\n    private short[] createPreLenTable() {\n        short[] tmp = new short[ChmConstants.LZX_PRETREE_MAXSYMBOLS];\n        for (int i = 0; i < ChmConstants.LZX_PRETREE_MAXSYMBOLS; i++) {\n            tmp[i] = (short) getChmSection().getSyncBits(\n                    ChmConstants.LZX_PRETREE_NUM_ELEMENTS_BITS);\n        }\n        return tmp;\n    }\n    private void createLengthTreeTable() throws TikaException {\n        //Read Pre Tree Table\n        short[] prelentable = createPreLenTable();\n        if (prelentable == null) {\n            throw new ChmParsingException(\"pretreetable is null\");\n        }\n        short[] pretreetable = createTreeTable2(prelentable,<fim_middle>// class below has no smell\n"}