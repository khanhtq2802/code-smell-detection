{"text": "<fim_prefix>import org.apache.accumulo.core.data.Mutation;\nimport org.apache.accumulo.core.data.Range;\nimport org.apache.accumulo.core.data.TableId;\nimport org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.file.FileSKVIterator;\nimport org.apache.accumulo.core.file.FileSKVWriter;\nimport org.apache.accumulo.core.file.rfile.RFile;\nimport org.apache.accumulo.core.file.rfile.RFileOperations;\nimport org.apache.accumulo.core.iterators.IteratorEnvironment;\nimport org.apache.accumulo.core.iterators.SortedKeyValueIterator;\nimport org.apache.accumulo.core.iterators.SortedMapIterator;\nimport org.apache.accumulo.core.iterators.WrappingIterator;\nimport org.apache.accumulo.core.iterators.system.EmptyIterator;\nimport org.apache.accumulo.core.iterators.system.InterruptibleIterator;\nimport org.apache.accumulo.core.iterators.system.LocalityGroupIterator;\nimport org.apache.accumulo.core.iterators.system.LocalityGroupIterator.LocalityGroup;\nimport org.apache.accumulo.core.iterators.system.SourceSwitchingIterator;\nimport org.apache.accumulo.core.iterators.system.SourceSwitchingIterator.DataSource;\nimport org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\nimport org.apache.accumulo.core.sample.impl.SamplerFactory;\nimport org.apache.accumulo.core.util.LocalityGroupUtil;\nimport org.apache.accumulo.core.util.LocalityGroupUtil.Partitioner;\nimport org.apache.accumulo.core.util.Pair;\nimport org.apache.accumulo.core.util.PreAllocatedArray;\nimport org.apache.accumulo.server.ServerContext;\nimport org.apache.commons.lang.mutable.MutableLong;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.collect.Iterables;\npublic class InMemoryMap {\n  private SimpleMap map = null;\n  private static final Logger log = LoggerFactory.getLogger(InMemoryMap.class);\n  private ServerContext context;\n  private volatile String memDumpFile = null;\n  private final String memDumpDir;\n  private final String mapType;\n  private Map<String,Set<ByteSequence>> lggroups;\n  private static Pair<SamplerConfigurationImpl,Sampler> getSampler(AccumuloConfiguration config) {\n    try {\n      SamplerConfigurationImpl sampleConfig = SamplerConfigurationImpl.newSamplerConfig(config);\n      if (sampleConfig == null) {\n        return new Pair<>(null, null);\n      }\n      return new Pair<>(sampleConfig, SamplerFactory.newSampler(sampleConfig, config));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public static final String TYPE_NATIVE_MAP_WRAPPER = \"NativeMapWrapper\";\n  public static final String TYPE_DEFAULT_MAP = \"DefaultMap\";\n  public static final String TYPE_LOCALITY_GROUP_MAP = \"LocalityGroupMap\";\n  public static final String TYPE_LOCALITY_GROUP_MAP_NATIVE = \"LocalityGroupMap with native\";\n  // @formatter:off\n  private AtomicReference<Pair<SamplerConfigurationImpl,Sampler>> samplerRef =\n    new AtomicReference<>(null);\n  // @formatter:on\n  private AccumuloConfiguration config;\n  // defer creating sampler until first write. This was done because an empty sample map configured\n  // with no sampler will not flush after a user changes sample\n  // config.\n  private Sampler getOrCreateSampler() {\n    Pair<SamplerConfigurationImpl,Sampler> pair = samplerRef.get();\n    if (pair == null) {\n      pair = getSampler(config);\n      if (!samplerRef.compareAndSet(null, pair)) {\n        pair = samplerRef.get();\n      }\n    }\n    return pair.getSecond();\n  }\n  public InMemoryMap(AccumuloConfiguration config, ServerContext serverContext, TableId tableId) {\n    boolean useNativeMap = config.getBoolean(Property.TSERV_NATIVEMAP_ENABLED);\n    this.memDumpDir = config.get(Property.TSERV_MEMDUMP_DIR);\n    this.lggroups = LocalityGroupUtil.getLocalityGroupsIgnoringErrors(config, tableId);\n    this.config = config;\n    this.context = serverContext;\n    SimpleMap allMap;\n    SimpleMap sampleMap;\n    if (lggroups.size() == 0) {\n      allMap = newMap(useNativeMap);\n      sampleMap = newMap(useNativeMap);\n      mapType = useNativeMap ? TYPE_NATIVE_MAP_WRAPPER : TYPE_DEFAULT_MAP;\n    } else {\n      allMap = new LocalityGroupMap(lggroups, useNativeMap);\n      sampleMap = new LocalityGroupMap(lggroups, useNativeMap);\n      mapType = useNativeMap ? TYPE_LOCALITY_GROUP_MAP_NATIVE : TYPE_LOCALITY_GROUP_MAP;\n    }\n    map = new SampleMap(allMap, sampleMap);\n  }\n  private static SimpleMap newMap(boolean useNativeMap) {\n    if (useNativeMap && NativeMap.isLoaded()) {\n      try {\n        return new NativeMapWrapper();\n      } catch (Throwable t) {\n        log.error(\"Failed to create native map\", t);\n      }\n    }\n    return new DefaultMap();\n  }\n  /**\n   * Description of the type of SimpleMap that is created.\n   * <p>\n   * If no locality groups are present, the SimpleMap is either TYPE_DEFAULT_MAP or\n   * TYPE_NATIVE_MAP_WRAPPER. If there is one more locality groups, then the InMemoryMap has an\n   * array for simple maps that either contain either TYPE_LOCALITY_GROUP_MAP which contains\n   * DefaultMaps or TYPE_LOCALITY_GROUP_MAP_NATIVE which contains NativeMapWrappers.\n   *\n   * @return String that describes the Map type\n   */\n  public String getMapType() {\n    return mapType;\n  }\n  private interface SimpleMap {\n    int size();\n    InterruptibleIterator skvIterator(SamplerConfigurationImpl samplerConfig);\n    void delete();\n    long getMemoryUsed();\n    void mutate(List<Mutation> mutations, int kvCount);\n  }\n<fim_suffix>  private class SampleMap implements SimpleMap {\n    private SimpleMap map;\n    private SimpleMap sample;\n    public SampleMap(SimpleMap map, SimpleMap sampleMap) {\n      this.map = map;\n      this.sample = sampleMap;\n    }\n    @Override\n    public int size() {\n      return map.size();\n    }\n    @Override\n    public InterruptibleIterator skvIterator(SamplerConfigurationImpl samplerConfig) {\n      if (samplerConfig == null)\n        return map.skvIterator(null);\n      else {\n        Pair<SamplerConfigurationImpl,Sampler> samplerAndConf = samplerRef.get();\n        if (samplerAndConf == null) {\n          return EmptyIterator.EMPTY_ITERATOR;\n        } else if (samplerAndConf.getFirst() != null\n            && samplerAndConf.getFirst().equals(samplerConfig)) {\n          return sample.skvIterator(null);\n        } else {\n          throw new SampleNotPresentException();\n        }\n      }\n    }\n    @Override\n    public void delete() {\n      map.delete();\n      sample.delete();\n    }\n    @Override\n    public long getMemoryUsed() {\n      return map.getMemoryUsed() + sample.getMemoryUsed();\n    }\n    @Override\n    public void mutate(List<Mutation> mutations, int kvCount) {\n      map.mutate(mutations, kvCount);\n      Sampler sampler = getOrCreateSampler();\n      if (sampler != null) {\n        List<Mutation> sampleMutations = null;\n        for (Mutation m : mutations) {\n          List<ColumnUpdate> colUpdates = m.getUpdates();\n          List<ColumnUpdate> sampleColUpdates = null;\n          for (ColumnUpdate cvp : colUpdates) {\n            Key k = new Key(m.getRow(), cvp.getColumnFamily(), cvp.getColumnQualifier(),\n                cvp.getColumnVisibility(), cvp.getTimestamp(), cvp.isDeleted(), false);\n            if (sampler.accept(k)) {\n              if (sampleColUpdates == null) {\n                sampleColUpdates = new ArrayList<>();\n              }\n              sampleColUpdates.add(cvp);\n            }\n          }\n          if (sampleColUpdates != null) {\n            if (sampleMutations == null) {\n              sampleMutations = new ArrayList<>();\n            }\n            sampleMutations\n                .add(new LocalityGroupUtil.PartitionedMutation(m.getRow(), sampleColUpdates));\n          }\n        }\n        if (sampleMutations != null) {\n          sample.mutate(sampleMutations, kvCount);\n        }\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}