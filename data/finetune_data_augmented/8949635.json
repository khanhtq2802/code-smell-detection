{"text": "<fim_prefix>                .unregisterTask(request.getAmHost(), request.getAmPort(),\n                    fragmentInfo.getQueryInfo().getQueryIdentifier(), ta);\n          }\n        }\n      } else {\n        // This should not happen.\n        LOG.warn(\"Ignoring kill request for task {} since a previous kill request was processed\",\n            taskSpec.getTaskAttemptID());\n      }\n    } else {\n      LOG.info(\"Ignoring kill request for task {} since it's already complete\",\n          taskSpec.getTaskAttemptID());\n    }\n  }\n  /**\n   * Inform the AM that this task has been killed.\n   */\n  public void reportTaskKilled() {\n    killedTaskHandler\n        .taskKilled(request.getAmHost(), request.getAmPort(), vertex.getTokenIdentifier(), jobToken,\n            fragmentInfo.getQueryInfo().getQueryIdentifier(), taskSpec.getTaskAttemptID());\n  }\n  public boolean canFinish() {\n    return QueryFragmentInfo.canFinish(fragmentInfo);\n  }\n  public boolean canFinishForPriority() {\n    return fragmentInfo.canFinishForPriority();\n  }\n  public void updateCanFinishForPriority(boolean value) {\n    fragmentInfo.setCanFinishForPriority(value);\n  }\n  private static Multimap<String, String> createStartedInputMap(SignableVertexSpec vertex) {\n    Multimap<String, String> startedInputMap = HashMultimap.create();\n    // Let the Processor control start for Broadcast inputs.\n    // TODO For now, this affects non broadcast unsorted cases as well. Make use of the edge\n    // property when it's available.\n    for (IOSpecProto inputSpec : vertex.getInputSpecsList()) {\n      if (inputSpec.getIoDescriptor().getClassName().equals(UnorderedKVInput.class.getName())) {\n        startedInputMap.put(vertex.getVertexName(), inputSpec.getConnectedVertexName());\n      }\n    }\n    return startedInputMap;\n  }\n  public void shutdown() {\n    if (executor != null) {\n      executor.shutdownNow();\n    }\n    if (taskReporter != null) {\n      taskReporter.shutdown();\n    }\n    if (umbilical != null) {\n      // TODO: Can this be moved out of the main callback path\n      RPC.stopProxy(umbilical);\n    }\n  }\n  @Override\n  public String toString() {\n    return requestId + \" {canFinish: \" + canFinish() +\n        \", vertexParallelism: \" + vertex.getVertexParallelism() +\n        \", selfAndUpstreamParallelism: \" + request.getFragmentRuntimeInfo().getNumSelfAndUpstreamTasks() +\n        \", selfAndUpstreamComplete: \" + request.getFragmentRuntimeInfo().getNumSelfAndUpstreamCompletedTasks() +\n        \", firstAttemptStartTime: \" + getFragmentRuntimeInfo().getFirstAttemptStartTime() +\n        \", dagStartTime:\" + getFragmentRuntimeInfo().getDagStartTime() +\n        \", withinDagPriority: \" + getFragmentRuntimeInfo().getWithinDagPriority() +\n        \"}\";\n  }\n  @Override\n  public int hashCode() {\n    return requestId.hashCode();\n  }\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof TaskRunnerCallable)) {\n      return false;\n    }\n    return requestId.equals(((TaskRunnerCallable) obj).getRequestId());\n  }\n  public String getRequestId() {\n    return requestId;\n  }\n  public String getQueryId() {\n    return queryId;\n  }\n  public QueryFragmentInfo getFragmentInfo() {\n    return fragmentInfo;\n  }\n  public TaskRunnerCallback getCallback() {\n    return new TaskRunnerCallback(request, vertex, this);\n  }\n  public SubmitWorkRequestProto getRequest() {\n    return request;\n  }\n  final class TaskRunnerCallback implements FutureCallback<TaskRunner2Result> {\n    private final SubmitWorkRequestProto request;\n    private final SignableVertexSpec vertex;\n    private final TaskRunnerCallable taskRunnerCallable;\n    TaskRunnerCallback(SubmitWorkRequestProto request, SignableVertexSpec vertex,\n        TaskRunnerCallable taskRunnerCallable) {\n      this.request = request;\n      this.vertex = vertex;\n      this.taskRunnerCallable = taskRunnerCallable;\n    }\n    // Errors are handled on the way over. FAIL/SUCCESS is informed via regular heartbeats. Killed\n    // via a kill message when a task kill is requested by the daemon.\n    @Override\n    public void onSuccess(TaskRunner2Result result) {\n      isCompleted.set(true);\n      switch(result.getEndReason()) {\n        // Only the KILLED case requires a message to be sent out to the AM.\n        case SUCCESS:\n          LOG.debug(\"Successfully finished {}\", requestId);\n          if (metrics != null) {\n            metrics.incrExecutorTotalSuccess();\n          }\n          break;\n        case CONTAINER_STOP_REQUESTED:\n          LOG.info(\"Received container stop request (AM preemption) for {}\", requestId);\n          if (metrics != null) {\n            metrics.incrExecutorTotalKilled();\n          }\n          break;\n        case KILL_REQUESTED:\n          LOG.info(\"Killed task {}\", requestId);\n          if (killtimerWatch.isRunning()) {\n            killtimerWatch.stop();\n            long elapsed = killtimerWatch.elapsed(TimeUnit.MILLISECONDS);\n            LOG.info(\"Time to die for task {}\", elapsed);\n            if (metrics != null) {\n              metrics.addMetricsPreemptionTimeToKill(elapsed);\n            }\n          }\n          if (metrics != null) {\n            metrics.addMetricsPreemptionTimeLost(runtimeWatch.elapsed(TimeUnit.MILLISECONDS));\n            metrics.incrExecutorTotalKilled();\n          }\n          break;\n        case COMMUNICATION_FAILURE:\n          LOG.info(\"Failed to run {} due to communication failure\", requestId);\n          if (metrics != null) {\n            metrics.incrExecutorTotalExecutionFailed();\n          }\n          break;\n        case TASK_ERROR:\n          LOG.info(\"Failed to run {} due to task error\", requestId);\n          if (metrics != null) {\n            metrics.incrExecutorTotalExecutionFailed();\n          }\n          break;\n      }\n      fragmentCompletionHanler.fragmentComplete(fragmentInfo);\n      taskRunnerCallable.shutdown();\n      logFragmentEnd(true);\n    }\n    @Override\n    public void onFailure(Throwable t) {\n      LOG.error(\"TezTaskRunner execution failed for : \"\n          + getTaskIdentifierString(request, vertex, queryId), t);\n      isCompleted.set(true);\n      fragmentCompletionHanler.fragmentComplete(fragmentInfo);\n      // TODO HIVE-10236 Report a fatal error over the umbilical\n      taskRunnerCallable.shutdown();\n      logFragmentEnd(false);\n    }\n    protected void logFragmentEnd(boolean success) {\n      LOG.info(\"WM counters: {}\", wmCounters);\n      HistoryLogger.logFragmentEnd(vertex.getQueryIdentifier().getApplicationIdString(),\n          request.getContainerIdString(), executionContext.getHostName(), queryId,\n          fragmentInfo.getQueryInfo().getDagIdentifier(), vertex.getVertexName(),\n          request.getFragmentNumber(), request.getAttemptNumber(), taskRunnerCallable.threadName,\n          taskRunnerCallable.startTime, success);\n    }\n  }\n  public static class ConfParams {\n    final int amHeartbeatIntervalMsMax;\n    final long amCounterHeartbeatInterval;\n    final int amMaxEventsPerHeartbeat;\n    public ConfParams(int amHeartbeatIntervalMsMax, long amCounterHeartbeatInterval,\n        int amMaxEventsPerHeartbeat) {\n      this.amHeartbeatIntervalMsMax = amHeartbeatIntervalMsMax;\n      this.amCounterHeartbeatInterval = amCounterHeartbeatInterval;\n      this.amMaxEventsPerHeartbeat = amMaxEventsPerHeartbeat;\n    }\n  }\n  public static String getTaskIdentifierString(\n      SubmitWorkRequestProto request, SignableVertexSpec vertex, String queryId) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"AppId=\").append(vertex.getQueryIdentifier().getApplicationIdString())\n        .append(\", containerId=\").append(request.getContainerIdString())\n        .append(\", QueryId=\").append(queryId)\n        .append(\", Vertex=\").append(vertex.getVertexName())\n        .append(\", FragmentNum=\").append(request.getFragmentNumber())\n        .append(\", Attempt=\").append(request.getAttemptNumber());\n    return sb.toString();\n  }\n  public FragmentRuntimeInfo getFragmentRuntimeInfo() {\n    return request.getFragmentRuntimeInfo();\n  }\n  public SignableVertexSpec getVertexSpec() {\n    // TODO: support for binary spec? presumably we'd parse it somewhere earlier\n    return vertex;\n  }\n  public boolean isGuaranteed() {\n    return isGuaranteed;\n  }\n  public void setIsGuaranteed(boolean isGuaranteed) {\n    this.isGuaranteed = isGuaranteed;\n    if (amNodeInfo != null) {\n      amNodeInfo.updateTaskAttempt(taskSpec.getTaskAttemptID(), isGuaranteed);\n    }\n    if (wmCounters != null) {\n      wmCounters.changeGuaranteed(isGuaranteed);\n    }\n  }\n<fim_suffix>  public void setWmCountersDone() {\n    if (wmCounters != null) {\n      wmCounters.changeStateDone();\n    }\n  }<fim_middle>// function below has no smell\n"}