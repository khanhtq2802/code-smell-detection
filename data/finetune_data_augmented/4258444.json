{"text": "<fim_prefix>    }\n    /**\n     * Query the server for a supported feature with particular value,\n     * for example \"AUTH SSL\" or \"AUTH TLS\".\n     * Caches the parsed response to avoid resending the command repeatedly.\n     *\n     * @param feature the name of the feature; it is converted to upper case.\n     * @param value the value to find.\n     *\n     * @return {@code true} if the feature is present, {@code false} if the feature is not present\n     * or the {@link #feat()} command failed. Check {@link #getReplyCode()} or {@link #getReplyString()}\n     * if it is necessary to distinguish these cases.\n     *\n     * @throws IOException on error\n     * @since 3.0\n     */\n    public boolean hasFeature(String feature, String value) throws IOException {\n        if (!initFeatureMap()) {\n            return false;\n        }\n        Set<String> entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));\n        if (entries != null) {\n            return entries.contains(value);\n        }\n        return false;\n    }\n    /*\n     * Create the feature map if not already created.\n     */\n    private boolean initFeatureMap() throws IOException {\n        if (__featuresMap == null) {\n            // Don't create map here, because next line may throw exception\n            final int replyCode = feat();\n            if (replyCode == FTPReply.NOT_LOGGED_IN) { // 503\n                return false; // NET-518; don't create empy map\n            }\n            boolean success = FTPReply.isPositiveCompletion(replyCode);\n            // we init the map here, so we don't keep trying if we know the command will fail\n            __featuresMap = new HashMap<String, Set<String>>();\n            if (!success) {\n                return false;\n            }\n            for (String l : getReplyStrings()) {\n                if (l.startsWith(\" \")) { // it's a FEAT entry\n                    String key;\n                    String value=\"\";\n                    int varsep = l.indexOf(' ', 1);\n                    if (varsep > 0) {\n                        key = l.substring(1, varsep);\n                        value = l.substring(varsep+1);\n                    } else {\n                        key = l.substring(1);\n                    }\n                    key = key.toUpperCase(Locale.ENGLISH);\n                    Set<String> entries = __featuresMap.get(key);\n                    if (entries == null) {\n                        entries = new HashSet<String>();\n                        __featuresMap.put(key, entries);\n                    }\n                    entries.add(value);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Reserve space on the server for the next file transfer.\n     *\n     * @param bytes  The number of bytes which the server should allocate.\n     * @param recordSize  The size of a file record.\n     * @return True if successfully completed, false if not.\n     * @throws FTPConnectionClosedException\n     *      If the FTP server prematurely closes the connection as a result\n     *      of the client being idle or some other reason causing the server\n     *      to send FTP reply code 421.  This exception may be caught either\n     *      as an IOException or independently as itself.\n     * @throws IOException  If an I/O error occurs while either sending a\n     *      command to the server or receiving a reply from the server.\n     */\n    public boolean allocate(int bytes, int recordSize) throws IOException\n    {\n        return FTPReply.isPositiveCompletion(allo(bytes, recordSize));\n    }\n    /**\n     * Issue a command and wait for the reply.\n     * <p>\n     * Should only be used with commands that return replies on the\n     * command channel - do not use for LIST, NLST, MLSD etc.\n     *\n     * @param command  The command to invoke\n     * @param params  The parameters string, may be {@code null}\n     * @return True if successfully completed, false if not, in which case\n     * call {@link #getReplyCode()} or {@link #getReplyString()}\n     * to get the reason.\n     *\n     * @throws IOException  If an I/O error occurs while either sending a\n     *      command to the server or receiving a reply from the server.\n     * @since 3.0\n     */\n    public boolean doCommand(String command, String params) throws IOException\n    {\n        return FTPReply.isPositiveCompletion(sendCommand(command, params));\n    }\n    /**\n     * Issue a command and wait for the reply, returning it as an array of strings.\n     * <p>\n     * Should only be used with commands that return replies on the\n     * command channel - do not use for LIST, NLST, MLSD etc.\n     *\n     * @param command  The command to invoke\n     * @param params  The parameters string, may be {@code null}\n     * @return The array of replies, or {@code null} if the command failed, in which case\n     * call {@link #getReplyCode()} or {@link #getReplyString()}\n     * to get the reason.\n     *\n     * @throws IOException  If an I/O error occurs while either sending a\n     *      command to the server or receiving a reply from the server.\n     * @since 3.0\n     */\n    public String[] doCommandAsStrings(String command, String params) throws IOException\n    {\n        boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));\n        if (success){\n            return getReplyStrings();\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Get file details using the MLST command\n     *\n     * @param pathname the file or directory to list, may be {@code null}\n     * @return the file details, may be {@code null}\n     * @throws IOException on error\n     * @since 3.0\n     */\n    public FTPFile mlistFile(String pathname) throws IOException\n    {\n        boolean success = FTPReply.isPositiveCompletion(sendCommand(FTPCmd.MLST, pathname));\n        if (success){\n            String reply = getReplyStrings()[1];\n            /* check the response makes sense.\n             * Must have space before fact(s) and between fact(s) and filename\n             * Fact(s) can be absent, so at least 3 chars are needed.\n             */\n            if (reply.length() < 3 || reply.charAt(0) != ' ') {\n                throw new MalformedServerReplyException(\"Invalid server reply (MLST): '\" + reply + \"'\");\n            }\n            String entry = reply.substring(1); // skip leading space for parser\n            return MLSxEntryParser.parseEntry(entry);\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Generate a directory listing for the current directory using the MLSD command.\n     *\n     * @return the array of file entries\n     * @throws IOException on error\n     * @since 3.0\n     */\n    public FTPFile[] mlistDir() throws IOException\n    {\n        return mlistDir(null);\n    }\n    /**\n     * Generate a directory listing using the MLSD command.\n     *\n     * @param pathname the directory name, may be {@code null}\n     * @return the array of file entries\n     * @throws IOException on error\n     * @since 3.0\n     */\n    public FTPFile[] mlistDir(String pathname) throws IOException\n    {\n        FTPListParseEngine engine = initiateMListParsing( pathname);\n        return engine.getFiles();\n    }\n    /**\n     * Generate a directory listing using the MLSD command.\n     *\n     * @param pathname the directory name, may be {@code null}\n     * @param filter the filter to apply to the responses\n     * @return the array of file entries\n     * @throws IOException on error\n     * @since 3.0\n     */\n<fim_suffix>    public FTPFile[] mlistDir(String pathname, FTPFileFilter filter) throws IOException\n    {\n        FTPListParseEngine engine = initiateMListParsing( pathname);\n        return engine.getFiles(filter);\n    }<fim_middle>// function below has no smell\n"}