{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n *******************************************************************************/\npackage org.eclipse.rdf4j.query.parser.sparql;\n\nimport java.net.URISyntaxException;\n\nimport org.eclipse.rdf4j.common.net.ParsedIRI;\nimport org.eclipse.rdf4j.common.net.ParsedURI;\nimport org.eclipse.rdf4j.query.MalformedQueryException;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTBaseDecl;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTDeleteData;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTIRI;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTIRIFunc;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTInsertData;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTOperationContainer;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTServiceGraphPattern;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.ASTUnparsedQuadDataBlock;\nimport org.eclipse.rdf4j.query.parser.sparql.ast.VisitorException;\n\n/**\n * Resolves relative URIs in a query model using either an external base URI or using the base URI specified in the\n * query model itself. The former takes precedence over the latter.\n * \n * @author Arjohn Kampman\n */\n<fim_suffix>public class BaseDeclProcessor {\n\n\t/**\n\t * Resolves relative URIs in the supplied query model using either the specified <tt>externalBaseURI</tt> or, if\n\t * this parameter is <tt>null</tt>, the base URI specified in the query model itself.\n\t * \n\t * @param qc              The query model to resolve relative URIs in.\n\t * @param externalBaseURI The external base URI to use for resolving relative URIs, or <tt>null</tt> if the base URI\n\t *                        that is specified in the query model should be used.\n\t * @throws IllegalArgumentException If an external base URI is specified that is not an absolute URI.\n\t * @throws MalformedQueryException  If the base URI specified in the query model is not an absolute URI.\n\t */\n\tpublic static void process(ASTOperationContainer qc, String externalBaseURI) throws MalformedQueryException {\n\t\tParsedIRI parsedBaseURI = null;\n\n\t\t// Use the query model's own base URI, if available\n\t\tASTBaseDecl baseDecl = qc.getBaseDecl();\n\t\tif (baseDecl != null) {\n\t\t\ttry {\n\t\t\t\tparsedBaseURI = new ParsedIRI(baseDecl.getIRI());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tthrow new MalformedQueryException(e);\n\t\t\t}\n\n\t\t\tif (!parsedBaseURI.isAbsolute()) {\n\t\t\t\tthrow new MalformedQueryException(\"BASE IRI is not an absolute IRI: \" + externalBaseURI);\n\t\t\t}\n\t\t} else if (externalBaseURI != null) {\n\t\t\t// Use external base URI if the query doesn't contain one itself\n\t\t\ttry {\n\t\t\t\tparsedBaseURI = new ParsedIRI(externalBaseURI);\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tthrow new MalformedQueryException(e);\n\t\t\t}\n\n\t\t\tif (!parsedBaseURI.isAbsolute()) {\n\t\t\t\tthrow new IllegalArgumentException(\"Supplied base URI is not an absolute IRI: \" + externalBaseURI);\n\t\t\t}\n\t\t} else {\n\t\t\t// FIXME: use the \"Default Base URI\"?\n\t\t}\n\n\t\tif (parsedBaseURI != null) {\n\t\t\tASTUnparsedQuadDataBlock dataBlock = null;\n\t\t\tif (qc.getOperation() instanceof ASTInsertData) {\n\t\t\t\tASTInsertData insertData = (ASTInsertData) qc.getOperation();\n\t\t\t\tdataBlock = insertData.jjtGetChild(ASTUnparsedQuadDataBlock.class);\n\n\t\t\t} else if (qc.getOperation() instanceof ASTDeleteData) {\n\t\t\t\tASTDeleteData deleteData = (ASTDeleteData) qc.getOperation();\n\t\t\t\tdataBlock = deleteData.jjtGetChild(ASTUnparsedQuadDataBlock.class);\n\t\t\t}\n\n\t\t\tif (dataBlock != null) {\n\t\t\t\tfinal String baseURIDeclaration = \"BASE <\" + parsedBaseURI + \"> \\n\";\n\t\t\t\tdataBlock.setDataBlock(baseURIDeclaration + dataBlock.getDataBlock());\n\t\t\t} else {\n\t\t\t\tRelativeIRIResolver visitor = new RelativeIRIResolver(parsedBaseURI);\n\t\t\t\ttry {\n\t\t\t\t\tqc.jjtAccept(visitor, null);\n\t\t\t\t} catch (VisitorException e) {\n\t\t\t\t\tthrow new MalformedQueryException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class RelativeIRIResolver extends AbstractASTVisitor {\n\n\t\tprivate ParsedIRI parsedBaseURI;\n\n\t\tpublic RelativeIRIResolver(ParsedURI parsedBaseURI) {\n\t\t\tthis(ParsedIRI.create(parsedBaseURI.toString()));\n\t\t}\n\n\t\tpublic RelativeIRIResolver(ParsedIRI parsedBaseURI) {\n\t\t\tthis.parsedBaseURI = parsedBaseURI;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(ASTIRI node, Object data) throws VisitorException {\n\t\t\tnode.setValue(parsedBaseURI.resolve(node.getValue()));\n\n\t\t\treturn super.visit(node, data);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(ASTIRIFunc node, Object data) throws VisitorException {\n\t\t\tnode.setBaseURI(parsedBaseURI.toString());\n\t\t\treturn super.visit(node, data);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(ASTServiceGraphPattern node, Object data) throws VisitorException {\n\t\t\tnode.setBaseURI(parsedBaseURI.toString());\n\t\t\treturn super.visit(node, data);\n\t\t}\n\t}\n}<fim_middle>// class below is blob\n"}