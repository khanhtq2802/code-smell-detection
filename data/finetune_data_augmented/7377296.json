{"text": "<fim_prefix>import org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.ResponseStatus;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.method.HandlerMethod;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.handler.MatchableHandlerMapping;\nimport org.springframework.web.servlet.handler.RequestMatchResult;\nimport org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.ProducesRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;\n/**\n * A custom {@link HandlerMapping} that makes {@link ExposableWebEndpoint web endpoints}\n * available over HTTP using Spring MVC.\n *\n * @author Andy Wilkinson\n * @author Madhura Bhave\n * @author Phillip Webb\n * @author Brian Clozel\n * @since 2.0.0\n */\npublic abstract class AbstractWebMvcEndpointHandlerMapping\n\t\textends RequestMappingInfoHandlerMapping\n\t\timplements InitializingBean, MatchableHandlerMapping {\n\tprivate final EndpointMapping endpointMapping;\n\tprivate final Collection<ExposableWebEndpoint> endpoints;\n\tprivate final EndpointMediaTypes endpointMediaTypes;\n\tprivate final CorsConfiguration corsConfiguration;\n\tprivate final Method handleMethod = ReflectionUtils.findMethod(OperationHandler.class,\n\t\t\t\"handle\", HttpServletRequest.class, Map.class);\n\tprivate static final RequestMappingInfo.BuilderConfiguration builderConfig = getBuilderConfig();\n\t/**\n\t * Creates a new {@code WebEndpointHandlerMapping} that provides mappings for the\n\t * operations of the given {@code webEndpoints}.\n\t * @param endpointMapping the base mapping for all endpoints\n\t * @param endpoints the web endpoints\n\t * @param endpointMediaTypes media types consumed and produced by the endpoints\n\t */\n\tpublic AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,\n\t\t\tCollection<ExposableWebEndpoint> endpoints,\n\t\t\tEndpointMediaTypes endpointMediaTypes) {\n\t\tthis(endpointMapping, endpoints, endpointMediaTypes, null);\n\t}\n\t/**\n\t * Creates a new {@code AbstractWebMvcEndpointHandlerMapping} that provides mappings\n\t * for the operations of the given endpoints.\n\t * @param endpointMapping the base mapping for all endpoints\n\t * @param endpoints the web endpoints\n\t * @param endpointMediaTypes media types consumed and produced by the endpoints\n\t * @param corsConfiguration the CORS configuration for the endpoints or {@code null}\n\t */\n\tpublic AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,\n\t\t\tCollection<ExposableWebEndpoint> endpoints,\n\t\t\tEndpointMediaTypes endpointMediaTypes, CorsConfiguration corsConfiguration) {\n\t\tthis.endpointMapping = endpointMapping;\n\t\tthis.endpoints = endpoints;\n\t\tthis.endpointMediaTypes = endpointMediaTypes;\n\t\tthis.corsConfiguration = corsConfiguration;\n\t\tsetOrder(-100);\n\t}\n\t@Override\n\tprotected void initHandlerMethods() {\n\t\tfor (ExposableWebEndpoint endpoint : this.endpoints) {\n\t\t\tfor (WebOperation operation : endpoint.getOperations()) {\n\t\t\t\tregisterMappingForOperation(endpoint, operation);\n\t\t\t}\n\t\t}\n\t\tif (StringUtils.hasText(this.endpointMapping.getPath())) {\n\t\t\tregisterLinksMapping();\n\t\t}\n\t}\n\t@Override\n\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod = super.createHandlerMethod(handler, method);\n\t\treturn new WebMvcEndpointHandlerMethod(handlerMethod.getBean(),\n\t\t\t\thandlerMethod.getMethod());\n\t}\n\t@Override\n\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tRequestMappingInfo info = RequestMappingInfo.paths(pattern).options(builderConfig)\n\t\t\t\t.build();\n\t\tRequestMappingInfo matchingInfo = info.getMatchingCondition(request);\n\t\tif (matchingInfo == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSet<String> patterns = matchingInfo.getPatternsCondition().getPatterns();\n\t\tString lookupPath = getUrlPathHelper().getLookupPathForRequest(request);\n\t\treturn new RequestMatchResult(patterns.iterator().next(), lookupPath,\n\t\t\t\tgetPathMatcher());\n\t}\n\tprivate static RequestMappingInfo.BuilderConfiguration getBuilderConfig() {\n\t\tRequestMappingInfo.BuilderConfiguration config = new RequestMappingInfo.BuilderConfiguration();\n\t\tconfig.setUrlPathHelper(null);\n\t\tconfig.setPathMatcher(null);\n\t\tconfig.setSuffixPatternMatch(false);\n\t\tconfig.setTrailingSlashMatch(true);\n\t\treturn config;\n\t}\n\tprivate void registerMappingForOperation(ExposableWebEndpoint endpoint,\n\t\t\tWebOperation operation) {\n\t\tServletWebOperation servletWebOperation = wrapServletWebOperation(endpoint,\n\t\t\t\toperation, new ServletWebOperationAdapter(operation));\n\t\tregisterMapping(createRequestMappingInfo(operation),\n\t\t\t\tnew OperationHandler(servletWebOperation), this.handleMethod);\n\t}\n\t/**\n\t * Hook point that allows subclasses to wrap the {@link ServletWebOperation} before\n\t * it's called. Allows additional features, such as security, to be added.\n\t * @param endpoint the source endpoint\n\t * @param operation the source operation\n\t * @param servletWebOperation the servlet web operation to wrap\n\t * @return a wrapped servlet web operation\n\t */\n\tprotected ServletWebOperation wrapServletWebOperation(ExposableWebEndpoint endpoint,\n\t\t\tWebOperation operation, ServletWebOperation servletWebOperation) {\n\t\treturn servletWebOperation;\n\t}\n\tprivate RequestMappingInfo createRequestMappingInfo(WebOperation operation) {\n\t\tWebOperationRequestPredicate predicate = operation.getRequestPredicate();\n\t\tPatternsRequestCondition patterns = patternsRequestConditionForPattern(\n\t\t\t\tpredicate.getPath());\n\t\tRequestMethodsRequestCondition methods = new RequestMethodsRequestCondition(\n\t\t\t\tRequestMethod.valueOf(predicate.getHttpMethod().name()));\n\t\tConsumesRequestCondition consumes = new ConsumesRequestCondition(\n\t\t\t\tStringUtils.toStringArray(predicate.getConsumes()));\n\t\tProducesRequestCondition produces = new ProducesRequestCondition(\n\t\t\t\tStringUtils.toStringArray(predicate.getProduces()));\n\t\treturn new RequestMappingInfo(null, patterns, methods, null, null, consumes,\n\t\t\t\tproduces, null);\n\t}\n\tprivate void registerLinksMapping() {\n\t\tPatternsRequestCondition patterns = patternsRequestConditionForPattern(\"\");\n\t\tRequestMethodsRequestCondition methods = new RequestMethodsRequestCondition(\n\t\t\t\tRequestMethod.GET);\n\t\tProducesRequestCondition produces = new ProducesRequestCondition(\n\t\t\t\tthis.endpointMediaTypes.getProduced().toArray(StringUtils\n\t\t\t\t\t\t.toStringArray(this.endpointMediaTypes.getProduced())));\n\t\tRequestMappingInfo mapping = new RequestMappingInfo(patterns, methods, null, null,\n\t\t\t\tnull, produces, null);\n\t\tLinksHandler linksHandler = getLinksHandler();\n\t\tregisterMapping(mapping, linksHandler,\n\t\t\t\tReflectionUtils.findMethod(linksHandler.getClass(), \"links\",\n\t\t\t\t\t\tHttpServletRequest.class, HttpServletResponse.class));\n\t}\n\tprivate PatternsRequestCondition patternsRequestConditionForPattern(String path) {\n\t\tString[] patterns = new String[] { this.endpointMapping.createSubPath(path) };\n\t\treturn new PatternsRequestCondition(patterns, builderConfig.getUrlPathHelper(),\n\t\t\t\tbuilderConfig.getPathMatcher(), builderConfig.useSuffixPatternMatch(),\n\t\t\t\tbuilderConfig.useTrailingSlashMatch());\n\t}\n\t@Override\n\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method,\n\t\t\tRequestMappingInfo mapping) {\n\t\treturn this.corsConfiguration;\n\t}\n\t@Override\n\tprotected boolean isHandler(Class<?> beanType) {\n\t\treturn false;\n\t}\n\t@Override\n\tprotected RequestMappingInfo getMappingForMethod(Method method,\n\t\t\tClass<?> handlerType) {\n\t\treturn null;\n\t}\n\t@Override\n\tprotected void extendInterceptors(List<Object> interceptors) {\n\t\tinterceptors.add(new SkipPathExtensionContentNegotiation());\n\t}\n\t/**\n\t * Return the Handler providing actuator links at the root endpoint.\n\t * @return the links handler\n\t */\n\tprotected abstract LinksHandler getLinksHandler();\n\t/**\n\t * Return the web endpoints being mapped.\n\t * @return the endpoints\n\t */\n\tpublic Collection<ExposableWebEndpoint> getEndpoints() {\n\t\treturn this.endpoints;\n\t}\n\t/**\n\t * Handler providing actuator links at the root endpoint.\n\t */\n<fim_suffix>\t@FunctionalInterface\n\tprotected interface LinksHandler {\n\t\tObject links(HttpServletRequest request, HttpServletResponse response);\n\t}<fim_middle>// class below has no smell\n"}