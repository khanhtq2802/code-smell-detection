{"text": "<fim_prefix>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.UUID;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n/**\n * Parses SmoothStreaming client manifests.\n *\n * @see <a href=\"http://msdn.microsoft.com/en-us/library/ee673436(v=vs.90).aspx\">\n * IIS Smooth Streaming Client Manifest Format</a>\n */\npublic class SsManifestParser implements ParsingLoadable.Parser<SsManifest> {\n  private final XmlPullParserFactory xmlParserFactory;\n  public SsManifestParser() {\n    try {\n      xmlParserFactory = XmlPullParserFactory.newInstance();\n    } catch (XmlPullParserException e) {\n      throw new RuntimeException(\"Couldn't create XmlPullParserFactory instance\", e);\n    }\n  }\n  @Override\n  public SsManifest parse(Uri uri, InputStream inputStream) throws IOException {\n    try {\n      XmlPullParser xmlParser = xmlParserFactory.newPullParser();\n      xmlParser.setInput(inputStream, null);\n      SmoothStreamingMediaParser smoothStreamingMediaParser =\n          new SmoothStreamingMediaParser(null, uri.toString());\n      return (SsManifest) smoothStreamingMediaParser.parse(xmlParser);\n    } catch (XmlPullParserException e) {\n      throw new ParserException(e);\n    }\n  }\n  /**\n   * Thrown if a required field is missing.\n   */\n  public static class MissingFieldException extends ParserException {\n    public MissingFieldException(String fieldName) {\n      super(\"Missing required field: \" + fieldName);\n    }\n  }\n  /**\n   * A base class for parsers that parse components of a smooth streaming manifest.\n   */\n<fim_suffix>  private abstract static class ElementParser {\n    private final String baseUri;\n    private final String tag;\n    private final ElementParser parent;\n    private final List<Pair<String, Object>> normalizedAttributes;\n    public ElementParser(ElementParser parent, String baseUri, String tag) {\n      this.parent = parent;\n      this.baseUri = baseUri;\n      this.tag = tag;\n      this.normalizedAttributes = new LinkedList<>();\n    }\n    public final Object parse(XmlPullParser xmlParser) throws XmlPullParserException, IOException {\n      String tagName;\n      boolean foundStartTag = false;\n      int skippingElementDepth = 0;\n      while (true) {\n        int eventType = xmlParser.getEventType();\n        switch (eventType) {\n          case XmlPullParser.START_TAG:\n            tagName = xmlParser.getName();\n            if (tag.equals(tagName)) {\n              foundStartTag = true;\n              parseStartTag(xmlParser);\n            } else if (foundStartTag) {\n              if (skippingElementDepth > 0) {\n                skippingElementDepth++;\n              } else if (handleChildInline(tagName)) {\n                parseStartTag(xmlParser);\n              } else {\n                ElementParser childElementParser = newChildParser(this, tagName, baseUri);\n                if (childElementParser == null) {\n                  skippingElementDepth = 1;\n                } else {\n                  addChild(childElementParser.parse(xmlParser));\n                }\n              }\n            }\n            break;\n          case XmlPullParser.TEXT:\n            if (foundStartTag && skippingElementDepth == 0) {\n              parseText(xmlParser);\n            }\n            break;\n          case XmlPullParser.END_TAG:\n            if (foundStartTag) {\n              if (skippingElementDepth > 0) {\n                skippingElementDepth--;\n              } else {\n                tagName = xmlParser.getName();\n                parseEndTag(xmlParser);\n                if (!handleChildInline(tagName)) {\n                  return build();\n                }\n              }\n            }\n            break;\n          case XmlPullParser.END_DOCUMENT:\n            return null;\n          default:\n            // Do nothing.\n            break;\n        }\n        xmlParser.next();\n      }\n    }\n    private ElementParser newChildParser(ElementParser parent, String name, String baseUri) {\n      if (QualityLevelParser.TAG.equals(name)) {\n        return new QualityLevelParser(parent, baseUri);\n      } else if (ProtectionParser.TAG.equals(name)) {\n        return new ProtectionParser(parent, baseUri);\n      } else if (StreamIndexParser.TAG.equals(name)) {\n        return new StreamIndexParser(parent, baseUri);\n      }\n      return null;\n    }\n    /**\n     * Stash an attribute that may be normalized at this level. In other words, an attribute that\n     * may have been pulled up from the child elements because its value was the same in all\n     * children.\n     * <p>\n     * Stashing an attribute allows child element parsers to retrieve the values of normalized\n     * attributes using {@link #getNormalizedAttribute(String)}.\n     *\n     * @param key The name of the attribute.\n     * @param value The value of the attribute.\n     */\n    protected final void putNormalizedAttribute(String key, Object value) {\n      normalizedAttributes.add(Pair.create(key, value));\n    }\n    /**\n     * Attempt to retrieve a stashed normalized attribute. If there is no stashed attribute with\n     * the provided name, the parent element parser will be queried, and so on up the chain.\n     *\n     * @param key The name of the attribute.\n     * @return The stashed value, or null if the attribute was not be found.\n     */\n    protected final Object getNormalizedAttribute(String key) {\n      for (int i = 0; i < normalizedAttributes.size(); i++) {\n        Pair<String, Object> pair = normalizedAttributes.get(i);\n        if (pair.first.equals(key)) {\n          return pair.second;\n        }\n      }\n      return parent == null ? null : parent.getNormalizedAttribute(key);\n    }\n    /**\n     * Whether this {@link ElementParser} parses a child element inline.\n     *\n     * @param tagName The name of the child element.\n     * @return Whether the child is parsed inline.\n     */\n    protected boolean handleChildInline(String tagName) {\n      return false;\n    }\n    /**\n     * @param xmlParser The underlying {@link XmlPullParser}\n     * @throws ParserException If a parsing error occurs.\n     */\n    protected void parseStartTag(XmlPullParser xmlParser) throws ParserException {\n      // Do nothing.\n    }\n    /**\n     * @param xmlParser The underlying {@link XmlPullParser}\n     */\n    protected void parseText(XmlPullParser xmlParser) {\n      // Do nothing.\n    }\n    /**\n     * @param xmlParser The underlying {@link XmlPullParser}\n     */\n    protected void parseEndTag(XmlPullParser xmlParser) {\n      // Do nothing.\n    }\n    /**\n     * @param parsedChild A parsed child object.\n     */\n    protected void addChild(Object parsedChild) {\n      // Do nothing.\n    }\n    protected abstract Object build();\n    protected final String parseRequiredString(XmlPullParser parser, String key)\n        throws MissingFieldException {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        return value;\n      } else {\n        throw new MissingFieldException(key);\n      }\n    }\n    protected final int parseInt(XmlPullParser parser, String key, int defaultValue)\n        throws ParserException {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        try {\n          return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n          throw new ParserException(e);\n        }\n      } else {\n        return defaultValue;\n      }\n    }\n    protected final int parseRequiredInt(XmlPullParser parser, String key) throws ParserException {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        try {\n          return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n          throw new ParserException(e);\n        }\n      } else {\n        throw new MissingFieldException(key);\n      }\n    }\n    protected final long parseLong(XmlPullParser parser, String key, long defaultValue)\n        throws ParserException {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        try {\n          return Long.parseLong(value);\n        } catch (NumberFormatException e) {\n          throw new ParserException(e);\n        }\n      } else {\n        return defaultValue;\n      }\n    }\n    protected final long parseRequiredLong(XmlPullParser parser, String key)\n        throws ParserException {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        try {\n          return Long.parseLong(value);\n        } catch (NumberFormatException e) {\n          throw new ParserException(e);\n        }\n      } else {\n        throw new MissingFieldException(key);\n      }\n    }\n    protected final boolean parseBoolean(XmlPullParser parser, String key, boolean defaultValue) {\n      String value = parser.getAttributeValue(null, key);\n      if (value != null) {\n        return Boolean.parseBoolean(value);\n      } else {\n        return defaultValue;\n      }\n    }\n  }<fim_middle>// class below is blob\n"}