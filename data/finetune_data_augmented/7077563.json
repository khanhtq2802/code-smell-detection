{"text": "<fim_prefix>     * compared using a byte-by-byte comparison.\n     * <p>\n     * When the {@code keyIdentifier} field of\n     * {@code AuthorityKeyIdentifier} is populated, the value is\n     * usually taken from the {@code SubjectKeyIdentifier} extension\n     * in the issuer's certificate.  Note, however, that the result of\n     * {@code X509Certificate.getExtensionValue(<SubjectKeyIdentifier Object\n     * Identifier>)} on the issuer's certificate may NOT be used\n     * directly as the input to {@code setAuthorityKeyIdentifier}.\n     * This is because the SubjectKeyIdentifier contains\n     * only a KeyIdentifier OCTET STRING, and not a SEQUENCE of\n     * KeyIdentifier, GeneralNames, and CertificateSerialNumber.\n     * In order to use the extension value of the issuer certificate's\n     * {@code SubjectKeyIdentifier}\n     * extension, it will be necessary to extract the value of the embedded\n     * {@code KeyIdentifier} OCTET STRING, then DER encode this OCTET\n     * STRING inside a SEQUENCE.\n     * For more details on SubjectKeyIdentifier, see\n     * {@link #setSubjectKeyIdentifier(byte[] subjectKeyID)}.\n     * <p>\n     * Note also that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param authorityKeyID the authority key identifier\n     *        (or {@code null})\n     * @see #getAuthorityKeyIdentifier\n     */\n    public void setAuthorityKeyIdentifier(byte[] authorityKeyID) {\n        if (authorityKeyID == null) {\n            this.authorityKeyID = null;\n        } else {\n            this.authorityKeyID = authorityKeyID.clone();\n        }\n    }\n    /**\n     * Sets the certificateValid criterion. The specified date must fall\n     * within the certificate validity period for the\n     * {@code X509Certificate}. If {@code null}, no certificateValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} supplied here is cloned to protect\n     * against subsequent modifications.\n     *\n     * @param certValid the {@code Date} to check (or {@code null})\n     * @see #getCertificateValid\n     */\n    public void setCertificateValid(Date certValid) {\n        if (certValid == null) {\n            certificateValid = null;\n        } else {\n            certificateValid = (Date)certValid.clone();\n        }\n    }\n    /**\n     * Sets the privateKeyValid criterion. The specified date must fall\n     * within the private key validity period for the\n     * {@code X509Certificate}. If {@code null}, no privateKeyValid\n     * check will be done.\n     * <p>\n     * Note that the {@code Date} supplied here is cloned to protect\n     * against subsequent modifications.\n     *\n     * @param privateKeyValid the {@code Date} to check (or\n     *                        {@code null})\n     * @see #getPrivateKeyValid\n     */\n    public void setPrivateKeyValid(Date privateKeyValid) {\n        if (privateKeyValid == null) {\n            this.privateKeyValid = null;\n        } else {\n            this.privateKeyValid = (Date)privateKeyValid.clone();\n        }\n    }\n    /**\n     * Sets the subjectPublicKeyAlgID criterion. The\n     * {@code X509Certificate} must contain a subject public key\n     * with the specified algorithm. If {@code null}, no\n     * subjectPublicKeyAlgID check will be done.\n     *\n     * @param oid The object identifier (OID) of the algorithm to check\n     *            for (or {@code null}). An OID is represented by a\n     *            set of nonnegative integers separated by periods.\n     * @throws IOException if the OID is invalid, such as\n     * the first component being not 0, 1 or 2 or the second component\n     * being greater than 39.\n     *\n     * @see #getSubjectPublicKeyAlgID\n     */\n    public void setSubjectPublicKeyAlgID(String oid) throws IOException {\n        if (oid == null) {\n            subjectPublicKeyAlgID = null;\n        } else {\n            subjectPublicKeyAlgID = new ObjectIdentifier(oid);\n        }\n    }\n    /**\n     * Sets the subjectPublicKey criterion. The\n     * {@code X509Certificate} must contain the specified subject public\n     * key. If {@code null}, no subjectPublicKey check will be done.\n     *\n     * @param key the subject public key to check for (or {@code null})\n     * @see #getSubjectPublicKey\n     */\n    public void setSubjectPublicKey(PublicKey key) {\n        if (key == null) {\n            subjectPublicKey = null;\n            subjectPublicKeyBytes = null;\n        } else {\n            subjectPublicKey = key;\n            subjectPublicKeyBytes = key.getEncoded();\n        }\n    }\n    /**\n     * Sets the subjectPublicKey criterion. The {@code X509Certificate}\n     * must contain the specified subject public key. If {@code null},\n     * no subjectPublicKey check will be done.\n     * <p>\n     * Because this method allows the public key to be specified as a byte\n     * array, it may be used for unknown key types.\n     * <p>\n     * If {@code key} is not {@code null}, it should contain a\n     * single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.\n     * The ASN.1 notation for this structure is as follows.\n     * <pre>{@code\n     * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n     *   algorithm            AlgorithmIdentifier,\n     *   subjectPublicKey     BIT STRING  }\n     *\n     * AlgorithmIdentifier  ::=  SEQUENCE  {\n     *   algorithm               OBJECT IDENTIFIER,\n     *   parameters              ANY DEFINED BY algorithm OPTIONAL  }\n     *                              -- contains a value of the type\n     *                              -- registered for use with the\n     *                              -- algorithm object identifier value\n     * }</pre>\n     * <p>\n     * Note that the byte array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param key a byte array containing the subject public key in ASN.1 DER\n     *            form (or {@code null})\n     * @throws IOException if an encoding error occurs (incorrect form for\n     * subject public key)\n     * @see #getSubjectPublicKey\n     */\n    public void setSubjectPublicKey(byte[] key) throws IOException {\n        if (key == null) {\n            subjectPublicKey = null;\n            subjectPublicKeyBytes = null;\n        } else {\n            subjectPublicKeyBytes = key.clone();\n            subjectPublicKey = X509Key.parse(new DerValue(subjectPublicKeyBytes));\n        }\n    }\n    /**\n     * Sets the keyUsage criterion. The {@code X509Certificate}\n     * must allow the specified keyUsage values. If {@code null}, no\n     * keyUsage check will be done. Note that an {@code X509Certificate}\n     * that has no keyUsage extension implicitly allows all keyUsage values.\n     * <p>\n     * Note that the boolean array supplied here is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param keyUsage a boolean array in the same format as the boolean\n     *                 array returned by\n     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.\n     *                 Or {@code null}.\n     * @see #getKeyUsage\n     */\n    public void setKeyUsage(boolean[] keyUsage) {\n        if (keyUsage == null) {\n            this.keyUsage = null;\n        } else {\n            this.keyUsage = keyUsage.clone();\n        }\n    }\n    /**\n     * Sets the extendedKeyUsage criterion. The {@code X509Certificate}\n     * must allow the specified key purposes in its extended key usage\n     * extension. If {@code keyPurposeSet} is empty or {@code null},\n     * no extendedKeyUsage check will be done. Note that an\n     * {@code X509Certificate} that has no extendedKeyUsage extension\n     * implicitly allows all key purposes.\n     * <p>\n     * Note that the {@code Set} is cloned to protect against\n     * subsequent modifications.\n     *\n     * @param keyPurposeSet a {@code Set} of key purpose OIDs in string\n     * format (or {@code null}). Each OID is represented by a set of\n     * nonnegative integers separated by periods.\n     * @throws IOException if the OID is invalid, such as\n     * the first component being not 0, 1 or 2 or the second component\n     * being greater than 39.\n     * @see #getExtendedKeyUsage\n     */\n<fim_suffix>    public void setExtendedKeyUsage(Set<String> keyPurposeSet) throws IOException {\n        if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {\n            this.keyPurposeSet = null;\n            keyPurposeOIDSet = null;\n        } else {\n            this.keyPurposeSet =\n                Collections.unmodifiableSet(new HashSet<String>(keyPurposeSet));\n            keyPurposeOIDSet = new HashSet<ObjectIdentifier>();\n            for (String s : this.keyPurposeSet) {\n                keyPurposeOIDSet.add(new ObjectIdentifier(s));\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}