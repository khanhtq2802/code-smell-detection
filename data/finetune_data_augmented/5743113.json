{"text": "<fim_prefix>\n<fim_suffix>    private void resizeInstructions() {\n        byte[] b = code.data; // bytecode of the method\n        int u, v, label; // indexes in b\n        int i, j; // loop indexes\n        /*\n         * 1st step: As explained above, resizing an instruction may require to\n         * resize another one, which may require to resize yet another one, and\n         * so on. The first step of the algorithm consists in finding all the\n         * instructions that need to be resized, without modifying the code.\n         * This is done by the following \"fix point\" algorithm:\n         * \n         * Parse the code to find the jump instructions whose offset will need\n         * more than 2 bytes to be stored (the future offset is computed from\n         * the current offset and from the number of bytes that will be inserted\n         * or removed between the source and target instructions). For each such\n         * instruction, adds an entry in (a copy of) the indexes and sizes\n         * arrays (if this has not already been done in a previous iteration!).\n         * \n         * If at least one entry has been added during the previous step, go\n         * back to the beginning, otherwise stop.\n         * \n         * In fact the real algorithm is complicated by the fact that the size\n         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their\n         * position in the bytecode (because of padding). In order to ensure the\n         * convergence of the algorithm, the number of bytes to be added or\n         * removed from these instructions is over estimated during the previous\n         * loop, and computed exactly only after the loop is finished (this\n         * requires another pass to parse the bytecode of the method).\n         */\n        int[] allIndexes = new int[0]; // copy of indexes\n        int[] allSizes = new int[0]; // copy of sizes\n        boolean[] resize; // instructions to be resized\n        int newOffset; // future offset of a jump instruction\n        resize = new boolean[code.length];\n        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done\n        int state = 3;\n        do {\n            if (state == 3) {\n                state = 2;\n            }\n            u = 0;\n            while (u < b.length) {\n                int opcode = b[u] & 0xFF; // opcode of current instruction\n                int insert = 0; // bytes to be added after this instruction\n                switch (ClassWriter.TYPE[opcode]) {\n                case ClassWriter.NOARG_INSN:\n                case ClassWriter.IMPLVAR_INSN:\n                    u += 1;\n                    break;\n                case ClassWriter.LABEL_INSN:\n                    if (opcode > 201) {\n                        // converts temporary opcodes 202 to 217, 218 and\n                        // 219 to IFEQ ... JSR (inclusive), IFNULL and\n                        // IFNONNULL\n                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                        label = u + readUnsignedShort(b, u + 1);\n                    } else {\n                        label = u + readShort(b, u + 1);\n                    }\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    if (newOffset < Short.MIN_VALUE\n                            || newOffset > Short.MAX_VALUE) {\n                        if (!resize[u]) {\n                            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                                // two additional bytes will be required to\n                                // replace this GOTO or JSR instruction with\n                                // a GOTO_W or a JSR_W\n                                insert = 2;\n                            } else {\n                                // five additional bytes will be required to\n                                // replace this IFxxx <l> instruction with\n                                // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx\n                                // is the \"opposite\" opcode of IFxxx (i.e.,\n                                // IFNE for IFEQ) and where <l'> designates\n                                // the instruction just after the GOTO_W.\n                                insert = 5;\n                            }\n                            resize[u] = true;\n                        }\n                    }\n                    u += 3;\n                    break;\n                case ClassWriter.LABELW_INSN:\n                    u += 5;\n                    break;\n                case ClassWriter.TABL_INSN:\n                    if (state == 1) {\n                        // true number of bytes to be added (or removed)\n                        // from this instruction = (future number of padding\n                        // bytes - current number of padding byte) -\n                        // previously over estimated variation =\n                        // = ((3 - newOffset%4) - (3 - u%4)) - u%4\n                        // = (-newOffset%4 + u%4) - u%4\n                        // = -(newOffset & 3)\n                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                        insert = -(newOffset & 3);\n                    } else if (!resize[u]) {\n                        // over estimation of the number of bytes to be\n                        // added to this instruction = 3 - current number\n                        // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3\n                        insert = u & 3;\n                        resize[u] = true;\n                    }\n                    // skips instruction\n                    u = u + 4 - (u & 3);\n                    u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;\n                    break;\n                case ClassWriter.LOOK_INSN:\n                    if (state == 1) {\n                        // like TABL_INSN\n                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                        insert = -(newOffset & 3);\n                    } else if (!resize[u]) {\n                        // like TABL_INSN\n                        insert = u & 3;\n                        resize[u] = true;\n                    }\n                    // skips instruction\n                    u = u + 4 - (u & 3);\n                    u += 8 * readInt(b, u + 4) + 8;\n                    break;\n                case ClassWriter.WIDE_INSN:\n                    opcode = b[u + 1] & 0xFF;\n                    if (opcode == Opcodes.IINC) {\n                        u += 6;\n                    } else {\n                        u += 4;\n                    }\n                    break;\n                case ClassWriter.VAR_INSN:\n                case ClassWriter.SBYTE_INSN:\n                case ClassWriter.LDC_INSN:\n                    u += 2;\n                    break;\n                case ClassWriter.SHORT_INSN:\n                case ClassWriter.LDCW_INSN:\n                case ClassWriter.FIELDORMETH_INSN:\n                case ClassWriter.TYPE_INSN:\n                case ClassWriter.IINC_INSN:\n                    u += 3;\n                    break;\n                case ClassWriter.ITFMETH_INSN:\n                case ClassWriter.INDYMETH_INSN:\n                    u += 5;\n                    break;\n                // case ClassWriter.MANA_INSN:\n                default:\n                    u += 4;\n                    break;\n                }\n                if (insert != 0) {\n                    // adds a new (u, insert) entry in the allIndexes and\n                    // allSizes arrays\n                    int[] newIndexes = new int[allIndexes.length + 1];\n                    int[] newSizes = new int[allSizes.length + 1];\n                    System.arraycopy(allIndexes, 0, newIndexes, 0,\n                            allIndexes.length);\n                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);\n                    newIndexes[allIndexes.length] = u;\n                    newSizes[allSizes.length] = insert;\n                    allIndexes = newIndexes;\n                    allSizes = newSizes;\n                    if (insert > 0) {\n                        state = 3;\n                    }\n                }\n            }\n            if (state < 3) {\n                --state;\n            }\n        } while (state != 0);\n        // 2nd step:\n        // copies the bytecode of the method into a new bytevector, updates the\n        // offsets, and inserts (or removes) bytes as requested.\n        ByteVector newCode = new ByteVector(code.length);\n        u = 0;\n        while (u < code.length) {\n            int opcode = b[u] & 0xFF;\n            switch (ClassWriter.TYPE[opcode]) {\n            case ClassWriter.NOARG_INSN:\n            case ClassWriter.IMPLVAR_INSN:\n                newCode.putByte(opcode);\n                u += 1;\n                break;\n            case ClassWriter.LABEL_INSN:\n                if (opcode > 201) {\n                    // changes temporary opcodes 202 to 217 (inclusive), 218\n                    // and 219 to IFEQ ... JSR (inclusive), IFNULL and\n                    // IFNONNULL\n                    opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                    label = u + readUnsignedShort(b, u + 1);\n                } else {\n                    label = u + readShort(b, u + 1);\n                }\n                newOffset = getNewOffset(allIndexes, allSizes, u, label);<fim_middle>// function below is long method\n"}