{"text": "<fim_prefix>        kvsClient = new StreamOps(Regions.US_WEST_2, kvsStreamName, credentialsProvider);\n        h264FrameProcessor = H264FrameProcessor.create(credentialsProvider, outputKvsStreamName);\n        fragmentCheckpointManager = new DDBBasedFragmentCheckpointManager(kvsClient.getRegion(), credentialsProvider);\n    }\n    /**\n     * Process Rekognized outputs for each rekognized output. For each kinesis event record i.e for each\n     * fragment number create a call getMediaForFragmentList, parse fragments, decode frame, draw bounding box,\n     * encode frame, call KVS PutFrame.\n     *\n     * @throws InterruptedException\n     */\n    private void processRekognizedOutputs() throws InterruptedException {\n        // Get the last processed fragment number if any\n        final Optional<FragmentCheckpoint> lastFragmentNumber = fragmentCheckpointManager\n                .getLastProcessedItem(inputKvsStreamName);\n        String fragmentNumber = null;\n        while (!rekognizedFragmentsIndex.isEmpty()) {\n            final RekognizedFragmentsIndex.RekognizedFragment rekognizedFragment = rekognizedFragmentsIndex.poll();\n            fragmentNumber = rekognizedFragment.getFragmentNumber();\n            final List<RekognizedOutput> rekognizedOutputList = rekognizedFragment.getRekognizedOutputs();\n            if (lastFragmentNumber.isPresent()\n                    && (fragmentNumber.equals(lastFragmentNumber.get().getFragmentNumber())\n                    || rekognizedFragment.getServerTime() <= lastFragmentNumber.get().getServerTime())) {\n                // If the current fragment number is equal to the last processed fragment number or if the current\n                // fragment's server time is older than or equal than last processed fragment's server time then\n                // skip this fragment number and proceed to next fragment.\n                log.info(\"Current fragment number : {} is already processed or older than last processed fragment. \"\n                        + \"So skipping..\", fragmentNumber);\n                continue;\n            }\n            try {\n                final FrameVisitor frameVisitor = FrameVisitor.create(h264FrameProcessor);\n                final GetMediaForFragmentListWorker worker = GetMediaForFragmentListWorker.create(\n                        kvsClient.getStreamName(),\n                        fragmentNumber,\n                        kvsClient.getCredentialsProvider(),\n                        kvsClient.getRegion(),\n                        kvsClient.getAmazonKinesisVideo(),\n                        frameVisitor);\n                h264FrameProcessor.setRekognizedOutputs(rekognizedOutputList);\n                worker.run();\n                // For every fragment, the rekognition output needs to be set and the encoder needs to be reset\n                // as the JCodec encoder always treats first frame as IDR fram\n                h264FrameProcessor.resetEncoder();\n                log.info(\"Fragment {}  processed successfully ...\", fragmentNumber);\n                // Once the current fragment number is processed save it as a heckpoint.\n                fragmentCheckpointManager.saveCheckPoint(inputKvsStreamName, fragmentNumber,\n                        rekognizedFragment.getProducerTime(), rekognizedFragment.getServerTime());\n            } catch (final Exception e) {\n                log.error(\"Error while processing fragment number: {}\", fragmentNumber, e);\n            }\n        }\n    }\n    /**\n     * Start Kinesis Data Streams worker.\n     */\n    public void startKDSWorker(final String kdsStreamName) {\n        final KinesisDataStreamsWorker kinesisDataStreamsWorker = KinesisDataStreamsWorker.create(Regions.US_WEST_2,\n                credentialsProvider, kdsStreamName, rekognizedFragmentsIndex);\n        kdsWorkers.submit(kinesisDataStreamsWorker);\n    }\n    /**\n     * Handle request for each lambda event.\n     *\n     * @param kinesisEvent Each kinesis event which describes the Rekognition output.\n     * @param context      Lambda context\n     * @return context\n     */\n    @Override\n    public Context handleRequest(final KinesisEvent kinesisEvent, final Context context) {\n        try {\n            log.info(\"Handling request !\");\n            initialize(System.getProperty(\"KVSStreamName\"));\n            log.info(\"Input KVS Stream name : {}\", inputKvsStreamName);\n            log.info(\"Output KVS Stream name : {}\", inputKvsStreamName);\n            log.info(\"Context : {}\", context);\n            loadProducerJNI(context);\n            final List<Record> records = kinesisEvent.getRecords()\n                    .stream()\n                    .map(KinesisEvent.KinesisEventRecord::getKinesis)\n                    .collect(Collectors.toList());\n            processRecordsWithRetries(records);\n            processRekognizedOutputs();\n        } catch (final Exception e) {\n            log.error(\"Unable to process lambda request !. Exiting... \", e);\n        }\n        return context;\n    }\n    /**\n     * Load pre-built binary of Kinesis Video Streams Producer JNI.\n     *\n     * @param context\n     */\n    private void loadProducerJNI(final Context context) throws IOException {\n        log.info(\"Context : {}\", context);\n        log.info(\"Working Directory = {}\", System.getProperty(\"user.dir\"));\n        log.info(\"Java library path = {}\", System.getProperty(\"java.library.path\"));\n        log.info(\"Class path %s\", this.getClass().getProtectionDomain().getCodeSource().getLocation());\n        log.info(\"Loading JNI .so file..\");\n        final ClassLoader classLoader = getClass().getClassLoader();\n        final File cityFile = new File(classLoader.getResource(\"libKinesisVideoProducerJNI.so\").getFile());\n        System.load(cityFile.getAbsolutePath());\n        log.info(\"Loaded JNI from {}\", cityFile.getAbsolutePath());\n    }\n    /**\n     * Process records performing retries as needed. Skip \"poison pill\" records.\n     *\n     * @param records Data records to be processed.\n     */\n    private void processRecordsWithRetries(final List<Record> records) {\n        for (final Record record : records) {\n            boolean processedSuccessfully = false;\n            for (int i = 0; i < NUM_RETRIES; i++) {\n                try {\n                    log.info(\"Processing single record...\");\n                    processSingleRecord(record);\n                    processedSuccessfully = true;\n                    break;\n                } catch (final Throwable t) {\n                    log.error(\"Caught throwable while processing record {}\", record, t);\n                }\n            }\n            if (!processedSuccessfully) {\n                log.warn(\"Couldn't processRekognizedOutputs record {}. Skipping the record.\", record);\n            }\n        }\n        log.info(\"Processing all {} KDS records.\", records.size());\n    }\n    /**\n     * Process a single record.\n     *\n     * @param record The record to be processed.\n     */\n<fim_suffix>    private void processSingleRecord(final Record record) {\n        String data = null;\n        final ObjectMapper mapper = new ObjectMapper();\n        try {\n            final ByteBuffer buffer = record.getData();\n            data = new String(buffer.array(), \"UTF-8\");\n            final RekognitionOutput output = mapper.readValue(data, RekognitionOutput.class);\n            // Get the fragment number from Rekognition Output\n            final String fragmentNumber = output\n                    .getInputInformation()\n                    .getKinesisVideo()\n                    .getFragmentNumber();\n            final Double frameOffsetInSeconds = output\n                    .getInputInformation()\n                    .getKinesisVideo()\n                    .getFrameOffsetInSeconds();\n            final Double serverTimestamp = output\n                    .getInputInformation()\n                    .getKinesisVideo()\n                    .getServerTimestamp();\n            final Double producerTimestamp = output\n                    .getInputInformation()\n                    .getKinesisVideo()\n                    .getProducerTimestamp();\n            final double detectedTime = output.getInputInformation().getKinesisVideo().getServerTimestamp()\n                    + output.getInputInformation().getKinesisVideo().getFrameOffsetInSeconds() * 1000L;\n            final RekognizedOutput rekognizedOutput = RekognizedOutput.builder()\n                    .fragmentNumber(fragmentNumber)\n                    .serverTimestamp(serverTimestamp)\n                    .producerTimestamp(producerTimestamp)\n                    .frameOffsetInSeconds(frameOffsetInSeconds)\n                    .detectedTime(detectedTime)\n                    .build();\n            // Add face search response\n            final List<FaceSearchResponse> responses = output.getFaceSearchResponse();\n            responses.forEach(response -> {\n                final DetectedFace detectedFace = response.getDetectedFace();\n                final List<MatchedFace> matchedFaces = response.getMatchedFaces();\n                final RekognizedOutput.FaceSearchOutput faceSearchOutput = RekognizedOutput.FaceSearchOutput.builder()\n                        .detectedFace(detectedFace)\n                        .matchedFaceList(matchedFaces)\n                        .build();\n                rekognizedOutput.addFaceSearchOutput(faceSearchOutput);\n            });\n            // Add it to the index\n            log.info(\"Found Rekognized results for fragment number : {}\", fragmentNumber);\n            rekognizedFragmentsIndex.add(fragmentNumber, producerTimestamp.longValue(),\n                    serverTimestamp.longValue(), rekognizedOutput);\n        } catch (final NumberFormatException e) {\n            log.warn(\"Record does not match sample record format. Ignoring record with data : {}\", data, e);\n        } catch (final Exception e) {\n            log.error(\"Unable to process record !\", e);\n        }\n    }<fim_middle>// function below is feature envy and long method\n"}