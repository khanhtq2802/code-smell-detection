{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\n\n\npackage org.eclipse.jetty.server.session;\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.eclipse.jetty.server.SessionIdManager;\nimport org.eclipse.jetty.util.annotation.ManagedAttribute;\nimport org.eclipse.jetty.util.annotation.ManagedObject;\nimport org.eclipse.jetty.util.component.AbstractLifeCycle;\nimport org.eclipse.jetty.util.log.Log;\nimport org.eclipse.jetty.util.log.Logger;\nimport org.eclipse.jetty.util.thread.ScheduledExecutorScheduler;\nimport org.eclipse.jetty.util.thread.Scheduler;\n\n/**\n * HouseKeeper\n *\n * There is 1 session HouseKeeper per SessionIdManager instance.\n *\n */\n@ManagedObject\npublic class HouseKeeper extends AbstractLifeCycle\n{\n    private  final static Logger LOG = Log.getLogger(\"org.eclipse.jetty.server.session\");\n    \n    public static final long DEFAULT_PERIOD_MS = 1000L * 60 * 10;\n    protected SessionIdManager _sessionIdManager;\n    protected Scheduler _scheduler;\n    protected Scheduler.Task _task; //scavenge task\n    protected Runner _runner;\n    protected boolean _ownScheduler = false;\n    private long _intervalMs =  DEFAULT_PERIOD_MS;\n   \n   \n    \n   \n    \n    /**\n     * Runner\n     *\n     */\n    protected class Runner implements Runnable\n    {\n\n        @Override\n        public void run()\n        {\n           try\n           {\n               scavenge();\n           }\n           finally\n           {\n               if (_scheduler != null && _scheduler.isRunning())\n                   _task = _scheduler.schedule(this, _intervalMs, TimeUnit.MILLISECONDS);\n           }\n        }\n    }\n    \n    \n    \n    \n    /**\n     * SessionIdManager associated with this scavenger\n     * @param sessionIdManager the session id manager\n     */\n    public void setSessionIdManager (SessionIdManager sessionIdManager)\n    {\n        _sessionIdManager = sessionIdManager;\n    }\n    \n    \n    /** \n     * @see org.eclipse.jetty.util.component.AbstractLifeCycle#doStart()\n     */\n    @Override\n    protected void doStart() throws Exception\n    {\n        if (_sessionIdManager == null)\n            throw new IllegalStateException (\"No SessionIdManager for Housekeeper\");\n        \n        setIntervalSec(getIntervalSec());\n        \n        super.doStart();\n    }\n\n    \n    /**\n     * Get a scheduler. First try a common scheduler, failing that\n     * create our own.\n     * \n     * @throws Exception when the scheduler cannot be started\n     */\n<fim_suffix>    protected void findScheduler() throws Exception\n    {\n        if (_scheduler == null)\n        {\n            if (_sessionIdManager instanceof DefaultSessionIdManager)\n            {\n                //try and use a common scheduler, fallback to own\n                _scheduler = ((DefaultSessionIdManager)_sessionIdManager).getServer().getBean(Scheduler.class);\n            }\n\n            if (_scheduler == null)\n            {\n                _scheduler = new ScheduledExecutorScheduler(String.format(\"Session-HouseKeeper-%x\",hashCode()),false);\n                _ownScheduler = true;\n                _scheduler.start();\n                if (LOG.isDebugEnabled()) LOG.debug(\"Using own scheduler for scavenging\");\n            }\n            else if (!_scheduler.isStarted())\n                throw new IllegalStateException(\"Shared scheduler not started\");\n        }\n    }\n    \n    /**\n     * If scavenging is not scheduled, schedule it.\n     * @throws Exception if any error during scheduling the scavenging\n     */\n    protected void startScavenging() throws Exception\n    {\n        synchronized (this)\n        {\n            if (_scheduler != null)\n            {\n                //cancel any previous task\n                if (_task!=null)\n                    _task.cancel();\n                if (_runner == null)\n                    _runner = new Runner();\n                LOG.info(\"{} Scavenging every {}ms\", _sessionIdManager.getWorkerName(), _intervalMs);\n                _task = _scheduler.schedule(_runner,_intervalMs,TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n\n    /**\n     * If scavenging is scheduled, stop it.\n     * \n     * @throws Exception if any error during stopping the scavenging\n     */\n    protected void stopScavenging() throws Exception\n    {\n        synchronized (this)\n        {   \n            if (_task!=null)\n            {\n                _task.cancel();\n                LOG.info(\"{} Stopped scavenging\", _sessionIdManager.getWorkerName());\n            }\n            _task = null;\n            if (_ownScheduler) \n            {\n                _scheduler.stop();\n                _scheduler = null;\n            }\n        }\n        _runner = null;\n    }\n\n\n    /** \n     * @see org.eclipse.jetty.util.component.AbstractLifeCycle#doStop()\n     */\n    @Override\n    protected void doStop() throws Exception\n    {\n        synchronized(this)\n        {\n            stopScavenging();\n            _scheduler = null;\n        }\n        super.doStop();\n    }\n    \n    \n    /**\n     * Set the period between scavenge cycles\n     * @param sec the interval (in seconds)\n     * @throws Exception if any error during restarting the scavenging\n     */\n    public void setIntervalSec(long sec) throws Exception\n    {\n        if (isStarted() || isStarting())\n        {\n            if (sec <= 0)\n            {\n                _intervalMs = 0L;\n                LOG.info(\"{} Scavenging disabled\", _sessionIdManager.getWorkerName());\n                stopScavenging();\n            }\n            else\n            {\n                if (sec < 10)\n                    LOG.warn(\"{} Short interval of {}sec for session scavenging.\", _sessionIdManager.getWorkerName(), sec);\n                \n                _intervalMs=sec*1000L;\n\n                //add a bit of variability into the scavenge time so that not all\n                //nodes with the same scavenge interval sync up\n                long tenPercent = _intervalMs/10;\n                if ((System.currentTimeMillis()%2) == 0)\n                    _intervalMs += tenPercent;\n                \n                if (isStarting() || isStarted())\n                {\n                    findScheduler();\n                    startScavenging();\n                }\n            }\n        }\n        else\n        {\n            _intervalMs=sec*1000L;\n        }\n\n    }\n\n    \n    \n    /**\n     * Get the period between scavenge cycles.\n     * \n     * @return the interval (in seconds)\n     */\n    @ManagedAttribute(value=\"secs between scavenge cycles\", readonly=true)   \n    public long getIntervalSec ()\n    {\n        return _intervalMs/1000;\n    }\n    \n    \n  \n    \n    \n    /**\n     * Periodically do session housekeeping\n     */\n    public void scavenge ()\n    {\n        //don't attempt to scavenge if we are shutting down\n        if (isStopping() || isStopped())\n            return;\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"{} scavenging sessions\", _sessionIdManager.getWorkerName());\n        \n        //find the session managers\n        for (SessionHandler manager:_sessionIdManager.getSessionHandlers())\n        {\n            if (manager != null)\n            {\n                try\n                {\n                    manager.scavenge();\n                }\n                catch (Exception e)\n                {\n                    LOG.warn(e);\n                }\n            }\n        }\n    }\n\n\n    /** \n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString()\n    {\n        return super.toString()+\"[interval=\"+_intervalMs+\", ownscheduler=\"+_ownScheduler+\"]\";\n    }\n\n}<fim_middle>// function below has no smell\n"}