{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution and is available at\n * http://eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n * initial implementation              Alexandre Vasseur\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.ReferenceType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.patterns.PerClause;\n/**\n * Adds aspectOf(), hasAspect() etc to the annotation defined aspects\n * \n * @author Alexandre Vasseur\n * @author Andy Clement\n */\npublic class BcelPerClauseAspectAdder extends BcelTypeMunger {\n\tprivate final PerClause.Kind kind;\n\tprivate boolean hasGeneratedInner = false;\n\tpublic BcelPerClauseAspectAdder(ResolvedType aspect, PerClause.Kind kind) {\n\t\tsuper(null, aspect);\n\t\tthis.kind = kind;\n\t\tif (kind == PerClause.SINGLETON || kind == PerClause.PERTYPEWITHIN || kind == PerClause.PERCFLOW) {\n\t\t\t// no inner needed\n\t\t\thasGeneratedInner = true;\n\t\t}\n\t}\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tdoAggressiveInner(gen);\n\t\t// Only munge the aspect type\n\t\tif (!gen.getType().equals(aspectType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn doMunge(gen, true);\n\t}\n\tpublic boolean forceMunge(LazyClassGen gen, boolean checkAlreadyThere) {\n\t\tdoAggressiveInner(gen);\n\t\treturn doMunge(gen, checkAlreadyThere);\n\t}\n<fim_suffix>\tprivate void doAggressiveInner(LazyClassGen gen) {\n\t\t// agressively generate the inner interface if any\n\t\t// Note: we do so because of the bug #75442 that leads to have this interface implemented by all classes and not\n\t\t// only those matched by the per clause, which fails under LTW since the very first class\n\t\t// gets weaved and impl this interface that is still not defined.\n\t\tif (!hasGeneratedInner) {\n\t\t\tif (kind == PerClause.PEROBJECT) {// redundant test - see constructor, but safer\n\t\t\t\t// inner class\n\t\t\t\tUnresolvedType interfaceTypeX = AjcMemberMaker.perObjectInterfaceType(aspectType);\n\t\t\t\tLazyClassGen interfaceGen = new LazyClassGen(interfaceTypeX.getName(), \"java.lang.Object\", null,\n\t\t\t\t\t\tConstants.ACC_INTERFACE + Constants.ACC_PUBLIC + Constants.ACC_ABSTRACT, new String[0], getWorld());\n\t\t\t\tinterfaceGen.addMethodGen(makeMethodGen(interfaceGen, AjcMemberMaker.perObjectInterfaceGet(aspectType)));\n\t\t\t\tinterfaceGen.addMethodGen(makeMethodGen(interfaceGen, AjcMemberMaker.perObjectInterfaceSet(aspectType)));\n\t\t\t\t// not really an inner class of it but that does not matter, we pass back to the LTW\n\t\t\t\tgen.addGeneratedInner(interfaceGen);\n\t\t\t}\n\t\t\thasGeneratedInner = true;\n\t\t}\n\t}\n\tprivate boolean doMunge(LazyClassGen gen, boolean checkAlreadyThere) {\n\t\tif (checkAlreadyThere && hasPerClauseMembersAlready(gen)) {\n\t\t\treturn false;\n\t\t}\n\t\tgeneratePerClauseMembers(gen);\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\n\t\t} else if (kind == PerClause.PEROBJECT) {\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\n\t\t\tgeneratePerObjectBindMethod(gen);\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - pr144602\n\t\t\t// generatePerObjectGetSetMethods(gen);\n\t\t} else if (kind == PerClause.PERCFLOW) {\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\n\t\t\tgeneratePerCflowPushMethod(gen);\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\n\t\t\tgeneratePerTWAspectOfMethod(gen);\n\t\t\tgeneratePerTWHasAspectMethod(gen);\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\n\t\t} else {\n\t\t\tthrow new Error(\"should not happen - not such kind \" + kind.getName());\n\t\t}\n\t\treturn true;\n\t}\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\n\t\treturn null;\n\t}\n\tpublic ResolvedMember getSignature() {\n\t\treturn null;\n\t}\n\tpublic boolean matches(ResolvedType onType) {\n\t\t// cannot always do the right thing because may need to eagerly generate ajcMightHaveAspect interface for LTW (says Alex)\n\t\tif (hasGeneratedInner) { // pr237419 - not always going to generate the marker interface\n\t\t\treturn aspectType.equals(onType);\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\tprivate boolean hasPerClauseMembersAlready(LazyClassGen classGen) {\n\t\tResolvedMember[] methods = classGen.getBcelObjectType().getDeclaredMethods();\n\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\tResolvedMember method = methods[i];\n\t\t\tif (\"aspectOf\".equals(method.getName())) {\n\t\t\t\tif (\"()\".equals(method.getParameterSignature()) && (kind == PerClause.SINGLETON || kind == PerClause.PERCFLOW)) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\"(Ljava/lang/Object;)\".equals(method.getParameterSignature()) && kind == PerClause.PEROBJECT) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\"(Ljava/lang/Class;)\".equals(method.getParameterSignature()) && kind == PerClause.PERTYPEWITHIN) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void generatePerClauseMembers(LazyClassGen classGen) {\n\t\t// FIXME Alex handle when field already there - or handle it with / similar to isAnnotationDefinedAspect()\n\t\t// for that use aspectType and iterate on the fields.\n\t\t// FIXME Alex percflowX is not using this one but AJ code style does generate it so..\n\t\tResolvedMember failureFieldInfo = AjcMemberMaker.initFailureCauseField(aspectType);\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tclassGen.addField(makeFieldGen(classGen, failureFieldInfo), null);\n\t\t}\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tResolvedMember perSingletonFieldInfo = AjcMemberMaker.perSingletonField(aspectType);\n\t\t\tclassGen.addField(makeFieldGen(classGen, perSingletonFieldInfo), null);\n\t\t\t// pr144602 - don't need to do this, PerObjectInterface munger will do it\n\t\t\t// } else if (kind == PerClause.PEROBJECT) {\n\t\t\t// ResolvedMember perObjectFieldInfo = AjcMemberMaker.perObjectField(aspectType, aspectType);\n\t\t\t// classGen.addField(makeFieldGen(classGen, perObjectFieldInfo).(), null);<fim_middle>// function below has no smell\n"}