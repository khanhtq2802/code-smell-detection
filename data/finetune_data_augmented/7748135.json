{"text": "<fim_prefix>import org.apache.brooklyn.entity.group.DynamicFabricImpl;\nimport org.apache.brooklyn.entity.group.DynamicGroup;\nimport org.apache.brooklyn.util.collections.CollectionFunctionals;\nimport org.apache.brooklyn.util.collections.MutableMap;\nimport org.apache.brooklyn.util.collections.MutableSet;\nimport org.apache.brooklyn.util.time.Time;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.base.Function;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\n/**\n * Implementation of {@link CassandraDatacenter}.\n * <p>\n * Serveral subtleties to note:\n * - a node may take some time after it is running and serving JMX to actually be contactable on its thrift port\n *   (so we wait for thrift port to be contactable)\n * - sometimes new nodes take a while to peer, and/or take a while to get a consistent schema\n *   (each up to 1m; often very close to the 1m) \n */\npublic class CassandraFabricImpl extends DynamicFabricImpl implements CassandraFabric {\n    private static final Logger log = LoggerFactory.getLogger(CassandraFabricImpl.class);\n    // Mutex for synchronizing during re-size operations\n    private final Object mutex = new Object[0];\n    private final Supplier<Set<Entity>> defaultSeedSupplier = new Supplier<Set<Entity>>() {\n        @Override public Set<Entity> get() {\n            // TODO Remove duplication from CassandraClusterImpl.defaultSeedSupplier\n            Set<Entity> seeds = getAttribute(CURRENT_SEEDS);\n            boolean hasPublishedSeeds = Boolean.TRUE.equals(getAttribute(HAS_PUBLISHED_SEEDS));\n            int quorumSize = getSeedQuorumSize();\n            // update seeds if we're not quorate; note this may not work for dynamically adding new datacenters\n            // as we do not take a new seed from the new datacenter\n            if (seeds == null || seeds.size() < quorumSize || containsDownEntity(seeds)) {\n                Set<Entity> newseeds;\n                Map<CassandraDatacenter,Set<Entity>> potentialSeeds = MutableMap.of();\n                int potentialSeedCount = 0;\n                for (CassandraDatacenter member : Iterables.filter(getMembers(), CassandraDatacenter.class)) {\n                    Set<Entity> dcPotentialSeeds = member.gatherPotentialSeeds();\n                    potentialSeeds.put(member, dcPotentialSeeds);\n                    potentialSeedCount += dcPotentialSeeds.size();\n                }\n                if (hasPublishedSeeds) {\n                    Set<Entity> currentSeeds = getAttribute(CURRENT_SEEDS);\n                    Lifecycle serviceState = getAttribute(SERVICE_STATE_ACTUAL);\n                    if (serviceState == Lifecycle.STARTING) {\n                        if (Sets.intersection(currentSeeds, ImmutableSet.copyOf(Iterables.concat(potentialSeeds.values()))).isEmpty()) {\n                            log.warn(\"Fabric {} lost all its seeds while starting! Subsequent failure likely, but changing seeds during startup would risk split-brain: seeds={}\", new Object[] {CassandraFabricImpl.this, currentSeeds});\n                        }\n                        newseeds = currentSeeds;\n                    } else if (serviceState == Lifecycle.STOPPING || serviceState == Lifecycle.STOPPED) {\n                        if (log.isTraceEnabled()) log.trace(\"Fabric {} ignoring any potential seed-changes, because {}: seeds={}\", new Object[] {CassandraFabricImpl.this, serviceState, currentSeeds});\n                        newseeds = currentSeeds;\n                    } else if (potentialSeedCount == 0) {\n                        // TODO Could be race where nodes have only just returned from start() and are about to \n                        // transition to serviceUp; so don't just abandon all our seeds!\n                        log.warn(\"Fabric {} has no seeds (after startup); leaving seeds as-is; but risks split-brain if these seeds come back up!\", new Object[] {CassandraFabricImpl.this});\n                        newseeds = currentSeeds;\n                    } else if (!allNonEmpty(potentialSeeds.values())) {\n                        log.warn(\"Fabric {} has datacenter with no seeds (after startup); leaving seeds as-is; but risks split-brain if these seeds come back up!\", new Object[] {CassandraFabricImpl.this});\n                        newseeds = currentSeeds;\n                    } else {\n                        Set<Entity> result = selectSeeds(quorumSize, potentialSeeds);\n                        if (log.isDebugEnabled() && !Objects.equal(seeds, result)) {\n                            log.debug(\"Fabric {} updating seeds: chosen={}; potential={}\", new Object[] {CassandraFabricImpl.this, result, potentialSeeds});\n                        }\n                        newseeds = result;\n                    }\n                } else if (potentialSeedCount < quorumSize) {\n                    if (log.isDebugEnabled()) log.debug(\"Not setting seeds of fabric {} yet, because still waiting for quorum (need {}; have {} potentials from {} members)\", new Object[] {CassandraFabricImpl.this, quorumSize, potentialSeedCount, getMembers()});\n                    newseeds = ImmutableSet.of();\n                } else if (!allNonEmpty(potentialSeeds.values())) {\n                    if (log.isDebugEnabled()) {\n                        Map<CassandraDatacenter, Integer> datacenterCounts = Maps.transformValues(potentialSeeds, CollectionFunctionals.sizeFunction());\n                        log.debug(\"Not setting seeds of fabric {} yet, because not all datacenters have seeds (sizes are {})\", new Object[] {CassandraFabricImpl.this, datacenterCounts});\n                    }\n                    newseeds = ImmutableSet.of();\n                } else {\n                    // yay, we're quorate\n                    Set<Entity> result = selectSeeds(quorumSize, potentialSeeds);\n                    log.info(\"Fabric {} has reached seed quorum: seeds={}\", new Object[] {CassandraFabricImpl.this, result});\n                    newseeds = result;\n                }\n                if (!Objects.equal(seeds, newseeds)) {\n                    sensors().set(CURRENT_SEEDS, newseeds);\n                    if (newseeds != null && newseeds.size() > 0) {\n                        sensors().set(HAS_PUBLISHED_SEEDS, true);\n                        // Need to tell every datacenter that seeds are ready.\n                        // Otherwise a datacenter might get no more changes (e.g. to nodes' hostnames etc), \n                        // and not call seedSupplier.get() again.\n                        for (CassandraDatacenter member : Iterables.filter(getMembers(), CassandraDatacenter.class)) {\n                            member.update();\n                        }\n                    }\n                    return newseeds;\n                } else {\n                    return seeds;\n                }\n            } else {\n                if (log.isTraceEnabled()) log.trace(\"Not refresheed seeds of fabric {}, because have quorum {} (of {} members), and none are down: seeds={}\", \n                        new Object[] {CassandraFabricImpl.class, quorumSize, getMembers().size(), seeds});\n                return seeds;\n            }\n        }\n        private boolean allNonEmpty(Collection<? extends Collection<Entity>> contenders) {\n            for (Collection<Entity> contender: contenders)\n                if (contender.isEmpty()) return false;\n            return true;\n        }\n        private Set<Entity> selectSeeds(int num, Map<CassandraDatacenter,? extends Collection<Entity>> contenders) {\n            // Prefer existing seeds wherever possible;\n            // otherwise prefer a seed from each sub-cluster;\n            // otherwise accept any other contenders\n            Set<Entity> currentSeeds = (getAttribute(CURRENT_SEEDS) != null) ? getAttribute(CURRENT_SEEDS) : ImmutableSet.<Entity>of();\n            MutableSet<Entity> result = MutableSet.of();\n            result.addAll(Sets.intersection(currentSeeds, ImmutableSet.copyOf(contenders.values())));\n            for (CassandraDatacenter cluster : contenders.keySet()) {\n                Set<Entity> contendersInCluster = Sets.newLinkedHashSet(contenders.get(cluster));\n                if (contendersInCluster.size() > 0 && Sets.intersection(result, contendersInCluster).isEmpty()) {\n                    result.add(Iterables.getFirst(contendersInCluster, null));\n                }\n            }\n            result.addAll(Iterables.concat(contenders.values()));\n            return ImmutableSet.copyOf(Iterables.limit(result, num));\n        }\n<fim_suffix>        private boolean containsDownEntity(Set<Entity> seeds) {\n            for (Entity seed : seeds) {\n                if (!isViableSeed(seed)) {\n                    return true;\n                }\n            }\n            return false;\n        }<fim_middle>// function below has no smell\n"}