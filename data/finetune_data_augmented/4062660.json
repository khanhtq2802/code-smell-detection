{"text": "<fim_prefix>/**\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\npackage org.apache.bookkeeper.bookie;\n\nimport static org.apache.bookkeeper.bookie.EntryLogger.UNASSIGNED_LEDGERID;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.concurrent.FastThreadLocal;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.bookkeeper.bookie.EntryLogger.BufferedLogChannel;\nimport org.apache.bookkeeper.bookie.EntryLogger.EntryLogListener;\nimport org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\nimport org.apache.bookkeeper.conf.ServerConfiguration;\n\n<fim_suffix>@Slf4j\nabstract class EntryLogManagerBase implements EntryLogManager {\n    volatile List<BufferedLogChannel> rotatedLogChannels;\n    final EntryLoggerAllocator entryLoggerAllocator;\n    final LedgerDirsManager ledgerDirsManager;\n    private final List<EntryLogger.EntryLogListener> listeners;\n    /**\n     * The maximum size of a entry logger file.\n     */\n    final long logSizeLimit;\n\n    EntryLogManagerBase(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager,\n            EntryLoggerAllocator entryLoggerAllocator, List<EntryLogger.EntryLogListener> listeners) {\n        this.ledgerDirsManager = ledgerDirsManager;\n        this.entryLoggerAllocator = entryLoggerAllocator;\n        this.listeners = listeners;\n        this.logSizeLimit = conf.getEntryLogSizeLimit();\n    }\n\n    private final FastThreadLocal<ByteBuf> sizeBufferForAdd = new FastThreadLocal<ByteBuf>() {\n        @Override\n        protected ByteBuf initialValue() throws Exception {\n            return Unpooled.buffer(4);\n        }\n    };\n\n    /*\n     * This method should be guarded by a lock, so callers of this method\n     * should be in the right scope of the lock.\n     */\n    @Override\n    public long addEntry(long ledger, ByteBuf entry, boolean rollLog) throws IOException {\n        int entrySize = entry.readableBytes() + 4; // Adding 4 bytes to prepend the size\n        BufferedLogChannel logChannel = getCurrentLogForLedgerForAddEntry(ledger, entrySize, rollLog);\n        ByteBuf sizeBuffer = sizeBufferForAdd.get();\n        sizeBuffer.clear();\n        sizeBuffer.writeInt(entry.readableBytes());\n        logChannel.write(sizeBuffer);\n\n        long pos = logChannel.position();\n        logChannel.write(entry);\n        logChannel.registerWrittenEntry(ledger, entrySize);\n\n        return (logChannel.getLogId() << 32L) | pos;\n    }\n\n    boolean reachEntryLogLimit(BufferedLogChannel logChannel, long size) {\n        if (logChannel == null) {\n            return false;\n        }\n        return logChannel.position() + size > logSizeLimit;\n    }\n\n    boolean readEntryLogHardLimit(BufferedLogChannel logChannel, long size) {\n        if (logChannel == null) {\n            return false;\n        }\n        return logChannel.position() + size > Integer.MAX_VALUE;\n    }\n\n    abstract BufferedLogChannel getCurrentLogForLedger(long ledgerId) throws IOException;\n\n    abstract BufferedLogChannel getCurrentLogForLedgerForAddEntry(long ledgerId, int entrySize, boolean rollLog)\n            throws IOException;\n\n    abstract void setCurrentLogForLedgerAndAddToRotate(long ledgerId, BufferedLogChannel logChannel) throws IOException;\n\n    /*\n     * flush current logs.\n     */\n    abstract void flushCurrentLogs() throws IOException;\n\n    /*\n     * flush rotated logs.\n     */\n    abstract void flushRotatedLogs() throws IOException;\n\n    List<BufferedLogChannel> getRotatedLogChannels() {\n        return rotatedLogChannels;\n    }\n\n    @Override\n    public void flush() throws IOException {\n        flushCurrentLogs();\n        flushRotatedLogs();\n    }\n\n    void flushLogChannel(BufferedLogChannel logChannel, boolean forceMetadata) throws IOException {\n        if (logChannel != null) {\n            logChannel.flushAndForceWrite(forceMetadata);\n            log.debug(\"Flush and sync current entry logger {}\", logChannel.getLogId());\n        }\n    }\n\n    /*\n     * Creates a new log file. This method should be guarded by a lock,\n     * so callers of this method should be in right scope of the lock.\n     */\n    @VisibleForTesting\n    void createNewLog(long ledgerId) throws IOException {\n        createNewLog(ledgerId, \"\");\n    }\n\n    void createNewLog(long ledgerId, String reason) throws IOException {\n        if (ledgerId != UNASSIGNED_LEDGERID) {\n            log.info(\"Creating a new entry log file for ledger '{}' {}\", ledgerId, reason);\n        } else {\n            log.info(\"Creating a new entry log file {}\", reason);\n        }\n\n        BufferedLogChannel logChannel = getCurrentLogForLedger(ledgerId);\n        // first tried to create a new log channel. add current log channel to ToFlush list only when\n        // there is a new log channel. it would prevent that a log channel is referenced by both\n        // *logChannel* and *ToFlush* list.\n        if (null != logChannel) {\n\n            // flush the internal buffer back to filesystem but not sync disk\n            logChannel.flush();\n\n            // Append ledgers map at the end of entry log\n            logChannel.appendLedgersMap();\n\n            BufferedLogChannel newLogChannel = entryLoggerAllocator.createNewLog(selectDirForNextEntryLog());\n            setCurrentLogForLedgerAndAddToRotate(ledgerId, newLogChannel);\n            log.info(\"Flushing entry logger {} back to filesystem, pending for syncing entry loggers : {}.\",\n                    logChannel.getLogId(), rotatedLogChannels);\n            for (EntryLogListener listener : listeners) {\n                listener.onRotateEntryLog();\n            }\n        } else {\n            setCurrentLogForLedgerAndAddToRotate(ledgerId,\n                    entryLoggerAllocator.createNewLog(selectDirForNextEntryLog()));\n        }\n    }\n\n    File selectDirForNextEntryLog() throws NoWritableLedgerDirException {\n        return getDirForNextEntryLog(ledgerDirsManager.getWritableLedgerDirsForNewLog());\n    }\n}<fim_middle>// class below has no smell\n"}