{"text": "<fim_prefix> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.lir.amd64.vector;\nimport static jdk.vm.ci.code.ValueUtil.asRegister;\nimport static jdk.vm.ci.code.ValueUtil.isRegister;\nimport static jdk.vm.ci.code.ValueUtil.isStackSlot;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VEXTRACTF128;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VEXTRACTI128;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VPEXTRB;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VPEXTRD;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VPEXTRQ;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp.VPEXTRW;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp.VMOVD;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp.VMOVQ;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMIOp.VINSERTF128;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMIOp.VINSERTI128;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMIOp.VSHUFPD;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMIOp.VSHUFPS;\nimport static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VPSHUFB;\nimport static org.graalvm.compiler.asm.amd64.AVXKind.AVXSize.XMM;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;\nimport org.graalvm.compiler.asm.amd64.AMD64Address;\nimport org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMRIOp;\nimport org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;\nimport org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMIOp;\nimport org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;\nimport org.graalvm.compiler.asm.amd64.AVXKind;\nimport org.graalvm.compiler.debug.GraalError;\nimport org.graalvm.compiler.lir.LIRInstructionClass;\nimport org.graalvm.compiler.lir.amd64.AMD64LIRInstruction;\nimport org.graalvm.compiler.lir.asm.CompilationResultBuilder;\nimport jdk.vm.ci.amd64.AMD64;\nimport jdk.vm.ci.amd64.AMD64.CPUFeature;\nimport jdk.vm.ci.amd64.AMD64Kind;\nimport jdk.vm.ci.meta.AllocatableValue;\npublic class AMD64VectorShuffle {\n    public static final class IntToVectorOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<IntToVectorOp> TYPE = LIRInstructionClass.create(IntToVectorOp.class);\n        @Def({REG}) protected AllocatableValue result;\n        @Use({REG, STACK}) protected AllocatableValue value;\n        public IntToVectorOp(AllocatableValue result, AllocatableValue value) {\n            super(TYPE);\n            assert ((AMD64Kind) result.getPlatformKind()).getScalar().isInteger() : result.getPlatformKind();\n            this.result = result;\n            this.value = value;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            if (isRegister(value)) {\n                VMOVD.emit(masm, XMM, asRegister(result), asRegister(value));\n            } else {\n                assert isStackSlot(value);\n                VMOVD.emit(masm, XMM, asRegister(result), (AMD64Address) crb.asAddress(value));\n            }\n        }\n    }\n    public static final class LongToVectorOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<LongToVectorOp> TYPE = LIRInstructionClass.create(LongToVectorOp.class);\n        @Def({REG}) protected AllocatableValue result;\n        @Use({REG, STACK}) protected AllocatableValue value;\n        public LongToVectorOp(AllocatableValue result, AllocatableValue value) {\n            super(TYPE);\n            assert result.getPlatformKind() == AMD64Kind.V128_QWORD || result.getPlatformKind() == AMD64Kind.V256_QWORD;\n            this.result = result;\n            this.value = value;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            if (isRegister(value)) {\n                VMOVQ.emit(masm, XMM, asRegister(result), asRegister(value));\n            } else {\n                assert isStackSlot(value);\n                VMOVQ.emit(masm, XMM, asRegister(result), (AMD64Address) crb.asAddress(value));\n            }\n        }\n    }\n    public static final class ShuffleBytesOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<ShuffleBytesOp> TYPE = LIRInstructionClass.create(ShuffleBytesOp.class);\n        @Def({REG}) protected AllocatableValue result;\n        @Use({REG}) protected AllocatableValue source;\n        @Use({REG, STACK}) protected AllocatableValue selector;\n        public ShuffleBytesOp(AllocatableValue result, AllocatableValue source, AllocatableValue selector) {\n            super(TYPE);\n            this.result = result;\n            this.source = source;\n            this.selector = selector;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Kind kind = (AMD64Kind) result.getPlatformKind();\n            if (isRegister(selector)) {\n                VPSHUFB.emit(masm, AVXKind.getRegisterSize(kind), asRegister(result), asRegister(source), asRegister(selector));\n            } else {\n                assert isStackSlot(selector);\n                VPSHUFB.emit(masm, AVXKind.getRegisterSize(kind), asRegister(result), asRegister(source), (AMD64Address) crb.asAddress(selector));\n            }\n        }\n    }\n<fim_suffix>    public static final class ConstShuffleBytesOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<ConstShuffleBytesOp> TYPE = LIRInstructionClass.create(ConstShuffleBytesOp.class);\n        @Def({REG}) protected AllocatableValue result;\n        @Use({REG}) protected AllocatableValue source;\n        private final byte[] selector;\n        public ConstShuffleBytesOp(AllocatableValue result, AllocatableValue source, byte... selector) {\n            super(TYPE);\n            assert AVXKind.getRegisterSize(((AMD64Kind) result.getPlatformKind())).getBytes() == selector.length;\n            this.result = result;\n            this.source = source;\n            this.selector = selector;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Kind kind = (AMD64Kind) result.getPlatformKind();\n            AMD64Address address = (AMD64Address) crb.recordDataReferenceInCode(selector, selector.length);\n            VPSHUFB.emit(masm, AVXKind.getRegisterSize(kind), asRegister(result), asRegister(source), address);\n        }\n    }<fim_middle>// class below has no smell\n"}