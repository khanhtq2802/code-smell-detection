{"text": "<fim_prefix>      throws EppException {\n    if (hasSignedMarks && tldState != START_DATE_SUNRISE) {\n      throw new SignedMarksOnlyDuringSunriseException();\n    }\n  }\n  /**\n   * Verifies anchor tenant creates are only done for {@value ANCHOR_TENANT_CREATE_VALID_YEARS} year\n   * periods, as anchor tenants get exactly that many years of free registration.\n   */\n  static void verifyAnchorTenantValidPeriod(boolean isAnchorTenant, int registrationYears)\n      throws EppException {\n    if (isAnchorTenant && registrationYears != ANCHOR_TENANT_CREATE_VALID_YEARS) {\n      throw new AnchorTenantCreatePeriodException(registrationYears);\n    }\n  }\n  /**\n   * Prohibit registrations unless QLP, General Availability or Start Date Sunrise.\n   *\n   * <p>During Start-Date Sunrise, we need a signed mark for registrations.\n   *\n   * <p>Note that \"superuser\" status isn't tested here - this should only be called for\n   * non-superusers.\n   */\n  private void verifyIsGaOrIsSpecialCase(\n      TldState tldState, boolean isAnchorTenant, boolean hasSignedMarks)\n      throws NoGeneralRegistrationsInCurrentPhaseException,\n          MustHaveSignedMarksInCurrentPhaseException {\n    // Anchor Tenant overrides any other consideration to allow registration.\n    if (isAnchorTenant) {\n      return;\n    }\n    // We allow general registration during GA.\n    if (GENERAL_AVAILABILITY.equals(tldState)) {\n      return;\n    }\n    // During START_DATE_SUNRISE, only allow registration with signed marks.\n    if (START_DATE_SUNRISE.equals(tldState)) {\n      if (!hasSignedMarks) {\n        throw new MustHaveSignedMarksInCurrentPhaseException();\n      }\n      return;\n    }\n    // All other phases do not allow registration\n    throw new NoGeneralRegistrationsInCurrentPhaseException();\n  }\n  /** Verifies and returns the allocation token if one is specified, otherwise does nothing. */\n  private Optional<AllocationToken> verifyAllocationTokenIfPresent(\n      DomainCommand.Create command, Registry registry, String clientId, DateTime now)\n      throws EppException {\n    Optional<AllocationTokenExtension> extension =\n        eppInput.getSingleExtension(AllocationTokenExtension.class);\n    return Optional.ofNullable(\n        extension.isPresent()\n            ? allocationTokenFlowUtils.verifyToken(\n                command, extension.get().getAllocationToken(), registry, clientId, now)\n            : null);\n  }\n  private HistoryEntry buildHistoryEntry(\n      String repoId, Registry registry, DateTime now, Period period, Duration addGracePeriod) {\n    // We ignore prober transactions\n    if (registry.getTldType() == TldType.REAL) {\n      historyBuilder\n          .setDomainTransactionRecords(\n              ImmutableSet.of(\n                  DomainTransactionRecord.create(\n                      registry.getTldStr(),\n                      now.plus(addGracePeriod),\n                      TransactionReportField.netAddsFieldFromYears(period.getValue()),\n                      1)));\n    }\n    return historyBuilder\n        .setType(HistoryEntry.Type.DOMAIN_CREATE)\n        .setPeriod(period)\n        .setModificationTime(now)\n        .setParent(Key.create(DomainBase.class, repoId))\n        .build();\n  }\n  private BillingEvent.OneTime createOneTimeBillingEvent(\n      Registry registry,\n      boolean isAnchorTenant,\n      boolean isSunriseCreate,\n      boolean isReserved,\n      int years,\n      FeesAndCredits feesAndCredits,\n      HistoryEntry historyEntry,\n      DateTime now) {\n    ImmutableSet.Builder<Flag> flagsBuilder = new ImmutableSet.Builder<>();\n    // Sunrise and anchor tenancy are orthogonal tags and thus both can be present together.\n    if (isSunriseCreate) {\n      flagsBuilder.add(Flag.SUNRISE);\n    }\n    if (isAnchorTenant) {\n      flagsBuilder.add(Flag.ANCHOR_TENANT);\n    } else if (isReserved) {\n      // Don't add this flag if the domain is an anchor tenant (which are also reserved); only add\n      // it if it's reserved for other reasons.\n      flagsBuilder.add(Flag.RESERVED);\n    }\n    return new BillingEvent.OneTime.Builder()\n        .setReason(Reason.CREATE)\n        .setTargetId(targetId)\n        .setClientId(clientId)\n        .setPeriodYears(years)\n        .setCost(feesAndCredits.getCreateCost())\n        .setEventTime(now)\n        .setBillingTime(\n            now.plus(\n                isAnchorTenant\n                    ? registry.getAnchorTenantAddGracePeriodLength()\n                    : registry.getAddGracePeriodLength()))\n        .setFlags(flagsBuilder.build())\n        .setParent(historyEntry)\n        .build();\n  }\n  private Recurring createAutorenewBillingEvent(\n      HistoryEntry historyEntry, DateTime registrationExpirationTime) {\n    return new BillingEvent.Recurring.Builder()\n        .setReason(Reason.RENEW)\n        .setFlags(ImmutableSet.of(Flag.AUTO_RENEW))\n        .setTargetId(targetId)\n        .setClientId(clientId)\n        .setEventTime(registrationExpirationTime)\n        .setRecurrenceEndTime(END_OF_TIME)\n        .setParent(historyEntry)\n        .build();\n  }\n  private Autorenew createAutorenewPollMessage(\n      HistoryEntry historyEntry, DateTime registrationExpirationTime) {\n    return new PollMessage.Autorenew.Builder()\n        .setTargetId(targetId)\n        .setClientId(clientId)\n        .setEventTime(registrationExpirationTime)\n        .setMsg(\"Domain was auto-renewed.\")\n        .setParent(historyEntry)\n        .build();\n  }\n  private static BillingEvent.OneTime createEapBillingEvent(\n      FeesAndCredits feesAndCredits, BillingEvent.OneTime createBillingEvent) {\n    return new BillingEvent.OneTime.Builder()\n        .setReason(Reason.FEE_EARLY_ACCESS)\n        .setTargetId(createBillingEvent.getTargetId())\n        .setClientId(createBillingEvent.getClientId())\n        .setPeriodYears(1)\n        .setCost(feesAndCredits.getEapCost())\n        .setEventTime(createBillingEvent.getEventTime())\n        .setBillingTime(createBillingEvent.getBillingTime())\n        .setFlags(createBillingEvent.getFlags())\n        .setParent(createBillingEvent.getParentKey())\n        .build();\n  }\n  private static PollMessage.OneTime createNameCollisionOneTimePollMessage(\n      String fullyQualifiedDomainName, HistoryEntry historyEntry, String clientId, DateTime now) {\n    return new PollMessage.OneTime.Builder()\n        .setClientId(clientId)\n        .setEventTime(now)\n        .setMsg(COLLISION_MESSAGE) // Remind the registrar of the name collision policy.\n        .setResponseData(\n            ImmutableList.of(\n                DomainPendingActionNotificationResponse.create(\n                    fullyQualifiedDomainName, true, historyEntry.getTrid(), now)))\n        .setParent(historyEntry)\n        .build();\n  }\n  private void enqueueTasks(\n      DomainBase newDomain, boolean hasSignedMarks, boolean hasClaimsNotice) {\n    if (newDomain.shouldPublishToDns()) {\n      dnsQueue.addDomainRefreshTask(newDomain.getFullyQualifiedDomainName());\n    }\n    if (hasClaimsNotice || hasSignedMarks) {\n      LordnTaskUtils.enqueueDomainBaseTask(newDomain);\n    }\n  }\n  private static ImmutableList<FeeTransformResponseExtension> createResponseExtensions(\n      Optional<FeeCreateCommandExtension> feeCreate, FeesAndCredits feesAndCredits) {\n    return feeCreate.isPresent()\n        ? ImmutableList.of(createFeeCreateResponse(feeCreate.get(), feesAndCredits))\n        : ImmutableList.of();\n  }\n  /** Signed marks are only allowed during sunrise. */\n  static class SignedMarksOnlyDuringSunriseException extends CommandUseErrorException {\n    public SignedMarksOnlyDuringSunriseException() {\n      super(\"Signed marks are only allowed during sunrise\");\n    }\n  }\n  /** The current registry phase does not allow for general registrations. */\n  static class NoGeneralRegistrationsInCurrentPhaseException extends CommandUseErrorException {\n    public NoGeneralRegistrationsInCurrentPhaseException() {\n      super(\"The current registry phase does not allow for general registrations\");\n    }\n  }\n  /** The current registry phase allows registrations only with signed marks. */\n<fim_suffix>  static class MustHaveSignedMarksInCurrentPhaseException extends CommandUseErrorException {\n    public MustHaveSignedMarksInCurrentPhaseException() {\n      super(\"The current registry phase requires a signed mark for registrations\");\n    }\n  }<fim_middle>// class below has no smell\n"}