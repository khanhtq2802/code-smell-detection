{"text": "<fim_prefix>        }\n        return true;\n    }\n    void removeDeliveringMessageNumber(long mn) {\n        synchronized (deliveringMessageNumbers) {\n            deliveringMessageNumbers.remove(mn);\n        }\n    }\n    void addDeliveringMessageNumber(long mn) {\n        synchronized (deliveringMessageNumbers) {\n            deliveringMessageNumbers.add(mn);\n        }\n    }\n    // this method is only used for redelivery\n    boolean allAcknowledgedMessagesDelivered() {\n        return deliveringMessageNumbers.isEmpty();\n    }\n    private Continuation getContinuation(Message message) {\n        if (message == null) {\n            return null;\n        }\n        return message.get(Continuation.class);\n    }\n    synchronized boolean waitInQueue(long mn, boolean canSkip,\n                                     Message message, Continuation continuation) {\n        while (true) {\n            // can process now if no other in process and this one is next\n            if (inProcessNumber == 0) {\n                long diff = mn - highNumberCompleted;\n                if (diff == 1 || (canSkip && diff > 0)) {\n                    inProcessNumber = mn;\n                    return true;\n                }\n            }\n            // can abort now if same message in process or already processed\n            if (mn == inProcessNumber || isAcknowledged(mn)) {\n                return false;\n            }\n            if (continuation == null) {\n                ContinuationProvider p = message.get(ContinuationProvider.class);\n                if (p != null) {\n                    boolean isOneWay = message.getExchange().isOneWay();\n                    message.getExchange().setOneWay(false);\n                    continuation = p.getContinuation();\n                    message.getExchange().setOneWay(isOneWay);\n                    message.put(Continuation.class, continuation);\n                }\n            }\n            if (continuation != null) {\n                continuation.setObject(message);\n                if (continuation.suspend(-1)) {\n                    continuations.put(mn, continuation);\n                    throw new SuspendedInvocationException();\n                }\n            }\n            try {\n                //if we get here, there isn't a continuation available\n                //so we need to block/wait\n                wait();\n            } catch (InterruptedException ie) {\n                // ignore\n            }\n        }\n    }\n    synchronized void wakeupNext(long i) {\n        try {\n            Continuation c = continuations.remove(i + 1);\n            if (c != null) {\n                //next was found, don't resume everything, just the next one\n                c.resume();\n                return;\n            }\n            //next wasn't found, nothing to resume, assume it will come in later...\n        } finally {\n            notifyAll();\n        }\n    }\n    synchronized void processingComplete(long mn) {\n        inProcessNumber = 0;\n        highNumberCompleted = mn;\n        wakeupNext(mn);\n    }\n    void purgeAcknowledged(long messageNr) {\n        RMStore store = destination.getManager().getStore();\n        if (null == store) {\n            return;\n        }\n        store.removeMessages(getIdentifier(), Collections.singleton(messageNr), false);\n    }\n    /**\n     * Called after an acknowledgement header for this sequence has been added to an outgoing message.\n     */\n    void acknowledgmentSent() {\n        acknowledgeOnNextOccasion = false;\n    }\n    public boolean sendAcknowledgement() {\n        return acknowledgeOnNextOccasion;\n    }\n    List<DeferredAcknowledgment> getDeferredAcknowledgements() {\n        return deferredAcknowledgments;\n    }\n    /**\n     * The correlation of the incoming CreateSequence call used to create this\n     * sequence is recorded so that in the absence of an offer, the corresponding\n     * outgoing CreateSeqeunce can be correlated.\n     */\n    void setCorrelationID(String cid) {\n        correlationID = cid;\n    }\n    String getCorrelationID() {\n        return correlationID;\n    }\n    void scheduleAcknowledgement(long acknowledgementInterval) {\n        AcksPolicyType ap = destination.getManager().getDestinationPolicy().getAcksPolicy();\n        if (acknowledgementInterval > 0 && getMonitor().getMPM() >= (ap == null ? 10 : ap.getIntraMessageThreshold())) {\n            LOG.fine(\"Schedule deferred acknowledgment\");\n            scheduleDeferredAcknowledgement(acknowledgementInterval);\n        } else {\n            LOG.fine(\"Schedule immediate acknowledgment\");\n            scheduleImmediateAcknowledgement();\n            destination.getManager().getTimer().schedule(\n                new ImmediateFallbackAcknowledgment(), ap == null ? 1000L : ap.getImmediaAcksTimeout());\n        }\n    }\n    void scheduleImmediateAcknowledgement() {\n        acknowledgeOnNextOccasion = true;\n    }\n    synchronized void scheduleSequenceTermination(long inactivityTimeout) {\n        if (inactivityTimeout <= 0) {\n            return;\n        }\n        boolean scheduled = null != scheduledTermination;\n        if (null == scheduledTermination) {\n            scheduledTermination = new SequenceTermination();\n        }\n        scheduledTermination.updateInactivityTimeout(inactivityTimeout);\n        if (!scheduled) {\n            destination.getManager().getTimer().schedule(scheduledTermination, inactivityTimeout);\n        }\n    }\n    synchronized void scheduleDeferredAcknowledgement(long delay) {\n        if (null == deferredAcknowledgments) {\n            deferredAcknowledgments = new ArrayList<>();\n        }\n        long now = System.currentTimeMillis();\n        long expectedExecutionTime = now + delay;\n        for (DeferredAcknowledgment da : deferredAcknowledgments) {\n            if (da.scheduledExecutionTime() <= expectedExecutionTime) {\n                return;\n            }\n        }\n        DeferredAcknowledgment da = new DeferredAcknowledgment();\n        deferredAcknowledgments.add(da);\n        destination.getManager().getTimer().schedule(da, delay);\n        LOG.fine(\"Scheduled acknowledgment to be sent in \" + delay + \" ms\");\n    }\n    synchronized void cancelDeferredAcknowledgments() {\n        if (null == deferredAcknowledgments) {\n            return;\n        }\n        for (int i = deferredAcknowledgments.size() - 1; i >= 0; i--) {\n            DeferredAcknowledgment da = deferredAcknowledgments.get(i);\n            da.cancel();\n        }\n    }\n    synchronized void cancelTermination() {\n        if (null != scheduledTermination) {\n            scheduledTermination.cancel();\n        }\n    }\n    final class DeferredAcknowledgment extends TimerTask {\n        public void run() {\n            LOG.fine(\"timer task: send acknowledgment.\");\n            DestinationSequence.this.scheduleImmediateAcknowledgement();\n            try {\n                RMEndpoint rme = destination.getReliableEndpoint();\n                Proxy proxy = rme.getProxy();\n                proxy.acknowledge(DestinationSequence.this);\n            } catch (RMException ex) {\n                // already logged\n            } finally {\n                synchronized (DestinationSequence.this) {\n                    DestinationSequence.this.deferredAcknowledgments.remove(this);\n                }\n            }\n        }\n    }\n    final class ImmediateFallbackAcknowledgment extends TimerTask {\n        public void run() {\n            LOG.fine(\"timer task: send acknowledgment.\");\n            if (!sendAcknowledgement()) {\n                //Acknowledgment already get send out\n                return;\n            }\n            try {\n                destination.getReliableEndpoint().getProxy().acknowledge(DestinationSequence.this);\n            } catch (RMException ex) {\n                // already logged\n            }\n        }\n    }\n    void terminate() {\n        if (!terminated) {\n            terminated = true;\n            RMStore store = destination.getManager().getStore();\n            if (null == store) {\n                return;\n            }\n            // only updating the sequence\n            store.persistIncoming(this, null);\n        }\n    }\n    public boolean isTerminated() {\n        return terminated;\n    }\n<fim_suffix>    final class SequenceTermination extends TimerTask {\n        private long maxInactivityTimeout;\n        void updateInactivityTimeout(long timeout) {\n            maxInactivityTimeout = Math.max(maxInactivityTimeout, timeout);\n        }\n        public void run() {\n            synchronized (DestinationSequence.this) {\n                DestinationSequence.this.scheduledTermination = null;\n                RMEndpoint rme = destination.getReliableEndpoint();\n                long lat = Math.max(rme.getLastControlMessage(), rme.getLastApplicationMessage());\n                if (0 == lat) {\n                    return;\n                }\n                long now = System.currentTimeMillis();\n                if (now - lat >= maxInactivityTimeout) {\n                    // terminate regardless outstanding acknowledgments - as we assume that the client is\n                    // gone there is no point in sending a SequenceAcknowledgment\n                    LogUtils.log(LOG, Level.WARNING, \"TERMINATING_INACTIVE_SEQ_MSG\",\n                                 DestinationSequence.this.getIdentifier().getValue());\n                    DestinationSequence.this.destination.terminateSequence(DestinationSequence.this, true);\n                    Source source = rme.getSource();\n                    if (source != null) {\n                        SourceSequence ss = source.getAssociatedSequence(DestinationSequence.this.getIdentifier());\n                        if (ss != null) {\n                            source.removeSequence(ss);\n                        }\n                    }\n                } else {\n                   // reschedule\n                    SequenceTermination st = new SequenceTermination();\n                    st.updateInactivityTimeout(maxInactivityTimeout);\n                    DestinationSequence.this.destination.getManager().getTimer()\n                        .schedule(st, maxInactivityTimeout);\n                }\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}