{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hadoop.hbase.util;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport org.apache.hadoop.hbase.io.ByteBufferWriter;\nimport org.apache.hadoop.hbase.io.util.StreamUtils;\nimport org.apache.hadoop.io.IOUtils;\nimport org.apache.hadoop.io.WritableUtils;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport sun.nio.ch.DirectBuffer;\nimport org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n/**\n * Utility functions for working with byte buffers, such as reading/writing\n * variable-length long numbers.\n */\n@SuppressWarnings(\"restriction\")\n@InterfaceAudience.Private\npublic final class ByteBufferUtils {\n  // \"Compressed integer\" serialization helper constants.\n  public final static int VALUE_MASK = 0x7f;\n  public final static int NEXT_BIT_SHIFT = 7;\n  public final static int NEXT_BIT_MASK = 1 << 7;\n  @VisibleForTesting\n  final static boolean UNSAFE_AVAIL = UnsafeAvailChecker.isAvailable();\n  public final static boolean UNSAFE_UNALIGNED = UnsafeAvailChecker.unaligned();\n  private ByteBufferUtils() {\n  }\n  static abstract class Comparer {\n    abstract int compareTo(byte [] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2);\n    abstract int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2);\n  }\n  static abstract class Converter {\n    abstract short toShort(ByteBuffer buffer, int offset);\n    abstract int toInt(ByteBuffer buffer);\n    abstract int toInt(ByteBuffer buffer, int offset);\n    abstract long toLong(ByteBuffer buffer, int offset);\n    abstract void putInt(ByteBuffer buffer, int val);\n    abstract int putInt(ByteBuffer buffer, int index, int val);\n    abstract void putShort(ByteBuffer buffer, short val);\n    abstract int putShort(ByteBuffer buffer, int index, short val);\n    abstract void putLong(ByteBuffer buffer, long val);\n    abstract int putLong(ByteBuffer buffer, int index, long val);\n  }\n<fim_suffix>  static class ComparerHolder {\n    static final String UNSAFE_COMPARER_NAME = ComparerHolder.class.getName() + \"$UnsafeComparer\";\n    static final Comparer BEST_COMPARER = getBestComparer();\n    static Comparer getBestComparer() {\n      try {\n        Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);\n        @SuppressWarnings(\"unchecked\")\n        Comparer comparer = (Comparer) theClass.getConstructor().newInstance();\n        return comparer;\n      } catch (Throwable t) { // ensure we really catch *everything*\n        return PureJavaComparer.INSTANCE;\n      }\n    }\n    static final class PureJavaComparer extends Comparer {\n      static final PureJavaComparer INSTANCE = new PureJavaComparer();\n      private PureJavaComparer() {}\n      @Override\n      public int compareTo(byte [] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {\n        int end1 = o1 + l1;\n        int end2 = o2 + l2;\n        for (int i = o1, j = o2; i < end1 && j < end2; i++, j++) {\n          int a = buf1[i] & 0xFF;\n          int b = buf2.get(j) & 0xFF;\n          if (a != b) {\n            return a - b;\n          }\n        }\n        return l1 - l2;\n      }\n      @Override\n      public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {\n        int end1 = o1 + l1;\n        int end2 = o2 + l2;\n        for (int i = o1, j = o2; i < end1 && j < end2; i++, j++) {\n          int a = buf1.get(i) & 0xFF;\n          int b = buf2.get(j) & 0xFF;\n          if (a != b) {\n            return a - b;\n          }\n        }\n        return l1 - l2;\n      }\n    }\n    static final class UnsafeComparer extends Comparer {\n      public UnsafeComparer() {}\n      static {\n        if(!UNSAFE_UNALIGNED) {\n          throw new Error();\n        }\n      }\n      @Override\n      public int compareTo(byte[] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {\n        long offset2Adj;\n        Object refObj2 = null;\n        if (buf2.isDirect()) {\n          offset2Adj = o2 + ((DirectBuffer)buf2).address();\n        } else {\n          offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;\n          refObj2 = buf2.array();\n        }\n        return compareToUnsafe(buf1, o1 + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET, l1,\n                refObj2, offset2Adj, l2);\n      }\n      @Override\n      public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {\n        long offset1Adj, offset2Adj;\n        Object refObj1 = null, refObj2 = null;\n        if (buf1.isDirect()) {\n          offset1Adj = o1 + ((DirectBuffer) buf1).address();\n        } else {\n          offset1Adj = o1 + buf1.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;\n          refObj1 = buf1.array();\n        }\n        if (buf2.isDirect()) {\n          offset2Adj = o2 + ((DirectBuffer) buf2).address();\n        } else {\n          offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;\n          refObj2 = buf2.array();\n        }\n        return compareToUnsafe(refObj1, offset1Adj, l1, refObj2, offset2Adj, l2);\n      }\n    }\n  }\n  static class ConverterHolder {\n    static final String UNSAFE_CONVERTER_NAME =\n            ConverterHolder.class.getName() + \"$UnsafeConverter\";\n    static final Converter BEST_CONVERTER = getBestConverter();\n    static Converter getBestConverter() {\n      try {\n        Class<?> theClass = Class.forName(UNSAFE_CONVERTER_NAME);\n        // yes, UnsafeComparer does implement Comparer<byte[]>\n        @SuppressWarnings(\"unchecked\")\n        Converter converter = (Converter) theClass.getConstructor().newInstance();\n        return converter;\n      } catch (Throwable t) { // ensure we really catch *everything*\n        return PureJavaConverter.INSTANCE;\n      }\n    }\n    static final class PureJavaConverter extends Converter {\n      static final PureJavaConverter INSTANCE = new PureJavaConverter();\n      private PureJavaConverter() {}\n      @Override\n      short toShort(ByteBuffer buffer, int offset) {\n        return buffer.getShort(offset);\n      }\n      @Override\n      int toInt(ByteBuffer buffer) {\n        return buffer.getInt();\n      }\n      @Override\n      int toInt(ByteBuffer buffer, int offset) {\n        return buffer.getInt(offset);\n      }\n      @Override\n      long toLong(ByteBuffer buffer, int offset) {\n        return buffer.getLong(offset);\n      }\n      @Override\n      void putInt(ByteBuffer buffer, int val) {\n        buffer.putInt(val);\n      }\n      @Override\n      int putInt(ByteBuffer buffer, int index, int val) {\n        buffer.putInt(index, val);\n        return index + Bytes.SIZEOF_INT;\n      }\n      @Override\n      void putShort(ByteBuffer buffer, short val) {\n        buffer.putShort(val);\n      }\n      @Override\n      int putShort(ByteBuffer buffer, int index, short val) {\n        buffer.putShort(index, val);\n        return index + Bytes.SIZEOF_SHORT;\n      }\n      @Override<fim_middle>// class below has no smell\n"}