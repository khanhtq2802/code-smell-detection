{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.util;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n/**\n * This class contains utility methods for commonly used functional patterns for collections.\n */\npublic final class CollectionsUtil {\n    private CollectionsUtil() {\n    }\n    /**\n     * Concatenates two iterables into a single iterable. The iterator exposed by the returned\n     * iterable does not support {@link Iterator#remove()} even if the input iterables do.\n     *\n     * @throws NullPointerException if {@code a} or {@code b} is {@code null}\n     */\n    public static <T> Iterable<T> concat(Iterable<T> a, Iterable<T> b) {\n        List<Iterable<T>> l = Arrays.asList(a, b);\n        return concat(l);\n    }\n    /**\n     * Concatenates multiple iterables into a single iterable. The iterator exposed by the returned\n     * iterable does not support {@link Iterator#remove()} even if the input iterables do.\n     *\n     * @throws NullPointerException if {@code iterables} or any of its elements are {@code null}\n     */\n    public static <T> Iterable<T> concat(List<Iterable<T>> iterables) {\n        for (Iterable<T> iterable : iterables) {\n            Objects.requireNonNull(iterable);\n        }\n        return new Iterable<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                if (iterables.size() == 0) {\n                    return Collections.emptyIterator();\n                }\n                return new Iterator<T>() {\n                    Iterator<Iterable<T>> cursor = iterables.iterator();\n                    Iterator<T> currentIterator = cursor.next().iterator();\n                    private void advance() {\n                        while (!currentIterator.hasNext() && cursor.hasNext()) {\n                            currentIterator = cursor.next().iterator();\n                        }\n                    }\n                    @Override\n                    public boolean hasNext() {\n                        advance();\n                        return currentIterator.hasNext();\n                    }\n                    @Override\n                    public T next() {\n                        advance();\n                        return currentIterator.next();\n                    }\n                };\n            }\n        };\n    }\n    /**\n     * Returns whether all elements in {@code inputs} match {@code predicate}. May not evaluate\n     * {@code predicate} on all elements if not necessary for determining the result. If\n     * {@code inputs} is empty then {@code true} is returned and {@code predicate} is not evaluated.\n     *\n     * @return {@code true} if either all elements in {@code inputs} match {@code predicate} or\n     *         {@code inputs} is empty, otherwise {@code false}.\n     */\n    public static <T> boolean allMatch(T[] inputs, Predicate<T> predicate) {\n        return allMatch(Arrays.asList(inputs), predicate);\n    }\n    /**\n     * Returns whether all elements in {@code inputs} match {@code predicate}. May not evaluate\n     * {@code predicate} on all elements if not necessary for determining the result. If\n     * {@code inputs} is empty then {@code true} is returned and {@code predicate} is not evaluated.\n     *\n     * @return {@code true} if either all elements in {@code inputs} match {@code predicate} or\n     *         {@code inputs} is empty, otherwise {@code false}.\n     */\n    public static <T> boolean allMatch(Iterable<T> inputs, Predicate<T> predicate) {\n        for (T t : inputs) {\n            if (!predicate.test(t)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns whether any elements in {@code inputs} match {@code predicate}. May not evaluate\n     * {@code predicate} on all elements if not necessary for determining the result. If\n     * {@code inputs} is empty then {@code false} is returned and {@code predicate} is not\n     * evaluated.\n     *\n     * @return {@code true} if any elements in {@code inputs} match {@code predicate}, otherwise\n     *         {@code false}.\n     */\n    public static <T> boolean anyMatch(T[] inputs, Predicate<T> predicate) {\n        return anyMatch(Arrays.asList(inputs), predicate);\n    }\n    /**\n     * Returns whether any elements in {@code inputs} match {@code predicate}. May not evaluate\n     * {@code predicate} on all elements if not necessary for determining the result. If\n     * {@code inputs} is empty then {@code false} is returned and {@code predicate} is not\n     * evaluated.\n     *\n     * @return {@code true} if any elements in {@code inputs} match {@code predicate}, otherwise\n     *         {@code false}.\n     */\n    public static <T> boolean anyMatch(Iterable<T> inputs, Predicate<T> predicate) {\n        for (T t : inputs) {\n            if (predicate.test(t)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns a new list consisting of the elements in {@code inputs} that match {@code predicate}.\n     *\n     * @return the new list.\n     */\n    public static <T> List<T> filterToList(List<T> inputs, Predicate<? super T> predicate) {\n        return filterToList(inputs, predicate, ArrayList::new);\n    }\n    /**\n     * Appends elements of {@code inputs} that match {@code predicate} to the list generated by\n     * {@code listGenerator}.\n     *\n     * @return the list generated by {@code listGenerator}.\n     */\n    public static <T> List<T> filterToList(List<T> inputs, Predicate<? super T> predicate, Supplier<List<T>> listGenerator) {\n        List<T> resultList = listGenerator.get();\n        for (T t : inputs) {\n            if (predicate.test(t)) {\n                resultList.add(t);\n            }\n        }\n        return resultList;\n    }\n    /**\n     * Filters {@code inputs} with {@code predicate}, applies {@code mapper} and adds them in the\n     * array provided by {@code arrayGenerator}.\n     *\n     * @return the array provided by {@code arrayGenerator}.\n     */\n    public static <T, R> R[] filterAndMapToArray(T[] inputs, Predicate<? super T> predicate, Function<? super T, ? extends R> mapper, IntFunction<R[]> arrayGenerator) {\n        List<R> resultList = new ArrayList<>();\n        for (T t : inputs) {\n            if (predicate.test(t)) {\n                resultList.add(mapper.apply(t));\n            }\n        }\n        return resultList.toArray(arrayGenerator.apply(resultList.size()));\n    }\n    /**\n     * Applies {@code mapper} on the elements in {@code inputs} and adds them in the array provided\n     * by {@code arrayGenerator}.\n     *\n     * @return the array provided by {@code arrayGenerator}.\n     */\n    public static <T, R> R[] mapToArray(T[] inputs, Function<? super T, ? extends R> mapper, IntFunction<R[]> arrayGenerator) {\n        return mapToArray(Arrays.asList(inputs), mapper, arrayGenerator);\n    }\n    /**\n     * Applies {@code mapper} on the elements in {@code inputs} and adds them in the array provided\n     * by {@code arrayGenerator}.\n     *\n     * @return the array provided by {@code arrayGenerator}.\n     */\n<fim_suffix>    public static <T, R> R[] mapToArray(Collection<T> inputs, Function<? super T, ? extends R> mapper, IntFunction<R[]> arrayGenerator) {\n        R[] result = arrayGenerator.apply(inputs.size());\n        int idx = 0;\n        for (T t : inputs) {\n            result[idx++] = mapper.apply(t);\n        }\n        return result;\n    }\n    /**<fim_middle>// function below has no smell\n"}