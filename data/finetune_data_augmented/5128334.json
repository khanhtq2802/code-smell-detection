{"text": "<fim_prefix>import java.util.List;\nimport java.util.Set;\nimport java.util.zip.GZIPOutputStream;\nimport org.apache.lucene.document.Document;\nimport org.apache.lucene.document.Field.Store;\nimport org.apache.lucene.document.StringField;\nimport org.apache.lucene.index.IndexOptions;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.IndexableField;\nimport org.apache.lucene.index.MultiFields;\nimport org.apache.lucene.util.Bits;\nimport org.apache.maven.index.ArtifactInfo;\nimport org.apache.maven.index.context.DefaultIndexingContext;\nimport org.apache.maven.index.context.IndexingContext;\n/**\n * An index data writer used to write transfer index format.\n * \n * @author Eugene Kuleshov\n */\n<fim_suffix>public class IndexDataWriter\n{\n    static final int VERSION = 1;\n    static final int F_INDEXED = 1;\n    static final int F_TOKENIZED = 2;\n    static final int F_STORED = 4;\n    static final int F_COMPRESSED = 8;\n    private final DataOutputStream dos;\n    private final GZIPOutputStream gos;\n    private final BufferedOutputStream bos;\n    private final Set<String> allGroups;\n    private final Set<String> rootGroups;\n    private boolean descriptorWritten;\n    public IndexDataWriter( OutputStream os )\n        throws IOException\n    {\n        bos = new BufferedOutputStream( os, 1024 * 8 );\n        gos = new GZIPOutputStream( bos, 1024 * 2 );\n        dos = new DataOutputStream( gos );\n        this.allGroups = new HashSet<String>();\n        this.rootGroups = new HashSet<String>();\n        this.descriptorWritten = false;\n    }\n    public int write( IndexingContext context, IndexReader indexReader, List<Integer> docIndexes )\n        throws IOException\n    {\n        writeHeader( context );\n        int n = writeDocuments( indexReader, docIndexes );\n        writeGroupFields();\n        close();\n        return n;\n    }\n    public void close()\n        throws IOException\n    {\n        dos.flush();\n        gos.flush();\n        gos.finish();\n        bos.flush();\n    }\n    public void writeHeader( IndexingContext context )\n        throws IOException\n    {\n        dos.writeByte( VERSION );\n        Date timestamp = context.getTimestamp();\n        dos.writeLong( timestamp == null ? -1 : timestamp.getTime() );\n    }\n    public void writeGroupFields()\n        throws IOException\n    {\n        {\n            List<IndexableField> allGroupsFields = new ArrayList<>( 2 );\n            allGroupsFields.add( new StringField( ArtifactInfo.ALL_GROUPS, ArtifactInfo.ALL_GROUPS_VALUE, Store.YES ) );\n            allGroupsFields.add( new StringField( ArtifactInfo.ALL_GROUPS_LIST, ArtifactInfo.lst2str( allGroups ),\n                                                  Store.YES ) );\n            writeDocumentFields( allGroupsFields );\n        }\n        {\n            List<IndexableField> rootGroupsFields = new ArrayList<>( 2 );\n            rootGroupsFields.add( new StringField( ArtifactInfo.ROOT_GROUPS, ArtifactInfo.ROOT_GROUPS_VALUE,\n                                                   Store.YES ) );\n            rootGroupsFields.add( new StringField( ArtifactInfo.ROOT_GROUPS_LIST, ArtifactInfo.lst2str( rootGroups ),\n                                                   Store.YES ) );\n            writeDocumentFields( rootGroupsFields );\n        }\n    }\n    public int writeDocuments( IndexReader r, List<Integer> docIndexes )\n        throws IOException\n    {\n        int n = 0;\n        Bits liveDocs = MultiFields.getLiveDocs( r );\n        if ( docIndexes == null )\n        {\n            for ( int i = 0; i < r.maxDoc(); i++ )\n            {\n                if ( liveDocs == null || liveDocs.get( i ) )\n                {\n                    if ( writeDocument( r.document( i ) ) )\n                    {\n                        n++;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for ( int i : docIndexes )\n            {\n                if ( liveDocs == null || liveDocs.get( i ) )\n                {\n                    if ( writeDocument( r.document( i ) ) )\n                    {\n                        n++;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    public boolean writeDocument( final Document document )\n        throws IOException\n    {\n        List<IndexableField> fields = document.getFields();\n        List<IndexableField> storedFields = new ArrayList<>( fields.size() );\n        for ( IndexableField field : fields )\n        {\n            if ( DefaultIndexingContext.FLD_DESCRIPTOR.equals( field.name() ) )\n            {\n                if ( descriptorWritten )\n                {\n                    return false;\n                }\n                else\n                {\n                    descriptorWritten = true;\n                }\n            }\n            if ( ArtifactInfo.ALL_GROUPS.equals( field.name() ) )\n            {\n                final String groupList = document.get( ArtifactInfo.ALL_GROUPS_LIST );\n                if ( groupList != null && groupList.trim().length() > 0 )\n                {\n                    allGroups.addAll( ArtifactInfo.str2lst( groupList ) );\n                }\n                return false;\n            }\n            if ( ArtifactInfo.ROOT_GROUPS.equals( field.name() ) )\n            {\n                final String groupList = document.get( ArtifactInfo.ROOT_GROUPS_LIST );\n                if ( groupList != null && groupList.trim().length() > 0 )\n                {\n                    rootGroups.addAll( ArtifactInfo.str2lst( groupList ) );\n                }\n                return false;\n            }\n            if ( field.fieldType().stored() )\n            {\n                storedFields.add( field );\n            }\n        }\n        writeDocumentFields( storedFields );\n        return true;\n    }\n    public void writeDocumentFields( List<IndexableField> fields )\n        throws IOException\n    {\n        dos.writeInt( fields.size() );\n        for ( IndexableField field : fields )\n        {\n            writeField( field );\n        }\n    }\n    public void writeField( IndexableField field )\n        throws IOException\n    {\n        int flags = ( field.fieldType().indexOptions() != IndexOptions.NONE  ? F_INDEXED : 0 ) //\n            + ( field.fieldType().tokenized() ? F_TOKENIZED : 0 ) //\n            + ( field.fieldType().stored() ? F_STORED : 0 ); //\n        // + ( false ? F_COMPRESSED : 0 ); // Compressed not supported anymore\n        String name = field.name();\n        String value = field.stringValue();\n        dos.write( flags );\n        dos.writeUTF( name );\n        writeUTF( value, dos );\n    }\n    private static void writeUTF( String str, DataOutput out )\n        throws IOException\n    {\n        int strlen = str.length();\n        int utflen = 0;\n        int c;\n        // use charAt instead of copying String to char array\n        for ( int i = 0; i < strlen; i++ )\n        {\n            c = str.charAt( i );\n            if ( ( c >= 0x0001 ) && ( c <= 0x007F ) )\n            {\n                utflen++;\n            }\n            else if ( c > 0x07FF )\n            {\n                utflen += 3;\n            }\n            else\n            {\n                utflen += 2;\n            }\n        }\n        // TODO optimize storing int value\n        out.writeInt( utflen );\n        byte[] bytearr = new byte[utflen];\n        int count = 0;\n        int i = 0;\n        for ( ; i < strlen; i++ )\n        {\n            c = str.charAt( i );\n            if ( !( ( c >= 0x0001 ) && ( c <= 0x007F ) ) )\n            {\n                break;\n            }\n            bytearr[count++] = (byte) c;\n        }\n        for ( ; i < strlen; i++ )\n        {\n            c = str.charAt( i );\n            if ( ( c >= 0x0001 ) && ( c <= 0x007F ) )\n            {\n                bytearr[count++] = (byte) c;\n            }\n            else if ( c > 0x07FF )\n            {\n                bytearr[count++] = (byte) ( 0xE0 | ( ( c >> 12 ) & 0x0F ) );\n                bytearr[count++] = (byte) ( 0x80 | ( ( c >> 6 ) & 0x3F ) );\n                bytearr[count++] = (byte) ( 0x80 | ( ( c >> 0 ) & 0x3F ) );\n            }\n            else\n            {\n                bytearr[count++] = (byte) ( 0xC0 | ( ( c >> 6 ) & 0x1F ) );\n                bytearr[count++] = (byte) ( 0x80 | ( ( c >> 0 ) & 0x3F ) );\n            }\n        }\n        out.write( bytearr, 0, utflen );\n    }\n}<fim_middle>// class below is blob\n"}