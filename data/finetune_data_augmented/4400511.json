{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.ws.rm;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.interceptor.OutgoingChainInterceptor;\nimport org.apache.cxf.message.Message;\nimport org.apache.cxf.message.MessageUtils;\nimport org.apache.cxf.phase.Phase;\nimport org.apache.cxf.ws.addressing.AddressingProperties;\nimport org.apache.cxf.ws.addressing.ContextUtils;\n\n/**\n * Interceptor used for InOrder delivery of messages to the destination. This works with\n * {@link DestinationSequence} to allow only one message at a time from a particular sequence through to the\n * destination (since otherwise there is no way to enforce in-order delivery).\n */\n<fim_suffix>public class RMDeliveryInterceptor extends AbstractRMInterceptor<Message> {\n\n    private static final Logger LOG = LogUtils.getL7dLogger(RMDeliveryInterceptor.class);\n\n    public RMDeliveryInterceptor() {\n        super(Phase.POST_INVOKE);\n        addBefore(OutgoingChainInterceptor.class.getName());\n    }\n\n    // Interceptor interface\n\n    public void handle(Message message) throws SequenceFault, RMException {\n        final AddressingProperties maps = ContextUtils.retrieveMAPs(message, false, false, false);\n        //if wsrmp:RMAssertion and addressing is optional\n        if (maps == null && isRMPolicyEnabled(message)) {\n            return;\n        }\n        LOG.entering(getClass().getName(), \"handleMessage\");\n        Destination dest = getManager().getDestination(message);\n        final boolean robust =\n            MessageUtils.getContextualBoolean(message, Message.ROBUST_ONEWAY, false);\n        if (robust) {\n            message.remove(RMMessageConstants.DELIVERING_ROBUST_ONEWAY);\n            dest.acknowledge(message);\n        }\n        dest.processingComplete(message);\n\n        // close InputStream of RMCaptureInInterceptor, to delete tmp files in filesystem\n        Closeable closable = (Closeable)message.get(\"org.apache.cxf.ws.rm.content.closeable\");\n        if (null != closable) {\n            try {\n                closable.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}<fim_middle>// class below has no smell\n"}