{"text": "<fim_prefix>/*\n * Copyright (C) 2014 Google, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.auto.value.processor;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.escapevelocity.Template;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n/**\n * A template and a set of variables to be substituted into that template. A concrete subclass of\n * this class defines a set of fields that are template variables, and an implementation of the\n * {@link #parsedTemplate()} method which is the template to substitute them into. Once the values\n * of the fields have been assigned, the {@link #toText()} method returns the result of substituting\n * them into the template.\n *\n * <p>The subclass may be a direct subclass of this class or a more distant descendant. Every field\n * in the starting class and its ancestors up to this class will be included. Fields cannot be\n * static unless they are also final. They cannot be private, though they can be package-private if\n * the class is in the same package as this class. They cannot be primitive or null, so that there\n * is a clear indication when a field has not been set.\n *\n * @author \u00c9amonn McManus\n */\nabstract class TemplateVars {\n  abstract Template parsedTemplate();\n  private final ImmutableList<Field> fields;\n  TemplateVars() {\n    this.fields = getFields(getClass());\n  }\n  private static ImmutableList<Field> getFields(Class<?> c) {\n    ImmutableList.Builder<Field> fieldsBuilder = ImmutableList.builder();\n    while (c != TemplateVars.class) {\n      addFields(fieldsBuilder, c.getDeclaredFields());\n      c = c.getSuperclass();\n    }\n    return fieldsBuilder.build();\n  }\n  private static void addFields(\n      ImmutableList.Builder<Field> fieldsBuilder, Field[] declaredFields) {\n    for (Field field : declaredFields) {\n      if (field.isSynthetic() || isStaticFinal(field)) {\n        continue;\n      }\n      if (Modifier.isPrivate(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field cannot be private: \" + field);\n      }\n      if (Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field cannot be static unless also final: \" + field);\n      }\n      if (field.getType().isPrimitive()) {\n        throw new IllegalArgumentException(\"Field cannot be primitive: \" + field);\n      }\n      fieldsBuilder.add(field);\n    }\n  }\n  /**\n   * Returns the result of substituting the variables defined by the fields of this class (a\n   * concrete subclass of TemplateVars) into the template returned by {@link #parsedTemplate()}.\n   */\n  String toText() {\n    Map<String, Object> vars = toVars();\n    return parsedTemplate().evaluate(vars);\n  }\n  private Map<String, Object> toVars() {\n    Map<String, Object> vars = new TreeMap<>();\n    for (Field field : fields) {\n      Object value = fieldValue(field, this);\n      if (value == null) {\n        throw new IllegalArgumentException(\"Field cannot be null (was it set?): \" + field);\n      }\n      Object old = vars.put(field.getName(), value);\n      if (old != null) {\n        throw new IllegalArgumentException(\"Two fields called \" + field.getName() + \"?!\");\n      }\n    }\n    return ImmutableMap.copyOf(vars);\n  }\n  static Template parsedTemplateForResource(String resourceName) {\n    try {\n      return Template.parseFrom(resourceName, TemplateVars::readerFromResource);\n    } catch (UnsupportedEncodingException e) {\n      throw new AssertionError(e);\n    } catch (IOException | NullPointerException e) {\n      // https://github.com/google/auto/pull/439 says that we can also get NullPointerException.\n      return retryParseAfterException(resourceName, e);\n    }\n  }\n  private static Template retryParseAfterException(String resourceName, Exception exception) {\n    try {\n      return Template.parseFrom(resourceName, TemplateVars::readerFromUrl);\n    } catch (IOException t) {\n      // Chain the original exception so we can see both problems.\n      Throwables.getRootCause(exception).initCause(t);\n      throw new AssertionError(exception);\n    }\n  }\n  private static Reader readerFromResource(String resourceName) {\n    InputStream in = TemplateVars.class.getResourceAsStream(resourceName);\n    if (in == null) {\n      throw new IllegalArgumentException(\"Could not find resource: \" + resourceName);\n    }\n    return new InputStreamReader(in, StandardCharsets.UTF_8);\n  }\n  // This is an ugly workaround for https://bugs.openjdk.java.net/browse/JDK-6947916, as\n  // reported in https://github.com/google/auto/issues/365.\n  // The issue is that sometimes the InputStream returned by JarURLCollection.getInputStream()\n  // can be closed prematurely, which leads to an IOException saying \"Stream closed\".\n  // We catch all IOExceptions, and fall back on logic that opens the jar file directly and\n  // loads the resource from it. Since that doesn't use JarURLConnection, it shouldn't be\n  // susceptible to the same bug. We only use this as fallback logic rather than doing it always,\n  // because jars are memory-mapped by URLClassLoader, so loading a resource in the usual way\n  // through the getResourceAsStream should be a lot more efficient than reopening the jar.\n  private static Reader readerFromUrl(String resourceName) throws IOException {\n    URL resourceUrl = TemplateVars.class.getResource(resourceName);\n    InputStream in;\n    try {\n      if (resourceUrl.getProtocol().equalsIgnoreCase(\"file\")) {\n        in = inputStreamFromFile(resourceUrl);\n      } else if (resourceUrl.getProtocol().equalsIgnoreCase(\"jar\")) {\n        in = inputStreamFromJar(resourceUrl);\n      } else {\n        throw new AssertionError(\"Template fallback logic fails for: \" + resourceUrl);\n      }\n    } catch (URISyntaxException e) {\n      throw new IOException(e);\n    }\n    return new InputStreamReader(in, StandardCharsets.UTF_8);\n  }\n<fim_suffix>  private static InputStream inputStreamFromJar(URL resourceUrl)\n      throws URISyntaxException, IOException {\n    // Jar URLs look like this: jar:file:/path/to/file.jar!/entry/within/jar\n    // So take apart the URL to open the jar /path/to/file.jar and read the entry\n    // entry/within/jar from it.\n    String resourceUrlString = resourceUrl.toString().substring(\"jar:\".length());\n    int bang = resourceUrlString.lastIndexOf('!');\n    String entryName = resourceUrlString.substring(bang + 1);\n    if (entryName.startsWith(\"/\")) {\n      entryName = entryName.substring(1);\n    }\n    URI jarUri = new URI(resourceUrlString.substring(0, bang));\n    JarFile jar = new JarFile(new File(jarUri));\n    JarEntry entry = jar.getJarEntry(entryName);\n    InputStream in = jar.getInputStream(entry);\n    // We have to be careful not to close the JarFile before the stream has been read, because\n    // that would also close the stream. So we defer closing the JarFile until the stream is closed.\n    return new FilterInputStream(in) {\n      @Override\n      public void close() throws IOException {\n        super.close();\n        jar.close();\n      }\n    };\n  }\n  // We don't really expect this case to arise, since the bug we're working around concerns jars\n  // not individual files. However, when running the test for this workaround from Maven, we do\n  // have files. That does mean the test is basically useless there, but Google's internal build\n  // system does run it using a jar, so we do have coverage.\n  private static InputStream inputStreamFromFile(URL resourceUrl)\n      throws IOException, URISyntaxException {\n    File resourceFile = new File(resourceUrl.toURI());\n    return new FileInputStream(resourceFile);\n  }<fim_middle>// function below has no smell\n"}