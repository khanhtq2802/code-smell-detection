{"text": "<fim_prefix>\n<fim_suffix>public class QuartzGFXCMD extends GFXCMD2\n{\n\tprivate native long createNSViewLong0();\n\tpublic void setVideoBounds(java.awt.Rectangle srcRect, java.awt.Rectangle destRect)\n\t{\n\t\tsuper.setVideoBounds(srcRect, destRect);\n\t\tif (srcRect != null && destRect != null)\n\t\t{\n\t\t\tjava.awt.geom.Rectangle2D.Float srcRectf = new java.awt.geom.Rectangle2D.Float(srcRect.x, srcRect.y, srcRect.width, srcRect.height);\n\t\t\tjava.awt.geom.Rectangle2D.Float destRectf = new java.awt.geom.Rectangle2D.Float(destRect.x, destRect.y, destRect.width, destRect.height);\n\t\t\tsetVideoRects0(srcRectf, destRectf, new java.awt.Color(0, true));\n\t\t}\n\t}\n\t\t// quick hack to get fonts looking correct since inter character spacing is different between AWT and Cocoa\n\tprivate class McFont {\n\t\tprivate java.awt.Font awtFont = null;\n\t\tprivate java.awt.font.FontRenderContext frc = null;\n\t\tpublic long nativeFont = 0;\n\t\tpublic McFont(String name, int style, int size) {\n\t\t\tfrc = new java.awt.font.FontRenderContext(null, true, false);\t// same as in MetaFont, so calculations should be the same here...\n\t\t\tawtFont = new java.awt.Font(name, style, size);\n\t\t\tnativeFont = loadFont0(name, style, size);\n\t\t}\n\t\tpublic void unload() {\n\t\t\tif(nativeFont != 0) unloadFont0(nativeFont);\n\t\t\tnativeFont = 0;\n\t\t\tawtFont = null;\n\t\t}\n\t\tpublic java.awt.Dimension getStringSize(String s) {\n\t\t\tjava.awt.geom.Rectangle2D bounds = awtFont.getStringBounds(s, frc);\n\t\t\treturn new java.awt.Dimension((int)bounds.getWidth(), (int)bounds.getHeight());\n\t\t}\n\t\tpublic float[] getGlyphPositions(String s) {\n\t\t\tjava.awt.font.GlyphVector gvec = awtFont.createGlyphVector(frc, s);\n//\t\t\tSystem.out.println(\"getGlyphPositions gvec=\"+gvec);\n\t\t\tif(gvec != null) {\n\t\t\t\tfloat[] positions = gvec.getGlyphPositions(0, gvec.getNumGlyphs(), null);\n\t\t\t\treturn positions;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\t\t// CocoaComponent derives from java.awt.Canvas\n\tprivate class QuartzRendererView extends com.apple.eawt.CocoaComponent {\n/*\t\tpublic void setBounds(int x, int y, int width, int height)\n\t\t{\n\t\t\tSystem.out.println(\"QRV.setBounds(\"+x+\",\"+y+\",\"+width+\",\"+height+\")\");\n\t\t\tsuper.setBounds(x,y,width,height);\n\t\t}\n\t\tpublic void setBounds(java.awt.Rectangle r)\n\t\t{\n\t\t\tSystem.out.println(\"QRV.setBounds(\"+r+\")\");\n\t\t\tsuper.setBounds(r);\n\t\t}\n*/\n\t\tpublic long nativeView = 0;\n//\t\tprivate native long createNSViewLong0();\n\t\tpublic long createNSViewLong() {\n\t\t\tnativeView = createNSViewLong0();\n\t\t\treturn nativeView;\n\t\t}\n\t\t// *sigh* ignore the deprecation warnings\n\t\tpublic int createNSView() {\n\t\t\treturn (int)createNSViewLong();\n\t\t}\n\t\t// CocaComponent abstracts\n\t\tfinal java.awt.Dimension PREF_SIZE = new java.awt.Dimension(720,480);\n\t\tfinal java.awt.Dimension MIN_SIZE = new java.awt.Dimension(20,20);\n\t\tfinal java.awt.Dimension MAX_SIZE = new java.awt.Dimension(4096,4096); // Baud help us if we ever see this size...\n\t\tpublic java.awt.Dimension getPreferredSize() {\n\t\t\treturn PREF_SIZE;\n\t\t}\n\t\tpublic java.awt.Dimension getMinimumSize() {\n\t\t\treturn MIN_SIZE;\n\t\t}\n\t\tpublic java.awt.Dimension getMaximumSize() {\n\t\t\treturn MAX_SIZE;\n\t\t}\n\t\t// all rendering is done on the native side, so override these to do nothing...\n\t\tpublic void update(java.awt.Graphics g) {}\n\t\tpublic void paint(java.awt.Graphics g) {}\n\t}\n\tpublic QuartzGFXCMD(MiniClientConnection myConn)\n\t{\n\t\tsuper(myConn);\n\t\timageCacheLimit = 32000000;\n\t\ttry\n\t\t{\n\t\t\timageCacheLimit = Integer.parseInt(MiniClient.myProperties.getProperty(\"image_cache_size\", \"32000000\"));\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Invalid image_cache_size property:\" + e);\n\t\t}\n\t}\n\tprivate QuartzRendererView c;\n\tprivate java.awt.Graphics2D g2;\n\tprivate java.awt.Graphics2D primaryG2;\n\tprivate java.util.Map imageMap = new java.util.HashMap();\n\tprivate java.util.Map layerMap = new java.util.HashMap();\n\tprivate int handleCount = 2;\n\tprivate long hideTime = 0;\n\tprivate java.util.TimerTask hideTimer;\n\tprivate long currentLayer = 0;\n\tpublic void close()\n\t{\n\t\tif (f != null)\n\t\t\tf.dispose();\n\t\tc = null;\n\t\tcancelHideTimer();\n\t\tcleanupRenderer();\n\t}\n\tpublic void refresh()\n\t{\n\t\tc.invalidate();\n\t\tf.invalidate();\n\t\tf.validate();\n\t}\n\tprivate void cleanupRenderer()\n\t{\n\t\tjava.util.Iterator iter;\n\t\t// free all images\n\t\tif(!imageMap.isEmpty()) {\n\t\t\titer = imageMap.values().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tLong imagePtr = (Long)iter.next();\n\t\t\t\tif(imagePtr != null) freeNativeImage0(imagePtr.longValue());\n\t\t\t}\n\t\t\timageMap.clear();\n\t\t}\n\t\t// free all layers\n\t\tif(!layerMap.isEmpty()) {\n\t\t\titer = layerMap.values().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tLong layerPtr = (Long)iter.next();\n\t\t\t\tif(layerPtr != null) freeLayer0(layerPtr.longValue());\n\t\t\t}\n\t\t\tlayerMap.clear();\n\t\t}\n\t\t// free all fonts\n\t\tif(!fontMap.isEmpty()) {\n\t\t\titer = fontMap.values().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tMcFont f = (McFont)iter.next();\n\t\t\t\tif(f != null) f.unload();\n\t\t\t}\n\t\t\tfontMap.clear();\n\t\t}\n\t\t// call cleanupRenderer0 to tell native side to clean up\n\t\tcleanupRenderer0();\n\t}\n\tpublic MiniClientWindow getWindow()\n\t{\n\t\treturn f;\n\t}\n\tprivate java.awt.GradientPaint getGradient(float x, float y, float width, float height, int argbTL, int argbTR, int argbBL, int argbBR)\n\t{\n\t\tfloat x2 = x + width;\n\t\tfloat y2 = y + height;\n\t\tif (argbTL != argbTR || argbTL != argbBL || argbTL != argbBR)\n\t\t{\n\t\t\tif (Math.abs(argbTL - argbTR) >= Math.abs(argbTL - argbBL) &&\n\t\t\t\tMath.abs(argbTL - argbTR) >= Math.abs(argbTL - argbBR))<fim_middle>// class below is blob\n"}