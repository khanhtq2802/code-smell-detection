{"text": "<fim_prefix>/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.aries.subsystem.core.internal;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.security.AccessController;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.aries.subsystem.core.archive.ProvisionPolicyDirective;\nimport org.apache.aries.subsystem.core.archive.SubsystemContentHeader;\nimport org.apache.aries.subsystem.core.archive.SubsystemManifest;\nimport org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;\nimport org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;\nimport org.apache.aries.subsystem.core.internal.DependencyCalculator.MissingCapability;\nimport org.apache.aries.subsystem.core.internal.StartAction.Restriction;\nimport org.apache.aries.subsystem.core.repository.Repository;\nimport org.eclipse.equinox.region.Region;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.namespace.ExecutionEnvironmentNamespace;\nimport org.osgi.framework.namespace.HostNamespace;\nimport org.osgi.framework.namespace.IdentityNamespace;\nimport org.osgi.framework.namespace.NativeNamespace;\nimport org.osgi.framework.namespace.PackageNamespace;\nimport org.osgi.framework.wiring.BundleRevision;\nimport org.osgi.framework.wiring.BundleWiring;\nimport org.osgi.resource.Capability;\nimport org.osgi.resource.Namespace;\nimport org.osgi.resource.Requirement;\nimport org.osgi.resource.Resource;\nimport org.osgi.resource.Wire;\nimport org.osgi.resource.Wiring;\nimport org.osgi.service.resolver.HostedCapability;\nimport org.osgi.service.subsystem.Subsystem.State;\npublic class ResolveContext extends org.osgi.service.resolver.ResolveContext {\n\tprivate final Repository contentRepository;\n\tprivate final Repository localRepository;\n\tprivate final Repository preferredProviderRepository;\n\tprivate final Repository repositoryServiceRepository;\n\tprivate final SubsystemResource resource;\n\tprivate final Repository systemRepository;\n\tprivate final Map<Resource, Wiring> wirings = computeWirings();\n\tpublic ResolveContext(SubsystemResource resource) {\n\t\tthis.resource = resource;\n\t\tcontentRepository = new ContentRepository(resource.getInstallableContent(), resource.getSharedContent());\n\t\tlocalRepository = resource.getLocalRepository();\n\t\tpreferredProviderRepository = new PreferredProviderRepository(resource);\n\t\trepositoryServiceRepository = new RepositoryServiceRepository();\n\t\tsystemRepository = Activator.getInstance().getSystemRepository();\n\t}\n\tprivate void installDependenciesOfRequirerIfNecessary(Requirement requirement) {\n\t\tif (requirement == null) {\n\t\t\treturn;\n\t\t}\n\t\tResource requirer = requirement.getResource();\n\t\tif (resource.equals(requirer)) {\n\t\t\treturn;\n\t\t}\n\t\tCollection<BasicSubsystem> subsystems;\n\t\tif (requirer instanceof BasicSubsystem) {\n\t\t\tBasicSubsystem subsystem = (BasicSubsystem)requirer;\n\t\t\tsubsystems = Collections.singletonList(subsystem);\n\t\t}\n\t\telse if (requirer instanceof BundleRevision) {\n\t\t\tBundleRevision revision = (BundleRevision)requirer;\n\t\t\tBundleConstituent constituent = new BundleConstituent(null, revision);\n\t\t\tsubsystems = Activator.getInstance().getSubsystems().getSubsystemsByConstituent(constituent);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor (BasicSubsystem subsystem : subsystems) {\n\t\t\tif (Utils.isProvisionDependenciesInstall(subsystem) \n\t\t\t\t\t|| !State.INSTALLING.equals(subsystem.getState())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAccessController.doPrivileged(new StartAction(subsystem, subsystem, subsystem, Restriction.INSTALL_ONLY));\n\t\t}\n\t}\n\tprivate boolean isResolved(Resource resource) {\n\t\treturn wirings.containsKey(resource);\n\t}\n\tprivate boolean isProcessableAsFragment(Requirement requirement) {\n\t\tResource resource = requirement.getResource();\n\t\tString namespace = requirement.getNamespace();\n\t\treturn Utils.isFragment(resource)\n\t\t\t\t&& !(ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE.equals(namespace)\n\t\t\t\t\t\t|| HostNamespace.HOST_NAMESPACE.equals(namespace));\n\t}\n\tprivate void processAsFragment(Requirement requirement, List<Capability> capabilities) {\n\t\tString namespace = requirement.getNamespace();\n\t\tResource fragment = requirement.getResource();\n\t\tWiring fragmentWiring = wirings.get(fragment);\n\t\tList<Wire> fragmentWires = fragmentWiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);\n\t\tfor (Wire fragmentWire : fragmentWires) {\n\t\t\tResource host = fragmentWire.getProvider();\n\t\t\tWiring hostWiring = wirings.get(host);\n\t\t\tList<Wire> hostWires = hostWiring.getRequiredResourceWires(namespace);\n\t\t\tprocessWires(hostWires, requirement, capabilities);\n\t\t}\n\t}\n\tprivate void processWires(Collection<Wire> wires, Requirement requirement, List<Capability> capabilities) {\n\t\tfor (Wire wire : wires) {\n\t\t\tprocessWire(wire, requirement, capabilities);\n\t\t}\n\t}\n\tprivate void processWire(Wire wire, Requirement requirement, List<Capability> capabilities) {\n\t\tif (requirement.equals(wire.getRequirement())) {\n\t\t\tcapabilities.add(wire.getCapability());\n\t\t}\n\t}\n\tprivate void processCapability(Capability capability, Requirement requirement, List<Capability> capabilities) {\n\t\tif (ResourceHelper.matches(requirement, capability)) {\n\t\t\tcapabilities.add(capability);\n\t\t}\n\t}\n\tprivate void processResourceCapabilities(Collection<Capability> resourceCapabilities, Requirement requirement, List<Capability> capabilities) {\n\t\tfor (Capability resourceCapability : resourceCapabilities) {\n\t\t\tprocessCapability(resourceCapability, requirement, capabilities);\n\t\t}\n\t}\n\tprivate void processAsBundle(Requirement requirement, List<Capability> capabilities) {\n\t\tString namespace = requirement.getNamespace();\n\t\tResource bundle = requirement.getResource();\n\t\tWiring wiring = wirings.get(bundle);\n\t\tList<Wire> wires = wiring.getRequiredResourceWires(namespace);\n\t\tprocessWires(wires, requirement, capabilities);\n\t}\n<fim_suffix>\tprivate void processAsSubstitutableExport(boolean isFragment, Requirement requirement, List<Capability> capabilities) {\n\t\tString namespace = requirement.getNamespace();\n\t\tif (!PackageNamespace.PACKAGE_NAMESPACE.equals(namespace)) {\n\t\t\treturn;\n\t\t}\n\t\tResource resource = requirement.getResource();\n\t\tWiring wiring = wirings.get(resource);\n\t\tif (isFragment) {\n\t\t\tList<Wire> fragmentWires = wiring.getRequiredResourceWires(HostNamespace.HOST_NAMESPACE);\n\t\t\tfor (Wire fragmentWire : fragmentWires) {\n\t\t\t\tResource host = fragmentWire.getProvider();\n\t\t\t\tprocessResourceCapabilities(\n\t\t\t\t\t\twirings.get(host).getResourceCapabilities(namespace),\n\t\t\t\t\t\trequirement,\n\t\t\t\t\t\tcapabilities);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<Capability> resourceCapabilities = wiring.getResourceCapabilities(namespace);\n\t\t\tprocessResourceCapabilities(resourceCapabilities, requirement, capabilities);\n\t\t}\n\t}\n\tprivate void processAlreadyResolvedResource(Resource resource, Requirement requirement, List<Capability> capabilities) {\n\t\tboolean isFragment = isProcessableAsFragment(requirement);\n\t\tif (isFragment) {\n\t\t\tprocessAsFragment(requirement, capabilities);\n\t\t}\n\t\telse {\n\t\t\tprocessAsBundle(requirement, capabilities);\n\t\t}\n\t\tif (capabilities.isEmpty() && Utils.isMandatory(requirement)) {\n\t\t\tprocessAsSubstitutableExport(isFragment, requirement, capabilities);\n\t\t\tif (capabilities.isEmpty()) {\n\t\t\t\t// ARIES-1538. Do not fail subsystem resolution if an already\n\t\t\t\t// resolved resource has a missing dependency.\n\t\t\t\tcapabilities.add(new MissingCapability(requirement));\n\t\t\t}\n\t\t}\n\t}<fim_middle>// function below is feature envy\n"}