{"text": "<fim_prefix>  }\n  /** Creates a program that executes a sequence of programs. */\n  public static Program sequence(Program... programs) {\n    return new SequenceProgram(ImmutableList.copyOf(programs));\n  }\n  /** Creates a program that executes a list of rules in a HEP planner. */\n  public static Program hep(Iterable<? extends RelOptRule> rules,\n      boolean noDag, RelMetadataProvider metadataProvider) {\n    final HepProgramBuilder builder = HepProgram.builder();\n    for (RelOptRule rule : rules) {\n      builder.addRuleInstance(rule);\n    }\n    return of(builder.build(), noDag, metadataProvider);\n  }\n  /** Creates a program that executes a {@link HepProgram}. */\n  public static Program of(final HepProgram hepProgram, final boolean noDag,\n      final RelMetadataProvider metadataProvider) {\n    return (planner, rel, requiredOutputTraits, materializations, lattices) -> {\n      final HepPlanner hepPlanner = new HepPlanner(hepProgram,\n          null, noDag, null, RelOptCostImpl.FACTORY);\n      List<RelMetadataProvider> list = new ArrayList<>();\n      if (metadataProvider != null) {\n        list.add(metadataProvider);\n      }\n      hepPlanner.registerMetadataProviders(list);\n      RelMetadataProvider plannerChain =\n          ChainedRelMetadataProvider.of(list);\n      rel.getCluster().setMetadataProvider(plannerChain);\n      hepPlanner.setRoot(rel);\n      return hepPlanner.findBestExp();\n    };\n  }\n  /** Creates a program that invokes heuristic join-order optimization\n   * (via {@link org.apache.calcite.rel.rules.JoinToMultiJoinRule},\n   * {@link org.apache.calcite.rel.rules.MultiJoin} and\n   * {@link org.apache.calcite.rel.rules.LoptOptimizeJoinRule})\n   * if there are 6 or more joins (7 or more relations). */\n  public static Program heuristicJoinOrder(\n      final Iterable<? extends RelOptRule> rules,\n      final boolean bushy, final int minJoinCount) {\n    return (planner, rel, requiredOutputTraits, materializations, lattices) -> {\n      final int joinCount = RelOptUtil.countJoins(rel);\n      final Program program;\n      if (joinCount < minJoinCount) {\n        program = ofRules(rules);\n      } else {\n        // Create a program that gathers together joins as a MultiJoin.\n        final HepProgram hep = new HepProgramBuilder()\n            .addRuleInstance(FilterJoinRule.FILTER_ON_JOIN)\n            .addMatchOrder(HepMatchOrder.BOTTOM_UP)\n            .addRuleInstance(JoinToMultiJoinRule.INSTANCE)\n            .build();\n        final Program program1 =\n            of(hep, false, DefaultRelMetadataProvider.INSTANCE);\n        // Create a program that contains a rule to expand a MultiJoin\n        // into heuristically ordered joins.\n        // We use the rule set passed in, but remove JoinCommuteRule and\n        // JoinPushThroughJoinRule, because they cause exhaustive search.\n        final List<RelOptRule> list = Lists.newArrayList(rules);\n        list.removeAll(\n            ImmutableList.of(JoinCommuteRule.INSTANCE,\n                JoinAssociateRule.INSTANCE,\n                JoinPushThroughJoinRule.LEFT,\n                JoinPushThroughJoinRule.RIGHT));\n        list.add(bushy\n            ? MultiJoinOptimizeBushyRule.INSTANCE\n            : LoptOptimizeJoinRule.INSTANCE);\n        final Program program2 = ofRules(list);\n        program = sequence(program1, program2);\n      }\n      return program.run(\n          planner, rel, requiredOutputTraits, materializations, lattices);\n    };\n  }\n  public static Program calc(RelMetadataProvider metadataProvider) {\n    return hep(CALC_RULES, true, metadataProvider);\n  }\n  @Deprecated // to be removed before 2.0\n  public static Program subquery(RelMetadataProvider metadataProvider) {\n    return subQuery(metadataProvider);\n  }\n  public static Program subQuery(RelMetadataProvider metadataProvider) {\n    final HepProgramBuilder builder = HepProgram.builder();\n    builder.addRuleCollection(ImmutableList.of((RelOptRule) SubQueryRemoveRule.FILTER,\n        SubQueryRemoveRule.PROJECT,\n        SubQueryRemoveRule.JOIN));\n    return of(builder.build(), true, metadataProvider);\n  }\n  public static Program getProgram() {\n    return (planner, rel, requiredOutputTraits, materializations, lattices)\n        -> null;\n  }\n  /** Returns the standard program used by Prepare. */\n  public static Program standard() {\n    return standard(DefaultRelMetadataProvider.INSTANCE);\n  }\n  /** Returns the standard program with user metadata provider. */\n  public static Program standard(RelMetadataProvider metadataProvider) {\n    final Program program1 =\n        (planner, rel, requiredOutputTraits, materializations, lattices) -> {\n          planner.setRoot(rel);\n          for (RelOptMaterialization materialization : materializations) {\n            planner.addMaterialization(materialization);\n          }\n          for (RelOptLattice lattice : lattices) {\n            planner.addLattice(lattice);\n          }\n          final RelNode rootRel2 =\n              rel.getTraitSet().equals(requiredOutputTraits)\n                  ? rel\n                  : planner.changeTraits(rel, requiredOutputTraits);\n          assert rootRel2 != null;\n          planner.setRoot(rootRel2);\n          final RelOptPlanner planner2 = planner.chooseDelegate();\n          final RelNode rootRel3 = planner2.findBestExp();\n          assert rootRel3 != null : \"could not implement exp\";\n          return rootRel3;\n        };\n    return sequence(subQuery(metadataProvider),\n        new DecorrelateProgram(),\n        new TrimFieldsProgram(),\n        program1,\n        // Second planner pass to do physical \"tweaks\". This the first time\n        // that EnumerableCalcRel is introduced.\n        calc(metadataProvider));\n  }\n  /** Program backed by a {@link RuleSet}. */\n  static class RuleSetProgram implements Program {\n    final RuleSet ruleSet;\n    private RuleSetProgram(RuleSet ruleSet) {\n      this.ruleSet = ruleSet;\n    }\n    public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      planner.clear();\n      for (RelOptRule rule : ruleSet) {\n        planner.addRule(rule);\n      }\n      for (RelOptMaterialization materialization : materializations) {\n        planner.addMaterialization(materialization);\n      }\n      for (RelOptLattice lattice : lattices) {\n        planner.addLattice(lattice);\n      }\n      if (!rel.getTraitSet().equals(requiredOutputTraits)) {\n        rel = planner.changeTraits(rel, requiredOutputTraits);\n      }\n      planner.setRoot(rel);\n      return planner.findBestExp();\n    }\n  }\n  /** Program that runs sub-programs, sending the output of the previous as\n   * input to the next. */\n  private static class SequenceProgram implements Program {\n    private final ImmutableList<Program> programs;\n    SequenceProgram(ImmutableList<Program> programs) {\n      this.programs = programs;\n    }\n    public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      for (Program program : programs) {\n        rel = program.run(\n            planner, rel, requiredOutputTraits, materializations, lattices);\n      }\n      return rel;\n    }\n  }\n  /** Program that de-correlates a query.\n   *\n   * <p>To work around\n   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-842\">[CALCITE-842]\n   * Decorrelator gets field offsets confused if fields have been trimmed</a>,\n   * disable field-trimming in {@link SqlToRelConverter}, and run\n   * {@link TrimFieldsProgram} after this program. */\n<fim_suffix>  private static class DecorrelateProgram implements Program {\n    public RelNode run(RelOptPlanner planner, RelNode rel,\n        RelTraitSet requiredOutputTraits,\n        List<RelOptMaterialization> materializations,\n        List<RelOptLattice> lattices) {\n      final CalciteConnectionConfig config =\n          planner.getContext().unwrap(CalciteConnectionConfig.class);\n      if (config != null && config.forceDecorrelate()) {\n        final RelBuilder relBuilder =\n            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);\n        return RelDecorrelator.decorrelateQuery(rel, relBuilder);\n      }\n      return rel;\n    }\n  }<fim_middle>// class below has no smell\n"}