{"text": "<fim_prefix>         *  as possible implementations.\n         */\n        public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {\n            return implementation(origin, types, checkResult, implementation_filter);\n        }\n        // where\n            public static final Filter<Symbol> implementation_filter = s ->\n                    s.kind == MTH && (s.flags() & SYNTHETIC) == 0;\n        public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter<Symbol> implFilter) {\n            MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);\n            if (res != null)\n                return res;\n            // if origin is derived from a raw type, we might have missed\n            // an implementation because we do not know enough about instantiations.\n            // in this case continue with the supertype as origin.\n            if (types.isDerivedRaw(origin.type) && !origin.isInterface())\n                return implementation(types.supertype(origin.type).tsym, types, checkResult);\n            else\n                return null;\n        }\n        public List<VarSymbol> params() {\n            owner.complete();\n            if (params == null) {\n                ListBuffer<VarSymbol> newParams = new ListBuffer<>();\n                int i = 0;\n                for (Type t : type.getParameterTypes()) {\n                    Name paramName = name.table.fromString(\"arg\" + i);\n                    VarSymbol param = new VarSymbol(PARAMETER, paramName, t, this);\n                    newParams.append(param);\n                    i++;\n                }\n                params = newParams.toList();\n            }\n            Assert.checkNonNull(params);\n            return params;\n        }\n        public Symbol asMemberOf(Type site, Types types) {\n            return new MethodSymbol(flags_field, name, types.memberType(site, this), owner);\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public ElementKind getKind() {\n            if (name == name.table.names.init)\n                return ElementKind.CONSTRUCTOR;\n            else if (name == name.table.names.clinit)\n                return ElementKind.STATIC_INIT;\n            else if ((flags() & BLOCK) != 0)\n                return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;\n            else\n                return ElementKind.METHOD;\n        }\n        public boolean isStaticOrInstanceInit() {\n            return getKind() == ElementKind.STATIC_INIT ||\n                    getKind() == ElementKind.INSTANCE_INIT;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public Attribute getDefaultValue() {\n            return defaultValue;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public List<VarSymbol> getParameters() {\n            return params();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public boolean isVarArgs() {\n            return (flags() & VARARGS) != 0;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public boolean isDefault() {\n            return (flags() & DEFAULT) != 0;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public <R, P> R accept(ElementVisitor<R, P> v, P p) {\n            return v.visitExecutable(this, p);\n        }\n        public <R, P> R accept(Symbol.Visitor<R, P> v, P p) {\n            return v.visitMethodSymbol(this, p);\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type getReceiverType() {\n            return asType().getReceiverType();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type getReturnType() {\n            return asType().getReturnType();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public List<Type> getThrownTypes() {\n            return asType().getThrownTypes();\n        }\n    }\n    /** A class for invokedynamic method calls.\n     */\n    public static class DynamicMethodSymbol extends MethodSymbol {\n        public Object[] staticArgs;\n        public Symbol bsm;\n        public int bsmKind;\n        public DynamicMethodSymbol(Name name, Symbol owner, int bsmKind, MethodSymbol bsm, Type type, Object[] staticArgs) {\n            super(0, name, type, owner);\n            this.bsm = bsm;\n            this.bsmKind = bsmKind;\n            this.staticArgs = staticArgs;\n        }\n        @Override\n        public boolean isDynamic() {\n            return true;\n        }\n    }\n    /** A class for predefined operators.\n     */\n    public static class OperatorSymbol extends MethodSymbol {\n        public int opcode;\n        private int accessCode = Integer.MIN_VALUE;\n        public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {\n            super(PUBLIC | STATIC, name, type, owner);\n            this.opcode = opcode;\n        }\n        @Override\n        public <R, P> R accept(Symbol.Visitor<R, P> v, P p) {\n            return v.visitOperatorSymbol(this, p);\n        }\n        public int getAccessCode(Tag tag) {\n            if (accessCode != Integer.MIN_VALUE && !tag.isIncOrDecUnaryOp()) {\n                return accessCode;\n            }\n            accessCode = AccessCode.from(tag, opcode);\n            return accessCode;\n        }\n        /** Access codes for dereferencing, assignment,\n         *  and pre/post increment/decrement.\n         *  All access codes for accesses to the current class are even.\n         *  If a member of the superclass should be accessed instead (because\n         *  access was via a qualified super), add one to the corresponding code\n         *  for the current class, making the number odd.\n         *  This numbering scheme is used by the backend to decide whether\n         *  to issue an invokevirtual or invokespecial call.\n         *\n         *  @see Gen#visitSelect(JCFieldAccess tree)\n         */\n        public enum AccessCode {\n            UNKNOWN(-1, Tag.NO_TAG),\n            DEREF(0, Tag.NO_TAG),\n            ASSIGN(2, Tag.ASSIGN),\n            PREINC(4, Tag.PREINC),\n            PREDEC(6, Tag.PREDEC),\n            POSTINC(8, Tag.POSTINC),\n            POSTDEC(10, Tag.POSTDEC),\n            FIRSTASGOP(12, Tag.NO_TAG);\n            public final int code;\n            public final Tag tag;\n            public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;\n            AccessCode(int code, Tag tag) {\n                this.code = code;\n                this.tag = tag;\n            }\n            static public AccessCode getFromCode(int code) {\n                for (AccessCode aCodes : AccessCode.values()) {\n                    if (aCodes.code == code) {\n                        return aCodes;\n                    }\n                }\n                return UNKNOWN;\n            }\n            static int from(Tag tag, int opcode) {\n                /** Map bytecode of binary operation to access code of corresponding\n                *  assignment operation. This is always an even number.\n                */\n                switch (tag) {\n                    case PREINC:\n                        return AccessCode.PREINC.code;\n                    case PREDEC:\n                        return AccessCode.PREDEC.code;\n                    case POSTINC:\n                        return AccessCode.POSTINC.code;\n                    case POSTDEC:\n                        return AccessCode.POSTDEC.code;\n                }\n                if (iadd <= opcode && opcode <= lxor) {\n                    return (opcode - iadd) * 2 + FIRSTASGOP.code;\n                } else if (opcode == string_add) {\n                    return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;\n                } else if (ishll <= opcode && opcode <= lushrl) {\n                    return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;\n                }\n                return -1;\n            }\n        }\n    }\n    /** Symbol completer interface.\n     */\n<fim_suffix>    public static interface Completer {\n        /** Dummy completer to be used when the symbol has been completed or\n         * does not need completion.\n         */\n        public final static Completer NULL_COMPLETER = new Completer() {\n            public void complete(Symbol sym) { }\n            public boolean isTerminal() { return true; }\n        };\n        void complete(Symbol sym) throws CompletionFailure;\n        /** Returns true if this completer is <em>terminal</em>. A terminal\n         * completer is used as a place holder when the symbol is completed.\n         * Calling complete on a terminal completer will not affect the symbol.\n         *\n         * The dummy NULL_COMPLETER and the GraphDependencies completer are\n         * examples of terminal completers.\n         *\n         * @return true iff this completer is terminal\n         */\n        default boolean isTerminal() {\n            return false;\n        }\n    }<fim_middle>// class below has no smell\n"}