{"text": "<fim_prefix>    // map from sink processor names to subscribed topic (without application-id prefix for internal topics)\n    private final Map<String, String> nodeToSinkTopic = new HashMap<>();\n    // map from topics to their matched regex patterns, this is to ensure one topic is passed through on source node\n    // even if it can be matched by multiple regex patterns\n    private final Map<String, Pattern> topicToPatterns = new HashMap<>();\n    // map from state store names to all the topics subscribed from source processors that\n    // are connected to these state stores\n    private final Map<String, Set<String>> stateStoreNameToSourceTopics = new HashMap<>();\n    // map from state store names to all the regex subscribed topics from source processors that\n    // are connected to these state stores\n    private final Map<String, Set<Pattern>> stateStoreNameToSourceRegex = new HashMap<>();\n    // map from state store names to this state store's corresponding changelog topic if possible\n    private final Map<String, String> storeToChangelogTopic = new HashMap<>();\n    // all global topics\n    private final Set<String> globalTopics = new HashSet<>();\n    private final Set<String> earliestResetTopics = new HashSet<>();\n    private final Set<String> latestResetTopics = new HashSet<>();\n    private final Set<Pattern> earliestResetPatterns = new HashSet<>();\n    private final Set<Pattern> latestResetPatterns = new HashSet<>();\n    private final QuickUnion<String> nodeGrouper = new QuickUnion<>();\n    private SubscriptionUpdates subscriptionUpdates = new SubscriptionUpdates();\n    private String applicationId = null;\n    private Pattern topicPattern = null;\n    private Map<Integer, Set<String>> nodeGroups = null;\n    // TODO: this is only temporary for 2.0 and should be removed\n    private final Map<StoreBuilder, String> storeToSourceChangelogTopic = new HashMap<>();\n    public static class StateStoreFactory {\n        private final StoreBuilder builder;\n        private final Set<String> users = new HashSet<>();\n        private StateStoreFactory(final StoreBuilder<?> builder) {\n            this.builder = builder;\n        }\n        public StateStore build() {\n            return builder.build();\n        }\n        long retentionPeriod() {\n            if (builder instanceof WindowStoreBuilder) {\n                return ((WindowStoreBuilder) builder).retentionPeriod();\n            } else if (builder instanceof TimestampedWindowStoreBuilder) {\n                return ((TimestampedWindowStoreBuilder) builder).retentionPeriod();\n            } else if (builder instanceof SessionStoreBuilder) {\n                return ((SessionStoreBuilder) builder).retentionPeriod();\n            } else {\n                throw new IllegalStateException(\"retentionPeriod is not supported when not a window store\");\n            }\n        }\n        private Set<String> users() {\n            return users;\n        }\n        public boolean loggingEnabled() {\n            return builder.loggingEnabled();\n        }\n        private String name() {\n            return builder.name();\n        }\n        private boolean isWindowStore() {\n            return builder instanceof WindowStoreBuilder\n                || builder instanceof TimestampedWindowStoreBuilder\n                || builder instanceof SessionStoreBuilder;\n        }\n        // Apparently Java strips the generics from this method because we're using the raw type for builder,\n        // even though this method doesn't use builder's (missing) type parameter. Our usage seems obviously\n        // correct, though, hence the suppression.\n        @SuppressWarnings(\"unchecked\")\n        private Map<String, String> logConfig() {\n            return builder.logConfig();\n        }\n    }\n    private static abstract class NodeFactory {\n        final String name;\n        final String[] predecessors;\n        NodeFactory(final String name,\n                    final String[] predecessors) {\n            this.name = name;\n            this.predecessors = predecessors;\n        }\n        public abstract ProcessorNode build();\n        abstract AbstractNode describe();\n    }\n    private static class ProcessorNodeFactory extends NodeFactory {\n        private final ProcessorSupplier<?, ?> supplier;\n        private final Set<String> stateStoreNames = new HashSet<>();\n        ProcessorNodeFactory(final String name,\n                             final String[] predecessors,\n                             final ProcessorSupplier<?, ?> supplier) {\n            super(name, predecessors.clone());\n            this.supplier = supplier;\n        }\n        public void addStateStore(final String stateStoreName) {\n            stateStoreNames.add(stateStoreName);\n        }\n        @Override\n        public ProcessorNode build() {\n            return new ProcessorNode<>(name, supplier.get(), stateStoreNames);\n        }\n        @Override\n        Processor describe() {\n            return new Processor(name, new HashSet<>(stateStoreNames));\n        }\n    }\n    private class SourceNodeFactory extends NodeFactory {\n        private final List<String> topics;\n        private final Pattern pattern;\n        private final Deserializer<?> keyDeserializer;\n        private final Deserializer<?> valDeserializer;\n        private final TimestampExtractor timestampExtractor;\n        private SourceNodeFactory(final String name,\n                                  final String[] topics,\n                                  final Pattern pattern,\n                                  final TimestampExtractor timestampExtractor,\n                                  final Deserializer<?> keyDeserializer,\n                                  final Deserializer<?> valDeserializer) {\n            super(name, NO_PREDECESSORS);\n            this.topics = topics != null ? Arrays.asList(topics) : new ArrayList<>();\n            this.pattern = pattern;\n            this.keyDeserializer = keyDeserializer;\n            this.valDeserializer = valDeserializer;\n            this.timestampExtractor = timestampExtractor;\n        }\n        List<String> getTopics(final Collection<String> subscribedTopics) {\n            // if it is subscribed via patterns, it is possible that the topic metadata has not been updated\n            // yet and hence the map from source node to topics is stale, in this case we put the pattern as a place holder;\n            // this should only happen for debugging since during runtime this function should always be called after the metadata has updated.\n            if (subscribedTopics.isEmpty()) {\n                return Collections.singletonList(String.valueOf(pattern));\n            }\n            final List<String> matchedTopics = new ArrayList<>();\n            for (final String update : subscribedTopics) {\n                if (pattern == topicToPatterns.get(update)) {\n                    matchedTopics.add(update);\n                } else if (topicToPatterns.containsKey(update) && isMatch(update)) {\n                    // the same topic cannot be matched to more than one pattern\n                    // TODO: we should lift this requirement in the future\n                    throw new TopologyException(\"Topic \" + update +\n                        \" is already matched for another regex pattern \" + topicToPatterns.get(update) +\n                        \" and hence cannot be matched to this regex pattern \" + pattern + \" any more.\");\n                } else if (isMatch(update)) {\n                    topicToPatterns.put(update, pattern);\n                    matchedTopics.add(update);\n                }\n            }\n            return matchedTopics;\n        }\n        @Override\n        public ProcessorNode build() {\n            final List<String> sourceTopics = nodeToSourceTopics.get(name);\n            // if it is subscribed via patterns, it is possible that the topic metadata has not been updated\n            // yet and hence the map from source node to topics is stale, in this case we put the pattern as a place holder;\n            // this should only happen for debugging since during runtime this function should always be called after the metadata has updated.\n            if (sourceTopics == null) {\n                return new SourceNode<>(name, Collections.singletonList(String.valueOf(pattern)), timestampExtractor, keyDeserializer, valDeserializer);\n            } else {\n                return new SourceNode<>(name, maybeDecorateInternalSourceTopics(sourceTopics), timestampExtractor, keyDeserializer, valDeserializer);\n            }\n        }\n        private boolean isMatch(final String topic) {\n            return pattern.matcher(topic).matches();\n        }\n        @Override\n        Source describe() {\n            return new Source(name, new HashSet<>(topics), pattern);\n        }\n    }\n<fim_suffix>    private class SinkNodeFactory<K, V> extends NodeFactory {\n        private final Serializer<K> keySerializer;\n        private final Serializer<V> valSerializer;\n        private final StreamPartitioner<? super K, ? super V> partitioner;\n        private final TopicNameExtractor<K, V> topicExtractor;\n        private SinkNodeFactory(final String name,\n                                final String[] predecessors,\n                                final TopicNameExtractor<K, V> topicExtractor,\n                                final Serializer<K> keySerializer,\n                                final Serializer<V> valSerializer,\n                                final StreamPartitioner<? super K, ? super V> partitioner) {\n            super(name, predecessors.clone());\n            this.topicExtractor = topicExtractor;\n            this.keySerializer = keySerializer;\n            this.valSerializer = valSerializer;\n            this.partitioner = partitioner;\n        }\n        @Override\n        public ProcessorNode build() {\n            if (topicExtractor instanceof StaticTopicNameExtractor) {\n                final String topic = ((StaticTopicNameExtractor) topicExtractor).topicName;\n                if (internalTopicNames.contains(topic)) {\n                    // prefix the internal topic name with the application id\n                    return new SinkNode<>(name, new StaticTopicNameExtractor<>(decorateTopic(topic)), keySerializer, valSerializer, partitioner);\n                } else {\n                    return new SinkNode<>(name, topicExtractor, keySerializer, valSerializer, partitioner);\n                }\n            } else {\n                return new SinkNode<>(name, topicExtractor, keySerializer, valSerializer, partitioner);\n            }\n        }\n        @Override\n        Sink describe() {\n            return new Sink(name, topicExtractor);\n        }\n    }<fim_middle>// class below has no smell\n"}