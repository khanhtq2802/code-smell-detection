{"text": "<fim_prefix>            // these are *not* true because some elements need not have vaddr\n            // assert firstElementByOffset == firstSectionByVaddr;\n            // assert lastElementByOffset == lastSectionByVaddr;\n            // -- FIXME: find out a sensible assertion that should be true along these lines\n            int fileOffset = (firstElementByOffset == null) ? 0 : (int) alreadyDecided.get(firstElementByOffset).getDecidedValue(LayoutDecision.Kind.OFFSET);\n            int maxOffset = (maxOffsetDecision == null) ? 0 : ((int) maxOffsetDecision.getValue() + (int) alreadyDecided.get(maxOffsetDecision.getElement()).getDecidedValue(LayoutDecision.Kind.SIZE));\n            int fileSize = maxOffset - minOffset;\n            int effectiveMinVaddr = segmentVaddrGivenFirstSectionVaddr(minVaddr);\n            assert effectiveMinVaddr >= 0;\n            /* If this is wrong, it means that 4KB was not enough padding in initialVaddr(). */\n            int prePadding = minVaddr - effectiveMinVaddr;\n            int effectiveVmSize = vmSize + prePadding;\n            int effectiveFileOffset = fileOffset - prePadding;\n            int effectiveFileSize = fileSize + prePadding;\n            db.write8Byte(effectiveMinVaddr);\n            db.write8Byte(effectiveVmSize);\n            db.write8Byte(effectiveFileOffset);\n            /*\n             * Round up effectiveFileSize to the nearest page boundary, to match what the stock\n             * tools do. BUT: ARGH:\n             *\n             * 1. the loader complains if this extends beyond end-of-file\n             *\n             * 2. the tools don't do this for the __LINKEDIT segment\n             *\n             * Approximate this by\n             *\n             * - skipping the round-up for the link edit segment\n             *\n             * - when we do round up, record a \"minimum file size\"...\n             *\n             * - ... and zero-pad the file to this length.\n             */\n            if (this != getLinkEditSegment()) {\n                effectiveFileSize = ObjectFile.nextIntegerMultiple(effectiveFileSize, getPageSize());\n                minimumFileSize = Math.max(minimumFileSize, effectiveFileOffset + effectiveFileSize);\n            }\n            db.write8Byte(effectiveFileSize);\n            db.write4Byte((int) ObjectFile.flagSetAsLong(maxprot));\n            db.write4Byte((int) ObjectFile.flagSetAsLong(initprot));\n            int sectionCountPos = db.pos();\n            db.write4Byte(0); // placeholder for section count\n            db.write4Byte(flags); // *segment* flags\n            db.align(8);\n            int sectionCount = 0;\n            for (Element el : elementsInSegment) {\n                // non-Section elements don't get an info struct!\n                if (!(el instanceof Section)) {\n                    continue;\n                }\n                ++sectionCount;\n                MachOSection s = (MachOSection) el;\n                int logAlignment = (int) (Math.log10(s.getAlignment()) / Math.log10(2.0));\n                /*\n                 * Find the LinkEditElement, if any, that contains our relocation records. We only\n                 * do this is we're a relocatable file. Dynamic relocs are indexed differently, from\n                 * fields in the LC_DYSYMTAB load command.\n                 */\n                MachORelocationElement ourRelocs = null;\n                if (getLinkEditSegment() != null) {\n                    for (Element e : getLinkEditSegment().elementsInSegment) {\n                        if (e instanceof MachORelocationElement && ((MachORelocationElement) e).relocatesSegment(this)) {\n                            if (ourRelocs == null) {\n                                ourRelocs = (MachORelocationElement) e;\n                                continue;\n                            }\n                            assert false; // i.e. we should not find *another* RelocationElement\n                                          // also containing relevant relocs\n                        }\n                    }\n                }\n                /*\n                 * If we're a a relocatable file, we should have a destination segment name. An\n                 * initial value is guessed in the MachOSection constructor.\n                 */\n                assert s.destinationSegmentName != null;\n                //@formatter:off\n                SectionInfoStruct si = new SectionInfoStruct(\n                    s.getName(),\n                    s.destinationSegmentName,\n                    s.getElement().isReferenceable() ? (int) alreadyDecided.get(s).getDecidedValue(LayoutDecision.Kind.VADDR) : 0,\n                    (int) alreadyDecided.get(s).getDecidedValue(LayoutDecision.Kind.SIZE),\n                    (int) alreadyDecided.get(s).getDecidedValue(LayoutDecision.Kind.OFFSET),\n                    logAlignment,\n                    ourRelocs == null ? 0 : (int) alreadyDecided.get(ourRelocs).getDecidedValue(LayoutDecision.Kind.OFFSET) + ourRelocs.startIndexFor(s) * ourRelocs.encodedEntrySize(),\n                    ourRelocs == null ? 0 : ourRelocs.countFor(s),\n                    (int) ObjectFile.flagSetAsLong(s.flags) | s.type.getValue(),\n                    /* reserved1 */ 0,\n                    /* reserved2 */ 0);\n                //@formatter:on\n                int startPos = db.pos();\n                si.write(db);\n                assert db.pos() - startPos == SectionInfoStruct.DEFAULT_SIZE;\n            }\n            // go back and fill in the actual section count\n            db.pushSeek(sectionCountPos);\n            db.write4Byte(sectionCount);\n            db.pop();\n        }\n        private int sectionsInSegment() {\n            int count = 0;\n            for (Element e : elementsInSegment) {\n                if (e instanceof Section) {\n                    ++count;\n                }\n            }\n            return count;\n        }\n        @Override\n        public int getOrDecideSize(Map<Element, LayoutDecisionMap> alreadyDecided, int sizeHint) {\n            // FIXME: please....\n            return 4 + 4 + 16 + 8 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + (sectionsInSegment() * SectionInfoStruct.DEFAULT_SIZE);\n        }\n        @Override\n        public Iterable<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n            // 'minimal' means that our size does not depend on our bytewise-encoded content\n            HashSet<BuildDependency> deps = ObjectFile.minimalDependencies(decisions, this);\n            // our content depends on the offset and size of every section we contain\n            LayoutDecision ourContent = decisions.get(this).getDecision(LayoutDecision.Kind.CONTENT);\n            for (Element s : elementsInSegment) {\n                deps.add(BuildDependency.createOrGet(ourContent, decisions.get(s).getDecision(LayoutDecision.Kind.SIZE)));\n                deps.add(BuildDependency.createOrGet(ourContent, decisions.get(s).getDecision(LayoutDecision.Kind.OFFSET)));\n                // our content also depends on the vaddr of every loadable section\n                // (because we record the vmsize in the segment header)\n                if (s.getElement().isReferenceable()) {\n                    deps.add(BuildDependency.createOrGet(ourContent, decisions.get(s).getDecision(LayoutDecision.Kind.VADDR)));\n                }\n            }\n            // if (sections.size() > 0) {\n            // deps.add(new BuildDependency(ourContent,\n            // decisions.get(sections.get(sections.size() -\n            // 1)).getDecision(LayoutProperty.Kind.SIZE)));\n            // }\n            /*\n             * If our name is \"__LINKEDIT\", we're special: it means we have to come last. The way we\n             * ensure this is to only create such segments at the *last* position in the segments\n             * list, and to preserve this positioning as new segments are added. We just assert that\n             * here. See loadCommands.\n             */\n            if ((getName() != null) && (getName().equals(\"__LINKEDIT\"))) {\n                assert this == loadCommands.linkEditCommand;\n            } else {\n                /*\n                 * We also depend on the offset of any relocation element containing relocation\n                 * records for our content.\n                 */\n                if (getLinkEditSegment() != null) {\n                    for (Element e : getLinkEditSegment().elementsInSegment) {\n                        if (e instanceof MachORelocationElement && ((MachORelocationElement) e).relocatesSegment(this)) {\n                            // we depend on its offset\n                            deps.add(BuildDependency.createOrGet(ourContent, decisions.get(e).getDecision(LayoutDecision.Kind.OFFSET)));\n                        }\n                    }\n                }\n            }\n            return deps;\n        }\n<fim_suffix>        @Override\n        public void add(int arg0, Element arg1) {\n            elementsInSegment.add(arg0, arg1);\n        }<fim_middle>// function below has no smell\n"}