{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.index;\n\n\nimport org.apache.lucene.index.DocumentsWriterPerThreadPool.ThreadState;\n\n/**\n * Default {@link FlushPolicy} implementation that flushes new segments based on\n * RAM used and document count depending on the IndexWriter's\n * {@link IndexWriterConfig}. It also applies pending deletes based on the\n * number of buffered delete terms.\n * \n * <ul>\n * <li>\n * {@link #onDelete(DocumentsWriterFlushControl, DocumentsWriterPerThreadPool.ThreadState)}\n * - applies pending delete operations based on the global number of buffered\n * delete terms if the consumed memory is greater than {@link IndexWriterConfig#getRAMBufferSizeMB()}</li>.\n * <li>\n * {@link #onInsert(DocumentsWriterFlushControl, DocumentsWriterPerThreadPool.ThreadState)}\n * - flushes either on the number of documents per\n * {@link DocumentsWriterPerThread} (\n * {@link DocumentsWriterPerThread#getNumDocsInRAM()}) or on the global active\n * memory consumption in the current indexing session iff\n * {@link IndexWriterConfig#getMaxBufferedDocs()} or\n * {@link IndexWriterConfig#getRAMBufferSizeMB()} is enabled respectively</li>\n * <li>\n * {@link #onUpdate(DocumentsWriterFlushControl, DocumentsWriterPerThreadPool.ThreadState)}\n * - calls\n * {@link #onInsert(DocumentsWriterFlushControl, DocumentsWriterPerThreadPool.ThreadState)}\n * and\n * {@link #onDelete(DocumentsWriterFlushControl, DocumentsWriterPerThreadPool.ThreadState)}\n * in order</li>\n * </ul>\n * All {@link IndexWriterConfig} settings are used to mark\n * {@link DocumentsWriterPerThread} as flush pending during indexing with\n * respect to their live updates.\n * <p>\n * If {@link IndexWriterConfig#setRAMBufferSizeMB(double)} is enabled, the\n * largest ram consuming {@link DocumentsWriterPerThread} will be marked as\n * pending iff the global active RAM consumption is {@code >=} the configured max RAM\n * buffer.\n */\nclass FlushByRamOrCountsPolicy extends FlushPolicy {\n\n  @Override\n  public void onDelete(DocumentsWriterFlushControl control, ThreadState state) {\n    if ((flushOnRAM() && control.getDeleteBytesUsed() > 1024*1024*indexWriterConfig.getRAMBufferSizeMB())) {\n      control.setApplyAllDeletes();\n      if (infoStream.isEnabled(\"FP\")) {\n        infoStream.message(\"FP\", \"force apply deletes bytesUsed=\" + control.getDeleteBytesUsed() + \" vs ramBufferMB=\" + indexWriterConfig.getRAMBufferSizeMB());\n      }\n    }\n  }\n\n  @Override\n  public void onInsert(DocumentsWriterFlushControl control, ThreadState state) {\n    if (flushOnDocCount()\n        && state.dwpt.getNumDocsInRAM() >= indexWriterConfig\n            .getMaxBufferedDocs()) {\n      // Flush this state by num docs\n      control.setFlushPending(state);\n    } else if (flushOnRAM()) {// flush by RAM\n      final long limit = (long) (indexWriterConfig.getRAMBufferSizeMB() * 1024.d * 1024.d);\n      final long totalRam = control.activeBytes() + control.getDeleteBytesUsed();\n      if (totalRam >= limit) {\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"trigger flush: activeBytes=\" + control.activeBytes() + \" deleteBytes=\" + control.getDeleteBytesUsed() + \" vs limit=\" + limit);\n        }\n        markLargestWriterPending(control, state, totalRam);\n      }\n    }\n  }\n  \n  /**\n   * Marks the most ram consuming active {@link DocumentsWriterPerThread} flush\n   * pending\n   */\n<fim_suffix>  protected void markLargestWriterPending(DocumentsWriterFlushControl control,\n      ThreadState perThreadState, final long currentBytesPerThread) {\n    ThreadState largestNonPendingWriter = findLargestNonPendingWriter(control, perThreadState);\n    if (largestNonPendingWriter != null) {\n      control.setFlushPending(largestNonPendingWriter);\n    }\n  }\n  \n  /**\n   * Returns <code>true</code> if this {@link FlushPolicy} flushes on\n   * {@link IndexWriterConfig#getMaxBufferedDocs()}, otherwise\n   * <code>false</code>.\n   */\n  protected boolean flushOnDocCount() {\n    return indexWriterConfig.getMaxBufferedDocs() != IndexWriterConfig.DISABLE_AUTO_FLUSH;\n  }\n\n  /**\n   * Returns <code>true</code> if this {@link FlushPolicy} flushes on\n   * {@link IndexWriterConfig#getRAMBufferSizeMB()}, otherwise\n   * <code>false</code>.\n   */\n  protected boolean flushOnRAM() {\n    return indexWriterConfig.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH;\n  }\n}<fim_middle>// function below has no smell\n"}