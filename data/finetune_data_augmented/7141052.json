{"text": "<fim_prefix>    private static final String PATH_SEPARATOR = \"/\";\n    private ISourceContainer[] sourceContainers = null;\n    private HashMap<String, Object> options = new HashMap<String, Object>();\n    @Override\n    public void initialize(IDebugAdapterContext context, Map<String, Object> props) {\n        if (props == null) {\n            throw new IllegalArgumentException(\"argument is null\");\n        }\n        options.putAll(props);\n        // During initialization, trigger a background job to load the source containers to improve the perf.\n        new Thread(() -> {\n            getSourceContainers();\n        }).start();\n    }\n    @Override\n    public boolean supportsRealtimeBreakpointVerification() {\n        return true;\n    }\n    /**\n     * For a given source file and a list of line locations, return the fully\n     * qualified names of the type of the line location. If the line location points\n     * an empty line or invalid line, it returns a null fully qualified name.\n     */\n    @Override\n    public String[] getFullyQualifiedName(String uri, int[] lines, int[] columns) throws DebugException {\n        if (uri == null) {\n            throw new IllegalArgumentException(\"sourceFilePath is null\");\n        }\n        if (lines == null) {\n            throw new IllegalArgumentException(\"lines is null\");\n        }\n        if (columns == null) {\n            columns = new int[lines.length];\n        } else if (lines.length != columns.length) {\n            throw new IllegalArgumentException(\"the count of lines and columns don't match!\");\n        }\n        if (lines.length == 0) {\n            return new String[0];\n        }\n        // Currently the highest version the debugger supports is Java SE 9 Edition (JLS9).\n        final ASTParser parser = ASTParser.newParser(AST.JLS9);\n        parser.setResolveBindings(true);\n        parser.setBindingsRecovery(true);\n        parser.setStatementsRecovery(true);\n        CompilationUnit astUnit = null;\n        String filePath = AdapterUtils.toPath(uri);\n        // For file uri, read the file contents directly and pass them to the ast parser.\n        if (filePath != null && Files.isRegularFile(Paths.get(filePath))) {\n            Charset cs = (Charset) this.options.get(Constants.DEBUGGEE_ENCODING);\n            if (cs == null) {\n                cs = Charset.defaultCharset();\n            }\n            String source = readFile(filePath, cs);\n            parser.setSource(source.toCharArray());\n            /**\n             * See the java doc for { @link ASTParser#setResolveBindings(boolean) }.\n             * Binding information is obtained from the Java model. This means that the compilation unit must be located relative to the Java model.\n             * This happens automatically when the source code comes from either setSource(ICompilationUnit) or setSource(IClassFile).\n             * When source is supplied by setSource(char[]), the location must be established explicitly\n             * by setting an environment using setProject(IJavaProject) or setEnvironment(String [], String [], String [], boolean)\n             * and a unit name setUnitName(String).\n             */\n            parser.setEnvironment(new String[0], new String[0], null, true);\n            parser.setUnitName(Paths.get(filePath).getFileName().toString());\n            /**\n             * See the java doc for { @link ASTParser#setSource(char[]) },\n             * the user need specify the compiler options explicitly.\n             */\n            Map<String, String> javaOptions = JavaCore.getOptions();\n            javaOptions.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_9);\n            javaOptions.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_9);\n            javaOptions.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_9);\n            parser.setCompilerOptions(javaOptions);\n            astUnit = (CompilationUnit) parser.createAST(null);\n        } else {\n            // For non-file uri (e.g. jdt://contents/rt.jar/java.io/PrintStream.class),\n            // leverage jdt to load the source contents.\n            ITypeRoot typeRoot = resolveClassFile(uri);\n            if (typeRoot != null) {\n                parser.setSource(typeRoot);\n                astUnit = (CompilationUnit) parser.createAST(null);\n            }\n        }\n        String[] fqns = new String[lines.length];\n        if (astUnit != null) {\n            for (int i = 0; i < lines.length; i++) {\n                // TODO\n                // The ValidBreakpointLocationLocator will verify if the current line is a valid location or not.\n                // If so, it will return the fully qualified name of the class type that contains the current line.\n                // Otherwise, it will try to find a valid location from the next lines and return it's fully qualified name.\n                // In current stage, we don't support to move the invalid breakpoint down to the next valid location, and just\n                // mark it as \"unverified\".\n                // In future, we could consider supporting to update the breakpoint to a valid location.\n                ValidBreakpointLocationLocator locator = new ValidBreakpointLocationLocator(astUnit, lines[i], true, true);\n                astUnit.accept(locator);\n                // When the final valid line location is same as the original line, that represents it's a valid breakpoint.\n                // Add location type check to avoid breakpoint on method/field which will never be hit in current implementation.\n                if (lines[i] == locator.getLineLocation() && locator.getLocationType() == ValidBreakpointLocationLocator.LOCATION_LINE) {\n                    fqns[i] = locator.getFullyQualifiedTypeName();\n                }\n            }\n        }\n        return fqns;\n    }\n    @Override\n    public String getSourceFileURI(String fullyQualifiedName, String sourcePath) {\n        if (sourcePath == null) {\n            return null;\n        }\n        Object sourceElement = JdtUtils.findSourceElement(sourcePath, getSourceContainers());\n        if (sourceElement instanceof IResource) {\n            return getFileURI((IResource) sourceElement);\n        } else if (sourceElement instanceof IClassFile) {\n            try {\n                IClassFile file = (IClassFile) sourceElement;\n                if (file.getBuffer() != null) {\n                    return getFileURI(file);\n                }\n            } catch (JavaModelException e) {\n                // do nothing.\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the project associated source containers.\n     * @return the initialized source container list\n     */\n    public synchronized ISourceContainer[] getSourceContainers() {\n        if (sourceContainers == null) {\n            sourceContainers = JdtUtils.getSourceContainers((String) options.get(Constants.PROJECT_NAME));\n        }\n        return sourceContainers;\n    }\n    @Override\n    public String getSourceContents(String uri) {\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        IClassFile cf = resolveClassFile(uri);\n        return getContents(cf);\n    }\n    private String getContents(IClassFile cf) {\n        String source = null;\n        if (cf != null) {\n            try {\n                IBuffer buffer = cf.getBuffer();\n                if (buffer != null) {\n                    source = buffer.getContents();\n                }\n            } catch (JavaModelException e) {\n                logger.log(Level.SEVERE, String.format(\"Failed to parse the source contents of the class file: %s\", e.toString()), e);\n            }\n            if (source == null) {\n                source = \"\";\n            }\n        }\n        return source;\n    }\n    private static String getFileURI(IClassFile classFile) {\n        String packageName = classFile.getParent().getElementName();\n        String jarName = classFile.getParent().getParent().getElementName();\n        try {\n            return new URI(JDT_SCHEME, \"contents\", PATH_SEPARATOR + jarName + PATH_SEPARATOR + packageName\n                    + PATH_SEPARATOR + classFile.getElementName(), classFile.getHandleIdentifier(), null)\n                            .toASCIIString();\n        } catch (URISyntaxException e) {\n            return null;\n        }\n    }\n    private static String getFileURI(IResource resource) {\n        URI uri = resource.getLocationURI();\n        if (uri != null) {\n            // If the file path contains non ASCII characters, encode the result.\n            String uriString = uri.toASCIIString();\n            // Fix uris by adding missing // to single file:/ prefix.\n            return uriString.replaceFirst(\"file:/([^/])\", \"file:///$1\");\n        }\n        return null;\n    }\n<fim_suffix>    private static IClassFile resolveClassFile(String uriString) {\n        if (uriString == null || uriString.isEmpty()) {\n            return null;\n        }\n        try {\n            URI uri = new URI(uriString);\n            if (uri != null && JDT_SCHEME.equals(uri.getScheme()) && \"contents\".equals(uri.getAuthority())) {\n                String handleId = uri.getQuery();\n                IJavaElement element = JavaCore.create(handleId);\n                IClassFile cf = (IClassFile) element.getAncestor(IJavaElement.CLASS_FILE);\n                return cf;\n            }\n        } catch (URISyntaxException e) {\n            // ignore\n        }\n        return null;\n    }<fim_middle>// function below has no smell\n"}