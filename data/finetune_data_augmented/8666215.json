{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.query.h2;\n\nimport java.lang.reflect.Field;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.NoSuchElementException;\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.internal.processors.query.IgniteSQLException;\nimport org.apache.ignite.internal.processors.query.h2.opt.GridH2ValueCacheObject;\nimport org.apache.ignite.internal.util.GridCloseableIteratorAdapter;\nimport org.apache.ignite.internal.util.typedef.internal.S;\nimport org.h2.jdbc.JdbcResultSet;\nimport org.h2.result.ResultInterface;\nimport org.h2.value.Value;\n\n/**\n * Iterator over result set.\n */\npublic abstract class H2ResultSetIterator<T> extends GridCloseableIteratorAdapter<T> {\n    /** */\n    private static final Field RESULT_FIELD;\n\n    /*\n     * Initialize.\n     */\n    static {\n        try {\n            RESULT_FIELD = JdbcResultSet.class.getDeclaredField(\"result\");\n\n            RESULT_FIELD.setAccessible(true);\n        }\n        catch (NoSuchFieldException e) {\n            throw new IllegalStateException(\"Check H2 version in classpath.\", e);\n        }\n    }\n\n    /** */\n    private static final long serialVersionUID = 0L;\n\n    /** */\n    private ResultInterface res;\n\n    /** */\n    private ResultSet data;\n\n    /** */\n    protected final Object[] row;\n\n    /** */\n    private boolean hasRow;\n\n    /**\n     * @param data Data array.\n     * @param forUpdate Whether is result is one of {@code SELECT FOR UPDATE} query.\n     * @throws IgniteCheckedException If failed.\n     */\n    protected H2ResultSetIterator(ResultSet data, boolean forUpdate) throws IgniteCheckedException {\n        this.data = data;\n\n        try {\n            res = (ResultInterface)RESULT_FIELD.get(data);\n        }\n        catch (IllegalAccessException e) {\n            throw new IllegalStateException(e); // Must not happen.\n        }\n\n        if (data != null) {\n            try {\n                int colsCnt = data.getMetaData().getColumnCount();\n\n                row = new Object[forUpdate ? colsCnt - 1 : colsCnt];\n            }\n            catch (SQLException e) {\n                throw new IgniteCheckedException(e);\n            }\n        }\n        else\n            row = null;\n    }\n\n    /**\n     * @return {@code true} If next row was fetched successfully.\n     */\n<fim_suffix>    private boolean fetchNext() throws IgniteCheckedException {\n        if (data == null)\n            return false;\n\n        try {\n            if (!data.next()) {\n                close();\n\n                return false;\n            }\n\n            if (res != null) {\n                Value[] values = res.currentRow();\n\n                for (int c = 0; c < row.length; c++) {\n                    Value val = values[c];\n\n                    if (val instanceof GridH2ValueCacheObject) {\n                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n\n                        row[c] = valCacheObj.getObject(true);\n                    }\n                    else\n                        row[c] = val.getObject();\n                }\n            }\n            else {\n                for (int c = 0; c < row.length; c++)\n                    row[c] = data.getObject(c + 1);\n            }\n\n            return true;\n        }\n        catch (SQLException e) {\n            throw new IgniteSQLException(e);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override public boolean onHasNext() throws IgniteCheckedException {\n        return hasRow || (hasRow = fetchNext());\n    }\n\n    /** {@inheritDoc} */\n    @Override public T onNext() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n\n        hasRow = false;\n\n        return createRow();\n    }\n\n    /**\n     * @return Row.\n     */\n    protected abstract T createRow();\n\n    /** {@inheritDoc} */\n    @Override public void onRemove() {\n        throw new UnsupportedOperationException();\n    }\n\n    /** {@inheritDoc} */\n    @Override public void onClose() throws IgniteCheckedException {\n        if (data == null)\n            // Nothing to close.\n            return;\n\n        try {\n            data.close();\n        }\n        catch (SQLException e) {\n            throw new IgniteSQLException(e);\n        }\n        finally {\n            res = null;\n            data = null;\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(H2ResultSetIterator.class, this);\n    }\n}<fim_middle>// function below is long method\n"}