{"text": "<fim_prefix>\n<fim_suffix>public class BalancingColumnBreakingAlgorithm extends PageBreakingAlgorithm {\n    private int columnCount;\n    private List<Integer> idealBreaks;\n    public BalancingColumnBreakingAlgorithm(LayoutManager topLevelLM,\n            PageProvider pageProvider,\n            PageBreakingLayoutListener layoutListener,\n            int alignment, int alignmentLast,\n            MinOptMax footnoteSeparatorLength,\n            boolean partOverflowRecovery,\n            int columnCount) {\n        super(topLevelLM, pageProvider, layoutListener,\n                alignment, alignmentLast,\n                footnoteSeparatorLength, partOverflowRecovery, false, false);\n        this.columnCount = columnCount;\n        this.considerTooShort = true; //This is important!\n    }\n    /** {@inheritDoc} */\n    protected double computeDemerits(KnuthNode activeNode,\n            KnuthElement element, int fitnessClass, double r) {\n        double demerits = Double.MAX_VALUE;\n        if (idealBreaks == null) {\n            idealBreaks = calculateIdealBreaks(activeNode.position);\n        }\n        LinkedList<Integer> curPossibility = getPossibilityTrail(activeNode);\n        boolean notIdeal = false;\n        int idealDemerit = columnCount + 1 - curPossibility.size();\n        if (curPossibility.size() > idealBreaks.size()) {\n            return demerits;\n        }\n        for (int breakPos = 0; breakPos < curPossibility.size(); breakPos++) {\n            if (curPossibility.get(breakPos) != 0\n                    && !curPossibility.get(breakPos).equals(idealBreaks.get(breakPos))) {\n                notIdeal = true;\n                break;\n            }\n        }\n        if (!notIdeal) {\n            demerits = idealDemerit;\n        }\n        return demerits;\n    }\n    private List<Integer> calculateIdealBreaks(int startPos) {\n        List<ColumnContent> previousPreviousBreaks = null;\n        List<ColumnContent> previousBreaks = null;\n        List<ColumnContent> breaks = new ArrayList<ColumnContent>();\n        breaks.add(new ColumnContent(startPos, par.size() - 1));\n        do {\n            previousPreviousBreaks = previousBreaks;\n            previousBreaks = breaks;\n            breaks = getInitialBreaks(startPos, getAverageColumnLength(breaks));\n        } while (!breaks.equals(previousBreaks) && !breaks.equals(previousPreviousBreaks));\n        breaks = sortElementsForBreaks(breaks);\n        return getElementIdBreaks(breaks, startPos);\n    }\n    private static final class ColumnContent {\n        public final int startIndex;\n        public final int endIndex;\n        ColumnContent(int startIndex, int endIndex) {\n            this.startIndex = startIndex;\n            this.endIndex = endIndex;\n        }\n        @Override\n        public int hashCode() {\n            return startIndex << 16 | endIndex;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof ColumnContent)) {\n                return false;\n            } else {\n                ColumnContent other = (ColumnContent) obj;\n                return other.startIndex == startIndex && other.endIndex == endIndex;\n            }\n        }\n        @Override\n        public String toString() {\n            return startIndex + \"-\" + endIndex;\n        }\n    }\n    private int getAverageColumnLength(List<ColumnContent> columns) {\n        int totalLength = 0;\n        for (ColumnContent col : columns) {\n            totalLength += calcContentLength(par, col.startIndex, col.endIndex);\n        }\n        return totalLength / columnCount;\n    }\n    private List<ColumnContent> getInitialBreaks(int startIndex, int averageColLength) {\n        List<ColumnContent> initialColumns = new ArrayList<ColumnContent>();\n        int colStartIndex = startIndex;\n        int totalLength = 0;\n        int idealBreakLength = averageColLength;\n        int previousBreakLength = 0;\n        int prevBreakIndex = startIndex;\n        boolean prevIsBox = false;\n        int colNumber = 1;\n        for (int i = startIndex; i < par.size(); i++) {\n            KnuthElement element = (KnuthElement) par.get(i);\n            if (isLegalBreak(i, prevIsBox)) {\n                int breakLength = totalLength\n                        + (element instanceof KnuthPenalty ? element.getWidth() : 0);\n                if (breakLength > idealBreakLength && colNumber < columnCount) {\n                    int breakIndex;\n                    if (breakLength - idealBreakLength > idealBreakLength - previousBreakLength) {\n                        breakIndex = prevBreakIndex;\n                        totalLength = previousBreakLength;\n                    } else {\n                        breakIndex = element instanceof KnuthPenalty ? i : i - 1;\n                        totalLength = breakLength;\n                    }\n                    initialColumns.add(new ColumnContent(colStartIndex, breakIndex));\n                    i = getNextStartIndex(breakIndex);\n                    colStartIndex = i--;\n                    colNumber++;\n                    idealBreakLength += averageColLength;\n                } else {\n                    previousBreakLength = breakLength;\n                    prevBreakIndex = element instanceof KnuthPenalty ? i : i - 1;\n                    prevIsBox = false;\n                }\n            } else {\n                totalLength += element instanceof KnuthPenalty ? 0 : element.getWidth();\n                prevIsBox = element instanceof KnuthBox;\n            }\n        }\n        assert initialColumns.size() == columnCount - 1;\n        initialColumns.add(new ColumnContent(colStartIndex, par.size() - 1));\n        return initialColumns;\n    }\n    private int getNextStartIndex(int breakIndex) {\n        int startIndex = breakIndex;\n        @SuppressWarnings(\"unchecked\")\n        Iterator<KnuthElement> iter = par.listIterator(breakIndex);\n        while (iter.hasNext() && !(iter.next() instanceof KnuthBox)) {\n            startIndex++;\n        }\n        return startIndex;\n    }\n    private List<ColumnContent> sortElementsForBreaks(List<ColumnContent> breaks) {\n        boolean changes;\n        /* Relax factor to make balancing more visually appealing as in some cases\n         * strict balancing would lead to ragged column endings. */\n        int fFactor = 4000;\n        do {\n            changes = false;\n            ColumnContent curColumn = breaks.get(breaks.size() - 1);\n            int curColLength = calcContentLength(par, curColumn.startIndex, curColumn.endIndex);\n            for (int colIndex = (breaks.size() - 1); colIndex > 0; colIndex--) {\n                ColumnContent prevColumn = breaks.get(colIndex - 1);\n                int prevColLength = calcContentLength(par, prevColumn.startIndex, prevColumn.endIndex);\n                if (prevColLength < curColLength) {\n                    int newBreakIndex = curColumn.startIndex;\n                    boolean prevIsBox = true;\n                    while (newBreakIndex <= curColumn.endIndex && !(isLegalBreak(newBreakIndex, prevIsBox))) {\n                        newBreakIndex++;\n                        prevIsBox = par.get(newBreakIndex) instanceof KnuthBox;\n                    }\n                    if (newBreakIndex < curColumn.endIndex) {\n                        if (prevIsBox) {\n                            newBreakIndex--;\n                        }\n                        int newStartIndex = getNextStartIndex(newBreakIndex);\n                        int newPrevColLength = calcContentLength(par, prevColumn.startIndex, newBreakIndex);\n                        if (newPrevColLength <= fFactor + curColLength) {\n                            prevColumn = new ColumnContent(prevColumn.startIndex, newBreakIndex);\n                            breaks.set(colIndex - 1, prevColumn);\n                            breaks.set(colIndex, new ColumnContent(newStartIndex, curColumn.endIndex));\n                            prevColLength = calcContentLength(par, prevColumn.startIndex, newBreakIndex);\n                            changes = true;\n                        }\n                    }\n                }\n                curColLength = prevColLength;\n                curColumn = prevColumn;\n            }\n        } while (changes);\n        return breaks;\n    }\n    private boolean isLegalBreak(int index, boolean prevIsBox) {\n        KnuthElement element = (KnuthElement) par.get(index);\n        return element instanceof KnuthPenalty && element.getPenalty() < KnuthPenalty.INFINITE\n                || prevIsBox && element instanceof KnuthGlue;\n    }\n    private int calcContentLength(KnuthSequence par, int startIndex, int endIndex) {\n        return ElementListUtils.calcContentLength(par, startIndex, endIndex) + getPenaltyWidth(endIndex);\n    }\n    private int getPenaltyWidth(int index) {\n        KnuthElement element = (KnuthElement) par.get(index);\n        return element instanceof KnuthPenalty ? element.getWidth() : 0;\n    }\n    private List<Integer> getElementIdBreaks(List<ColumnContent> breaks, int startPos) {\n        List<Integer> elementIdBreaks = new ArrayList<Integer>();\n        elementIdBreaks.add(startPos);\n        for (ColumnContent column : breaks) {\n            if (breaks.get(breaks.size() - 1).equals(column)) {\n                continue;\n            }<fim_middle>// class below has no smell\n"}