{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.chain2.impl;\nimport org.apache.commons.chain2.Context;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * <p>Convenience base class for {@link Context} implementations.</p>\n *\n * <p>In addition to the minimal functionality required by the {@link Context}\n * interface, this class implements the recommended support for\n * <em>Attribute-Property Transparency</em>. This is implemented by\n * analyzing the available JavaBeans properties of this class (or its\n * subclass), exposes them as key-value pairs in the <code>Map</code>,\n * with the key being the name of the property itself.</p>\n *\n * <p><strong>IMPLEMENTATION NOTE</strong> - Because <code>empty</code> is a\n * read-only property defined by the <code>Map</code> interface, it may not\n * be utilized as an attribute key or property name.</p>\n *\n * @version $Id$\n */\npublic class ContextBase extends ContextMap<String, Object> {\n    // ------------------------------------------------------------ Constructors\n    /**\n     *\n     */\n    private static final long serialVersionUID = 20120724L;\n    /**\n     * Default, no argument constructor.\n     */\n    public ContextBase() {\n        super();\n        initialize();\n    }\n    /**\n     * <p>Initialize the contents of this {@link Context} by copying the\n     * values from the specified <code>Map</code>.  Any keys in <code>map</code>\n     * that correspond to local properties will cause the setter method for\n     * that property to be called.</p>\n     *\n     * @param map Map whose key-value pairs are added\n     *\n     * @throws IllegalArgumentException if an exception is thrown\n     *  writing a local property value\n     * @throws UnsupportedOperationException if a local property does not\n     *  have a write method.\n     */\n    public ContextBase(Map<? extends String, ? extends Object> map) {\n        super(map);\n        initialize();\n        putAll(map);\n    }\n    // ------------------------------------------------------ Instance Variables\n    // NOTE - PropertyDescriptor instances are not Serializable, so the\n    // following variables must be declared as transient.  When a ContextBase\n    // instance is deserialized, the no-arguments constructor is called,\n    // and the initialize() method called there will repoopulate them.\n    // Therefore, no special restoration activity is required.\n    /**\n     * <p>The <code>PropertyDescriptor</code>s for all JavaBeans properties\n     * of this {@link Context} implementation class, keyed by property name.\n     * This collection is allocated only if there are any JavaBeans\n     * properties.</p>\n     */\n    private transient Map<String, PropertyDescriptor> descriptors = null;\n    /**\n     * <p>The same <code>PropertyDescriptor</code>s as an array.</p>\n     */\n    private transient PropertyDescriptor[] pd = null;\n    /**\n     * <p>Distinguished singleton value that is stored in the map for each\n     * key that is actually a property.  This value is used to ensure that\n     * <code>equals()</code> comparisons will always fail.</p>\n     */\n    private static final Object singleton;\n    static {\n        singleton = new Serializable() {\n                private static final long serialVersionUID = 20120724L;\n                @Override\n                public boolean equals(Object object) {\n                    return false;\n                }\n                @Override\n                public int hashCode() {\n                    return super.hashCode();\n                }\n            };\n    }\n    /**\n     * <p>Zero-length array of parameter values for calling property getters.\n     * </p>\n     */\n    private static Object[] zeroParams = new Object[0];\n    // ------------------------------------------------------------- Map Methods\n    /**\n     * <p>Override the default <code>Map</code> behavior to clear all keys and\n     * values except those corresponding to JavaBeans properties.</p>\n     */\n    @Override\n    public void clear() {\n        if (descriptors == null) {\n            super.clear();\n        } else {\n            Iterator<String> keys = keySet().iterator();\n            while (keys.hasNext()) {\n                String key = keys.next();\n                if (!descriptors.containsKey(key)) {\n                    keys.remove();\n                }\n            }\n        }\n    }\n    /**\n     * <p>Override the default <code>Map</code> behavior to return\n     * <code>true</code> if the specified value is present in either the\n     * underlying <code>Map</code> or one of the local property values.</p>\n     *\n     * @param value the value look for in the context.\n     * @return <code>true</code> if found in this context otherwise\n     *  <code>false</code>.\n     * @throws IllegalArgumentException if a property getter\n     *  throws an exception\n     */\n    @Override\n    public boolean containsValue(Object value) {\n        // Case 1 -- no local properties\n        if (descriptors == null) {\n            return super.containsValue(value);\n        // Case 2 -- value found in the underlying Map\n        } else if (super.containsValue(value)) {\n            return true;\n        }\n        // Case 3 -- check the values of our readable properties\n        for (PropertyDescriptor aPd : pd) {\n            if (aPd.getReadMethod() != null) {\n                Object prop = readProperty(aPd);\n                if (value == null) {\n                    if (prop == null) {\n                        return true;\n                    }\n                } else if (value.equals(prop)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * <p>Override the default <code>Map</code> behavior to return a\n     * <code>Set</code> that meets the specified default behavior except\n     * for attempts to remove the key for a property of the {@link Context}\n     * implementation class, which will throw\n     * <code>UnsupportedOperationException</code>.</p>\n     *\n     * @return Set of entries in the Context.\n     */\n<fim_suffix>    @Override\n    public Set<Entry<String, Object>> entrySet() {\n        return new EntrySetImpl();\n    }\n    /**\n     * <p>Override the default <code>Map</code> behavior to return the value\n     * of a local property if the specified key matches a local property name.\n     * </p>\n     *\n     * <p><strong>IMPLEMENTATION NOTE</strong> - If the specified\n     * <code>key</code> identifies a write-only property, <code>null</code>\n     * will arbitrarily be returned, in order to avoid difficulties implementing\n     * the contracts of the <code>Map</code> interface.</p>\n     *\n     * @param key Key of the value to be returned\n     * @return The value for the specified key.\n     *\n     * @throws IllegalArgumentException if an exception is thrown\n     *  reading this local property value\n     * @throws UnsupportedOperationException if this local property does not\n     *  have a read method.\n     */\n    @Override\n    public Object get(Object key) {\n        // Case 1 -- no local properties\n        if (descriptors == null) {\n            return super.get(key);\n        }\n        // Case 2 -- this is a local property\n        if (key != null) {\n            PropertyDescriptor descriptor = descriptors.get(key);\n            if (descriptor != null) {\n                if (descriptor.getReadMethod() != null) {\n                    return readProperty(descriptor);\n                } else {\n                    return null;\n                }\n            }\n        }\n        // Case 3 -- retrieve value from our underlying Map\n        return super.get(key);\n    }\n    /**\n     * <p>Override the default <code>Map</code> behavior to return\n     * <code>true</code> if the underlying <code>Map</code> only contains\n     * key-value pairs for local properties (if any).</p>\n     *\n     * @return <code>true</code> if this Context is empty, otherwise\n     *  <code>false</code>.\n     */\n    @Override\n    public boolean isEmpty() {\n        // Case 1 -- no local properties\n        if (descriptors == null) {<fim_middle>// function below has no smell\n"}