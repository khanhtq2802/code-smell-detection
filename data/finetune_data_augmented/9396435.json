{"text": "<fim_prefix> *\n * @author Clemens Eisserer\n */\npublic class XRCompositeManager {\n    private static boolean enableGradCache = true;\n    private static XRCompositeManager instance;\n    private static final int SOLID = 0;\n    private static final int TEXTURE = 1;\n    private static final int GRADIENT = 2;\n    int srcType;\n    XRSolidSrcPict solidSrc32;\n    XRSurfaceData texture;\n    XRSurfaceData gradient;\n    int alphaMask = XRUtils.None;\n    XRColor solidColor = new XRColor();\n    float extraAlpha = 1.0f;\n    byte compRule = XRUtils.PictOpOver;\n    XRColor alphaColor = new XRColor();\n    XRSurfaceData solidSrcPict;\n    int alphaMaskPict;\n    int gradCachePixmap;\n    int gradCachePicture;\n    boolean xorEnabled = false;\n    int validatedPixel = 0;\n    Composite validatedComp;\n    Paint validatedPaint;\n    float validatedExtraAlpha = 1.0f;\n    XRBackend con;\n    MaskTileManager maskBuffer;\n    XRTextRenderer textRenderer;\n    XRMaskImage maskImage;\n    public static synchronized XRCompositeManager getInstance(\n            XRSurfaceData surface) {\n        if (instance == null) {\n            instance = new XRCompositeManager(surface);\n        }\n        return instance;\n    }\n    private XRCompositeManager(XRSurfaceData surface) {\n        con = new XRBackendNative();\n        String gradProp =\n            AccessController.doPrivileged(new PrivilegedAction<String>() {\n                public String run() {\n                    return System.getProperty(\"sun.java2d.xrgradcache\");\n                }\n            });\n        enableGradCache = gradProp == null ||\n                          !(gradProp.equalsIgnoreCase(\"false\") ||\n                          gradProp.equalsIgnoreCase(\"f\"));\n        XRPaints.register(this);\n        initResources(surface);\n        maskBuffer = new MaskTileManager(this, surface.getXid());\n        textRenderer = new XRTextRenderer(this);\n        maskImage = new XRMaskImage(this, surface.getXid());\n    }\n    public void initResources(XRSurfaceData surface) {\n        int parentXid = surface.getXid();\n        solidSrc32 = new XRSolidSrcPict(con, parentXid);\n        setForeground(0);\n        int extraAlphaMask = con.createPixmap(parentXid, 8, 1, 1);\n        alphaMaskPict = con.createPicture(extraAlphaMask,\n                XRUtils.PictStandardA8);\n        con.setPictureRepeat(alphaMaskPict, XRUtils.RepeatNormal);\n        con.renderRectangle(alphaMaskPict, XRUtils.PictOpClear,\n                XRColor.NO_ALPHA, 0, 0, 1, 1);\n        if (enableGradCache) {\n            gradCachePixmap = con.createPixmap(parentXid, 32,\n                    MaskTileManager.MASK_SIZE, MaskTileManager.MASK_SIZE);\n            gradCachePicture = con.createPicture(gradCachePixmap,\n                    XRUtils.PictStandardARGB32);\n        }\n    }\n    public void setForeground(int pixel) {\n        solidColor.setColorValues(pixel);\n    }\n    public void setGradientPaint(XRSurfaceData gradient) {\n        if (this.gradient != null) {\n            con.freePicture(this.gradient.picture);\n        }\n        this.gradient = gradient;\n        srcType = GRADIENT;\n    }\n    public void setTexturePaint(XRSurfaceData texture) {\n        this.texture = texture;\n        this.srcType = TEXTURE;\n    }\n    public void XRResetPaint() {\n        srcType = SOLID;\n    }\n    public void validateCompositeState(Composite comp, AffineTransform xform,\n            Paint paint, SunGraphics2D sg2d) {\n        boolean updatePaint = (paint != validatedPaint) || paint == null;\n        // validate composite\n        if ((comp != validatedComp)) {\n            if (comp != null) {\n                setComposite(comp);\n            } else {\n                comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);\n                setComposite(comp);\n            }\n            // the paint state is dependent on the composite state, so make\n            // sure we update the color below\n            updatePaint = true;\n            validatedComp = comp;\n        }\n        if (sg2d != null && (validatedPixel != sg2d.pixel  || updatePaint)) {\n            validatedPixel = sg2d.pixel;\n            setForeground(validatedPixel);\n        }\n        // validate paint\n        if (updatePaint) {\n            if (paint != null && sg2d != null\n                    && sg2d.paintState >= SunGraphics2D.PAINT_GRADIENT) {\n                XRPaints.setPaint(sg2d, paint);\n            } else {\n                XRResetPaint();\n            }\n            validatedPaint = paint;\n        }\n        if (srcType != SOLID) {\n            AffineTransform at = (AffineTransform) xform.clone();\n            try {\n                at.invert();\n            } catch (NoninvertibleTransformException e) {\n                at.setToIdentity();\n            }\n            getCurrentSource().validateAsSource(at, -1, XRUtils.ATransOpToXRQuality(sg2d.interpolationType));\n        }\n    }\n    private void setComposite(Composite comp) {\n        if (comp instanceof AlphaComposite) {\n            AlphaComposite aComp = (AlphaComposite) comp;\n            validatedExtraAlpha = aComp.getAlpha();\n            this.compRule = XRUtils.j2dAlphaCompToXR(aComp.getRule());\n            this.extraAlpha = validatedExtraAlpha;\n            if (extraAlpha == 1.0f) {\n                alphaMask = XRUtils.None;\n                alphaColor.alpha = XRColor.FULL_ALPHA.alpha;\n            } else {\n                alphaColor.alpha = XRColor\n                        .byteToXRColorValue((int) (extraAlpha * 255));\n                alphaMask = alphaMaskPict;\n                con.renderRectangle(alphaMaskPict, XRUtils.PictOpSrc,\n                        alphaColor, 0, 0, 1, 1);\n            }\n            xorEnabled = false;\n        } else if (comp instanceof XORComposite) {\n            /* XOR composite validation is handled in XRSurfaceData */\n            xorEnabled = true;\n        } else {\n            throw new InternalError(\n                    \"Composite accaleration not implemented for: \"\n                            + comp.getClass().getName());\n        }\n    }\n    public boolean maskRequired() {\n        return (!xorEnabled)\n                && ((srcType != SOLID)\n                        || (srcType == SOLID && (solidColor.alpha != 0xffff) || (extraAlpha != 1.0f)));\n    }\n    public void XRComposite(int src, int mask, int dst, int srcX, int srcY,\n            int maskX, int maskY, int dstX, int dstY, int width, int height) {\n        int cachedSrc = (src == XRUtils.None) ? getCurrentSource().picture : src;\n        int cachedX = srcX;\n        int cachedY = srcY;\n        if (enableGradCache && gradient != null\n                && cachedSrc == gradient.picture) {\n            con.renderComposite(XRUtils.PictOpSrc, gradient.picture,\n                    XRUtils.None, gradCachePicture, srcX, srcY, 0, 0, 0, 0,\n                    width, height);\n            cachedX = 0;\n            cachedY = 0;\n            cachedSrc = gradCachePicture;\n        }\n        con.renderComposite(compRule, cachedSrc, mask, dst, cachedX, cachedY,\n                maskX, maskY, dstX, dstY, width, height);\n    }\n    public void XRRenderRectangles(XRSurfaceData dst, GrowableRectArray rects) {\n        if (xorEnabled) {\n            con.GCRectangles(dst.getXid(), dst.getGC(), rects);\n        } else {\n            if (rects.getSize() == 1) {\n                con.renderRectangle(dst.getPicture(), compRule, solidColor,\n                        rects.getX(0), rects.getY(0), rects.getWidth(0), rects.getHeight(0));\n            } else {\n                con.renderRectangles(dst.getPicture(), compRule, solidColor, rects);\n            }\n        }\n    }\n<fim_suffix>    public void XRCompositeRectangles(XRSurfaceData dst, GrowableRectArray rects) {\n        int srcPict = getCurrentSource().picture;\n        for(int i=0; i < rects.getSize(); i++) {\n            int x = rects.getX(i);\n            int y = rects.getY(i);\n            int width = rects.getWidth(i);\n            int height = rects.getHeight(i);\n            con.renderComposite(compRule, srcPict, XRUtils.None, dst.picture, x, y, 0, 0, x, y, width, height);\n        }\n    }<fim_middle>// function below has no smell\n"}