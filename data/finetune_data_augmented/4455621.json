{"text": "<fim_prefix>  private ExpressionTreeMaterializer() {\n  }\n  public static LogicalExpression materialize(LogicalExpression expr, VectorAccessible batch, ErrorCollector errorCollector, FunctionLookupContext functionLookupContext) {\n    return ExpressionTreeMaterializer.materialize(expr, batch, errorCollector, functionLookupContext, false, false);\n  }\n  public static LogicalExpression materializeAndCheckErrors(LogicalExpression expr, VectorAccessible batch, FunctionLookupContext functionLookupContext) throws SchemaChangeException {\n    ErrorCollector collector = new ErrorCollectorImpl();\n    LogicalExpression e = ExpressionTreeMaterializer.materialize(expr, batch, collector, functionLookupContext, false, false);\n    if (collector.hasErrors()) {\n      throw new SchemaChangeException(String.format(\"Failure while trying to materialize incoming schema.  Errors:\\n %s.\", collector.toErrorString()));\n    }\n    return e;\n  }\n  public static LogicalExpression materialize(LogicalExpression expr, VectorAccessible batch, ErrorCollector errorCollector, FunctionLookupContext functionLookupContext,\n                                              boolean allowComplexWriterExpr) {\n    return materialize(expr, batch, errorCollector, functionLookupContext, allowComplexWriterExpr, false);\n  }\n  public static LogicalExpression materializeFilterExpr(LogicalExpression expr, TupleMetadata fieldTypes, ErrorCollector errorCollector, FunctionLookupContext functionLookupContext) {\n    final FilterMaterializeVisitor filterMaterializeVisitor = new FilterMaterializeVisitor(fieldTypes, errorCollector);\n    return expr.accept(filterMaterializeVisitor, functionLookupContext);\n  }\n  /**\n   * Materializes logical expression taking into account passed parameters.\n   * Is used to materialize logical expression that contains reference to one batch.\n   *\n   * @param expr logical expression to be materialized\n   * @param batch batch instance\n   * @param errorCollector error collector\n   * @param functionLookupContext context to find drill function holder\n   * @param allowComplexWriterExpr true if complex expressions are allowed\n   * @param unionTypeEnabled true if union type is enabled\n   * @return materialized logical expression\n   */\n  public static LogicalExpression materialize(LogicalExpression expr,\n                                              VectorAccessible batch,\n                                              ErrorCollector errorCollector,\n                                              FunctionLookupContext functionLookupContext,\n                                              boolean allowComplexWriterExpr,\n                                              boolean unionTypeEnabled) {\n    Map<VectorAccessible, BatchReference> batches = Maps.newHashMap();\n    batches.put(batch, null);\n    return materialize(expr, batches, errorCollector, functionLookupContext, allowComplexWriterExpr, unionTypeEnabled);\n  }\n  /**\n   * Materializes logical expression taking into account passed parameters.\n   * Is used to materialize logical expression that can contain several batches with or without custom batch reference.\n   *\n   * @param expr logical expression to be materialized\n   * @param batches one or more batch instances used in expression\n   * @param errorCollector error collector\n   * @param functionLookupContext context to find drill function holder\n   * @param allowComplexWriterExpr true if complex expressions are allowed\n   * @param unionTypeEnabled true if union type is enabled\n   * @return materialized logical expression\n   */\n  public static LogicalExpression materialize(LogicalExpression expr,\n                                              Map<VectorAccessible, BatchReference> batches,\n                                              ErrorCollector errorCollector,\n                                              FunctionLookupContext functionLookupContext,\n                                              boolean allowComplexWriterExpr,\n                                              boolean unionTypeEnabled) {\n    LogicalExpression out = expr.accept(\n        new MaterializeVisitor(batches, errorCollector, allowComplexWriterExpr, unionTypeEnabled),\n        functionLookupContext);\n    if (!errorCollector.hasErrors()) {\n      out = out.accept(ConditionalExprOptimizer.INSTANCE, null);\n    }\n    if (out instanceof NullExpression) {\n      return new TypedNullConstant(Types.optional(MinorType.INT));\n    } else {\n      return out;\n    }\n  }\n  public static LogicalExpression convertToNullableType(LogicalExpression fromExpr, MinorType toType, FunctionLookupContext functionLookupContext, ErrorCollector errorCollector) {\n    String funcName = \"convertToNullable\" + toType.toString();\n    List<LogicalExpression> args = Lists.newArrayList();\n    args.add(fromExpr);\n    FunctionCall funcCall = new FunctionCall(funcName, args, ExpressionPosition.UNKNOWN);\n    FunctionResolver resolver = FunctionResolverFactory.getResolver(funcCall);\n    DrillFuncHolder matchedConvertToNullableFuncHolder = functionLookupContext.findDrillFunction(resolver, funcCall);\n    if (matchedConvertToNullableFuncHolder == null) {\n      logFunctionResolutionError(errorCollector, funcCall);\n      return NullExpression.INSTANCE;\n    }\n    return matchedConvertToNullableFuncHolder.getExpr(funcName, args, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression addCastExpression(LogicalExpression fromExpr, MajorType toType, FunctionLookupContext functionLookupContext, ErrorCollector errorCollector) {\n    return addCastExpression(fromExpr, toType, functionLookupContext, errorCollector, true);\n  }\n  public static LogicalExpression addCastExpression(LogicalExpression fromExpr, MajorType toType, FunctionLookupContext functionLookupContext, ErrorCollector errorCollector, boolean exactResolver) {\n    String castFuncName = FunctionReplacementUtils.getCastFunc(toType.getMinorType());\n    List<LogicalExpression> castArgs = Lists.newArrayList();\n    castArgs.add(fromExpr);  //input_expr\n    if (fromExpr.getMajorType().getMinorType() == MinorType.UNION && toType.getMinorType() == MinorType.UNION) {\n      return fromExpr;\n    }\n    if (Types.isDecimalType(toType)) {\n      // Add the scale and precision to the arguments of the implicit cast\n      castArgs.add(new ValueExpressions.IntExpression(toType.getPrecision(), null));\n      castArgs.add(new ValueExpressions.IntExpression(toType.getScale(), null));\n    } else if (!Types.isFixedWidthType(toType) && !Types.isUnion(toType)) {\n      /* We are implicitly casting to VARCHAR so we don't have a max length,\n       * using an arbitrary value. We trim down the size of the stored bytes\n       * to the actual size so this size doesn't really matter.\n       */\n      castArgs.add(new ValueExpressions.LongExpression(Types.MAX_VARCHAR_LENGTH, null));\n    }\n    FunctionCall castCall = new FunctionCall(castFuncName, castArgs, ExpressionPosition.UNKNOWN);\n    FunctionResolver resolver;\n    if (exactResolver) {\n      resolver = FunctionResolverFactory.getExactResolver(castCall);\n    } else {\n      resolver = FunctionResolverFactory.getResolver(castCall);\n    }\n    DrillFuncHolder matchedCastFuncHolder = functionLookupContext.findDrillFunction(resolver, castCall);\n    if (matchedCastFuncHolder == null) {\n      logFunctionResolutionError(errorCollector, castCall);\n      return NullExpression.INSTANCE;\n    }\n    return matchedCastFuncHolder.getExpr(castFuncName, castArgs, ExpressionPosition.UNKNOWN);\n  }\n  private static void logFunctionResolutionError(ErrorCollector errorCollector, FunctionCall call) {\n    // add error to collector\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Missing function implementation: \");\n    sb.append(\"[\");\n    sb.append(call.getName());\n    sb.append(\"(\");\n    boolean first = true;\n    for(LogicalExpression e : call.args) {\n      TypeProtos.MajorType mt = e.getMajorType();\n      if (first) {\n        first = false;\n      } else {\n        sb.append(\", \");\n      }\n      sb.append(mt.getMinorType().name());\n      sb.append(\"-\");\n      sb.append(mt.getMode().name());\n    }\n    sb.append(\")\");\n    sb.append(\"]\");\n    errorCollector.addGeneralError(call.getPosition(), sb.toString());\n  }\n  /**\n   * Visitor that wraps schema path into value vector read expression\n   * if schema path is present in one of the batches,\n   * otherwise instance of null expression.\n   */\n<fim_suffix>  private static class MaterializeVisitor extends AbstractMaterializeVisitor {\n    private final Map<VectorAccessible, BatchReference> batches;\n    public MaterializeVisitor(Map<VectorAccessible, BatchReference> batches,\n                              ErrorCollector errorCollector,\n                              boolean allowComplexWriter,\n                              boolean unionTypeEnabled) {\n      super(errorCollector, allowComplexWriter, unionTypeEnabled);\n      this.batches = batches;\n    }\n    @Override\n    public LogicalExpression visitSchemaPath(final SchemaPath path, FunctionLookupContext functionLookupContext) {\n      TypedFieldId tfId = null;\n      BatchReference batchRef = null;\n      for (Map.Entry<VectorAccessible, BatchReference> entry : batches.entrySet()) {\n        tfId = entry.getKey().getValueVectorId(path);\n        if (tfId != null) {\n          batchRef = entry.getValue();\n          break;\n        }\n      }\n      if (tfId == null) {\n        logger.warn(\"Unable to find value vector of path {}, returning null instance.\", path);\n        return NullExpression.INSTANCE;\n      } else {\n        return new ValueVectorReadExpression(tfId, batchRef);\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}