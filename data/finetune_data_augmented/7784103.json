{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.wicket.behavior;\n\nimport org.apache.wicket.Component;\nimport org.apache.wicket.IRequestListener;\nimport org.apache.wicket.markup.ComponentTag;\nimport org.apache.wicket.request.mapper.parameter.INamedParameters;\nimport org.apache.wicket.request.mapper.parameter.PageParameters;\nimport org.apache.wicket.util.lang.Args;\n\nimport java.util.List;\n\n/**\n * Abstract class for handling Ajax roundtrips. This class serves as a base for javascript specific\n * implementations, like ones based on Dojo or Scriptaculous, or Wicket's default.\n * \n * @author Eelco Hillenius\n * @author Ralf Ebert\n * @author Igor Vaynberg\n */\n<fim_suffix>public abstract class AbstractAjaxBehavior extends Behavior implements IRequestListener\n{\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** the component that this handler is bound to. */\n\tprivate Component component;\n\n\t/**\n\t * Constructor.\n\t */\n\tpublic AbstractAjaxBehavior()\n\t{\n\t}\n\n\t/**\n\t * Bind this handler to the given component.\n\t * \n\t * @param hostComponent\n\t *            the component to bind to\n\t */\n\t@Override\n\tpublic final void bind(final Component hostComponent)\n\t{\n\t\tArgs.notNull(hostComponent, \"hostComponent\");\n\n\t\tif (component != null)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"this kind of handler cannot be attached to \" +\n\t\t\t\t\"multiple components; it is already attached to component \" + component +\n\t\t\t\t\", but component \" + hostComponent + \" wants to be attached too\");\n\t\t}\n\n\t\tcomponent = hostComponent;\n\n\t\t// call the callback\n\t\tonBind();\n\t}\n\n\t/**\n\t * Gets the url that references this handler.\n\t * \n\t * @return the url that references this handler\n\t */\n\tpublic CharSequence getCallbackUrl()\n\t{\n\t\tComponent component = getComponent();\n\t\tif (component == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Behavior must be bound to a component to create the URL\");\n\t\t}\n\n\t\tPageParameters parameters = new PageParameters();\n\t\tPageParameters pageParameters = component.getPage().getPageParameters();\n\t\tList<INamedParameters.NamedPair> allNamedInPath = pageParameters.getAllNamedByType(INamedParameters.Type.PATH);\n\t\tfor (INamedParameters.NamedPair namedPair : allNamedInPath) {\n\t\t\tparameters.add(namedPair.getKey(), namedPair.getValue(), INamedParameters.Type.PATH);\n\t\t}\n\t\treturn getComponent().urlForListener(this, parameters);\n\t}\n\n\t@Override\n\tpublic final void onComponentTag(final Component component, final ComponentTag tag)\n\t{\n\t\tonComponentTag(tag);\n\t}\n\n\t@Override\n\tpublic final void afterRender(final Component hostComponent)\n\t{\n\t\tonComponentRendered();\n\t}\n\n\t/**\n\t * Gets the component that this handler is bound to.\n\t * \n\t * @return the component that this handler is bound to\n\t */\n\tprotected final Component getComponent()\n\t{\n\t\treturn component;\n\t}\n\n\t/**\n\t * Called any time a component that has this handler registered is rendering the component tag.\n\t * Use this method e.g. to bind to javascript event handlers of the tag\n\t * \n\t * @param tag\n\t *            the tag that is rendered\n\t */\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t}\n\n\t/**\n\t * Called when the component was bound to it's host component. You can get the bound host\n\t * component by calling getComponent.\n\t */\n\tprotected void onBind()\n\t{\n\t}\n\n\t/**\n\t * Called to indicate that the component that has this handler registered has been rendered. Use\n\t * this method to do any cleaning up of temporary state\n\t */\n\tprotected void onComponentRendered()\n\t{\n\t}\n\n\t@Override\n\tpublic final void unbind(Component component)\n\t{\n\t\tonUnbind();\n\n\t\tthis.component = null;\n\n\t\tsuper.unbind(component);\n\t}\n\n\t/**\n\t * Called when the behavior is removed from its component. The bound host component is\n\t * still available through {@linkplain #getComponent()}. The relation to it will be removed\n\t * right after the finish of the execution of this method.\n\t */\n\tprotected void onUnbind()\n\t{\n\t}\n}<fim_middle>// class below has no smell\n"}