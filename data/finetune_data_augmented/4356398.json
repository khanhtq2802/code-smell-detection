{"text": "<fim_prefix>\n<fim_suffix>    @Override\n    ValueNode preprocess(int numTables,\n\t\t\t\t\t\t\t\tFromList outerFromList,\n\t\t\t\t\t\t\t\tSubqueryList outerSubqueryList,\n\t\t\t\t\t\t\t\tPredicateList outerPredicateList) \n\t\t\t\t\tthrows StandardException\n\t{\n\t\t/* Only preprocess this node once.  We may get called multiple times\n\t\t * due to tree transformations.\n\t\t */\n\t\tif (preprocessed)\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t\tpreprocessed = true;\n\t\tboolean\t\tflattenable;\n\t\tValueNode\ttopNode = this;\n        final boolean haveOrderBy; // need to remember for flattening decision\n        // Push the order by list down to the ResultSet\n        if (orderByList != null) {\n            haveOrderBy = true;\n            // If we have more than 1 ORDERBY columns, we may be able to\n            // remove duplicate columns, e.g., \"ORDER BY 1, 1, 2\".\n            if (orderByList.size() > 1)\n            {\n                orderByList.removeDupColumns();\n            }\n            resultSet.pushOrderByList(orderByList);\n            orderByList = null;\n        } else {\n            haveOrderBy = false;\n        }\n        resultSet = resultSet.preprocess(numTables, null, (FromList) null);\n        if (leftOperand != null)\n        {\n            leftOperand = leftOperand.preprocess(numTables,\n                    outerFromList, outerSubqueryList, outerPredicateList);\n        }\n\t\t// Eliminate any unnecessary DISTINCTs\n\t\tif (resultSet instanceof SelectNode)\n\t\t{\n\t\t\tif (((SelectNode) resultSet).hasDistinct())\n\t\t\t{\n\t\t\t\t((SelectNode) resultSet).clearDistinct();\n\t\t\t\t/* We need to remember to check for single unique value\n\t\t\t\t * at execution time for expression subqueries.\n\t\t\t\t */\n\t\t\t\tif  (subqueryType == EXPRESSION_SUBQUERY)\n\t\t\t\t{\n\t\t\t\t\tdistinctExpression = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Lame transformation - For IN/ANY subqueries, if\n\t\t * result set is guaranteed to return at most 1 row\n\t\t * and it is not correlated\n\t\t * then convert the subquery into the matching expression\n\t\t * subquery type.  For example:\n\t\t *\tc1 in (select min(c1) from t2)\n\t\t * becomes:\n\t\t *\tc1 = (select min(c1) from t2)\n\t\t * (This actually showed up in an app that a potential customer\n\t\t * was porting from SQL Server.)\n\t\t * The transformed query can then be flattened if appropriate.\n\t\t */\n\t\tif ((isIN() || isANY()) &&\n\t\t\tresultSet.returnsAtMostOneRow())\n\t\t{\n\t\t\tif (! hasCorrelatedCRs())\n\t\t\t{\n\t\t\t\tchangeToCorrespondingExpressionType();\n\t\t\t}\n\t\t}\n\t\t/* NOTE: Flattening occurs before the pushing of\n\t\t * the predicate, since the pushing will add a node \n\t\t * above the SubqueryNode.\n\t\t */\n\t\t/* Values subquery is flattenable if:\n\t\t *  o It is not under an OR.\n         *  o It is not a subquery in a having clause (DERBY-3257)\n\t\t *  o It is an expression subquery on the right side\n\t\t *\t  of a BinaryComparisonOperatorNode.\n\t\t *  o Either a) it does not appear within a WHERE clause, or \n\t\t *           b) it appears within a WHERE clause but does not itself \n\t\t *              contain a WHERE clause with other subqueries in it. \n\t\t *          (DERBY-3301)\n\t\t */\n\t\tflattenable = (resultSet instanceof RowResultSetNode) &&\n\t\t\t\t\t  underTopAndNode && !havingSubquery &&\n                      !haveOrderBy &&\n                      offset == null &&\n                      fetchFirst == null &&\n\t\t\t\t\t  !isWhereExistsAnyInWithWhereSubquery() &&\n                      parentComparisonOperator != null;\n\t\tif (flattenable)\n\t\t{\n\t\t\t/* If we got this far and we are an expression subquery\n\t\t\t * then we want to set leftOperand to be the left side\n\t\t\t * of the comparison in case we pull the comparison into\n\t\t\t * the flattened subquery.\n\t\t\t */\n\t\t\tleftOperand = parentComparisonOperator.getLeftOperand();\n\t\t\t// Flatten the subquery\n\t\t\tRowResultSetNode rrsn = (RowResultSetNode) resultSet;\n            FromList fl = new FromList(getContextManager());\n\t\t\t// Remove ourselves from the outer subquery list\n\t\t\touterSubqueryList.removeElement(this);\n\t\t\t/* We only need to add the table from the subquery into \n\t\t\t * the outer from list if the subquery itself contains\n\t\t\t * another subquery.  Otherwise, it just becomes a constant.\n\t\t\t */\n\t\t\tif (rrsn.subquerys.size() != 0)\n\t\t\t{\n\t\t\t\tfl.addElement(rrsn);\n\t\t\t\touterFromList.destructiveAppend(fl);\n\t\t\t}\n\t\t\t/* Append the subquery's subquery list to the \n\t\t\t * outer subquery list.\n\t\t\t */\n\t\t\touterSubqueryList.destructiveAppend(rrsn.subquerys);\n\t\t\t/* return the new join condition \n\t\t\t * If we are flattening an EXISTS then there is no new join\n\t\t\t * condition since there is no leftOperand.  Simply return\n\t\t\t * TRUE.\n\t\t\t *\n\t\t\t * NOTE: The outer where clause, etc. has already been normalized,\n\t\t\t * so we simply return the BinaryComparisonOperatorNode above\n\t\t\t * the new join condition.\n\t\t\t */\n\t\t\treturn getNewJoinCondition(leftOperand, getRightOperand());\n\t\t}\n\t\t/* Select subquery is flattenable if:\n\t\t *  o It is not under an OR.\n\t\t *  o The subquery type is IN, ANY or EXISTS or\n\t\t *    an expression subquery on the right side\n\t\t *\t  of a BinaryComparisonOperatorNode.\n\t\t *  o There are no aggregates in the select list\n\t\t *  o There is no group by clause or having clause.\n\t\t *  o There is a uniqueness condition that ensures\n\t\t *\t  that the flattening of the subquery will not\n\t\t *\t  introduce duplicates into the result set.\n         *  o The subquery is not part of a having clause (DERBY-3257)\n\t\t *  o There are no windows defined on it\n\t\t *\n\t\t *\tOR,\n\t\t *  o The subquery is NOT EXISTS, NOT IN, ALL (beetle 5173).\n\t\t *  o Either a) it does not appear within a WHERE clause, or \n\t\t *           b) it appears within a WHERE clause but does not itself \n\t\t *              contain a WHERE clause with other subqueries in it. \n\t\t *          (DERBY-3301)\n\t\t */\n\t\tboolean flattenableNotExists = (isNOT_EXISTS() || canAllBeFlattened());\n\t\tflattenable = (resultSet instanceof SelectNode) &&\n \t\t\t          !((SelectNode)resultSet).hasWindows() &&\n                      !haveOrderBy &&\n                      offset == null &&\n                      fetchFirst == null &&\n\t\t\t\t\t  underTopAndNode && !havingSubquery &&\n\t\t\t\t\t  !isWhereExistsAnyInWithWhereSubquery() &&\n\t\t\t\t\t  (isIN() || isANY() || isEXISTS() || flattenableNotExists ||\n                       parentComparisonOperator != null);\n\t\tif (flattenable)\n\t\t{\n\t\t\tSelectNode\tselect = (SelectNode) resultSet;\n\t\t\tif ((!select.hasAggregatesInSelectList()) &&\n\t\t\t    (select.havingClause == null))\n\t\t\t{\n\t\t\t\tValueNode origLeftOperand = leftOperand;\n\t\t\t\t/* Check for uniqueness condition. */\n\t\t\t\t/* Is the column being returned by the subquery\n\t\t\t\t * a candidate for an = condition?\n\t\t\t\t */\n\t\t\t\tboolean additionalEQ =\n\t\t\t\t\t\t\t(subqueryType == IN_SUBQUERY) ||\n\t\t\t\t\t\t\t(subqueryType == EQ_ANY_SUBQUERY);\n\t\t\t\tadditionalEQ = additionalEQ &&\n\t\t\t\t\t\t\t\t((leftOperand instanceof ConstantNode) ||\n\t\t\t\t\t\t\t\t (leftOperand instanceof ColumnReference) ||\n\t\t\t\t\t\t\t\t (leftOperand.requiresTypeFromContext()));\n\t\t\t\t/* If we got this far and we are an expression subquery\n\t\t\t\t * then we want to set leftOperand to be the left side\n\t\t\t\t * of the comparison in case we pull the comparison into\n\t\t\t\t * the flattened subquery.\n\t\t\t\t */\n                if (parentComparisonOperator != null)\n\t\t\t\t{\n\t\t\t\t\tleftOperand = parentComparisonOperator.getLeftOperand();\n\t\t\t\t}\n\t\t\t\t/* Never flatten to normal join for NOT EXISTS.\n\t\t\t\t */\n\t\t\t\tif ((! flattenableNotExists) && select.uniqueSubquery(additionalEQ))\n\t\t\t\t{\n\t\t\t\t\t// Flatten the subquery\n\t\t\t\t\treturn flattenToNormalJoin(numTables,<fim_middle>// function below is long method\n"}